/*! For license information please see LICENSES */
(window.webpackJsonp=window.webpackJsonp||[]).push([[1],Array(220).concat([function(t,e,n){"use strict";n.d(e,"a",(function(){return r})),n.d(e,"b",(function(){return o})),n.d(e,"c",(function(){return c})),n.d(e,"d",(function(){return l})),n.d(e,"e",(function(){return d})),n.d(e,"f",(function(){return h})),n.d(e,"g",(function(){return f})),n.d(e,"h",(function(){return m})),n.d(e,"i",(function(){return y})),n.d(e,"j",(function(){return O})),n.d(e,"k",(function(){return x})),n.d(e,"l",(function(){return v})),n.d(e,"n",(function(){return w})),n.d(e,"m",(function(){return j})),n.d(e,"o",(function(){return E})),n.d(e,"r",(function(){return $})),n.d(e,"p",(function(){return C})),n.d(e,"q",(function(){return N})),n.d(e,"s",(function(){return R})),n.d(e,"t",(function(){return S})),n.d(e,"u",(function(){return T})),n.d(e,"v",(function(){return I})),n.d(e,"w",(function(){return A})),n.d(e,"x",(function(){return k})),n.d(e,"y",(function(){return D})),n.d(e,"z",(function(){return _})),n.d(e,"A",(function(){return F})),n.d(e,"B",(function(){return P})),n.d(e,"C",(function(){return M})),n.d(e,"D",(function(){return B})),n.d(e,"E",(function(){return L})),n.d(e,"F",(function(){return V})),n.d(e,"G",(function(){return z})),n.d(e,"H",(function(){return U})),n.d(e,"J",(function(){return W})),n.d(e,"I",(function(){return G})),n.d(e,"K",(function(){return H})),n.d(e,"L",(function(){return K})),n.d(e,"M",(function(){return X})),n.d(e,"N",(function(){return Y})),n.d(e,"O",(function(){return Q})),n.d(e,"Q",(function(){return J})),n.d(e,"P",(function(){return Z})),n.d(e,"R",(function(){return tt})),n.d(e,"S",(function(){return et})),n.d(e,"T",(function(){return nt})),n.d(e,"V",(function(){return at})),n.d(e,"U",(function(){return st})),n.d(e,"W",(function(){return ot})),n.d(e,"X",(function(){return it})),n.d(e,"Y",(function(){return ct})),n.d(e,"Z",(function(){return ut})),n.d(e,"ab",(function(){return lt})),n.d(e,"bb",(function(){return pt})),n.d(e,"cb",(function(){return ht})),n.d(e,"eb",(function(){return ft})),n.d(e,"ib",(function(){return mt})),n.d(e,"hb",(function(){return bt})),n.d(e,"jb",(function(){return gt})),n.d(e,"kb",(function(){return yt})),n.d(e,"mb",(function(){return Ot})),n.d(e,"lb",(function(){return xt})),n.d(e,"nb",(function(){return vt})),n.d(e,"ob",(function(){return wt})),n.d(e,"pb",(function(){return jt})),n.d(e,"qb",(function(){return Et})),n.d(e,"tb",(function(){return $t})),n.d(e,"ub",(function(){return Ct})),n.d(e,"vb",(function(){return Nt})),n.d(e,"wb",(function(){return Rt})),n.d(e,"xb",(function(){return St})),n.d(e,"zb",(function(){return Tt})),n.d(e,"Ab",(function(){return It})),n.d(e,"Bb",(function(){return At})),n.d(e,"yb",(function(){return kt})),n.d(e,"rb",(function(){return Dt})),n.d(e,"sb",(function(){return _t})),n.d(e,"Cb",(function(){return Ft})),n.d(e,"Ib",(function(){return Pt})),n.d(e,"Db",(function(){return Mt})),n.d(e,"Gb",(function(){return Bt})),n.d(e,"Eb",(function(){return Lt})),n.d(e,"Fb",(function(){return Vt})),n.d(e,"Hb",(function(){return zt})),n.d(e,"Jb",(function(){return Ut})),n.d(e,"Kb",(function(){return Wt})),n.d(e,"Lb",(function(){return Gt})),n.d(e,"Mb",(function(){return Ht})),n.d(e,"Nb",(function(){return qt})),n.d(e,"Rb",(function(){return Kt})),n.d(e,"Ob",(function(){return Xt})),n.d(e,"Pb",(function(){return Yt})),n.d(e,"Qb",(function(){return Qt})),n.d(e,"Tb",(function(){return Jt})),n.d(e,"Sb",(function(){return Zt})),n.d(e,"Ub",(function(){return te})),n.d(e,"Vb",(function(){return ee})),n.d(e,"Wb",(function(){return ne})),n.d(e,"Xb",(function(){return re})),n.d(e,"Yb",(function(){return ae})),n.d(e,"Zb",(function(){return se})),n.d(e,"ac",(function(){return oe})),n.d(e,"bc",(function(){return ie})),n.d(e,"dc",(function(){return ce})),n.d(e,"gc",(function(){return ue})),n.d(e,"hc",(function(){return le})),n.d(e,"ec",(function(){return de})),n.d(e,"fc",(function(){return pe})),n.d(e,"cc",(function(){return he})),n.d(e,"ic",(function(){return fe})),n.d(e,"kc",(function(){return me})),n.d(e,"lc",(function(){return be})),n.d(e,"mc",(function(){return ge})),n.d(e,"nc",(function(){return ye})),n.d(e,"oc",(function(){return Oe})),n.d(e,"tc",(function(){return xe})),n.d(e,"rc",(function(){return ve})),n.d(e,"sc",(function(){return we})),n.d(e,"qc",(function(){return je})),n.d(e,"pc",(function(){return Ee})),n.d(e,"vc",(function(){return $e})),n.d(e,"zc",(function(){return Ce})),n.d(e,"Fc",(function(){return Ne})),n.d(e,"wc",(function(){return Re})),n.d(e,"yc",(function(){return Se})),n.d(e,"uc",(function(){return Te})),n.d(e,"Bc",(function(){return Ie})),n.d(e,"Ac",(function(){return Ae})),n.d(e,"Ec",(function(){return ke})),n.d(e,"xc",(function(){return De})),n.d(e,"Dc",(function(){return _e})),n.d(e,"Gc",(function(){return Fe})),n.d(e,"Hc",(function(){return Pe})),n.d(e,"Ic",(function(){return Me})),n.d(e,"Jc",(function(){return Be})),n.d(e,"Kc",(function(){return Le})),n.d(e,"Lc",(function(){return Ve})),n.d(e,"Mc",(function(){return ze})),n.d(e,"Nc",(function(){return Ue})),n.d(e,"Oc",(function(){return We})),n.d(e,"Cc",(function(){return Ge})),n.d(e,"db",(function(){return He})),n.d(e,"jc",(function(){return qe})),n.d(e,"Pc",(function(){return Ke})),n.d(e,"fb",(function(){return Xe})),n.d(e,"gb",(function(){return Ye}));const r="Abs",o="Acos",c="Acosh",l="Add",d="AddN",h="All",f="Any",m="ArgMax",y="ArgMin",O="Asin",x="Asinh",v="Atan",w="Atanh",j="Atan2",E="AvgPool",$="AvgPoolBackprop",C="AvgPool3D",N="AvgPool3DBackprop",R="BatchMatMul",S="BatchToSpaceND",T="BroadcastTo",I="Cast",A="Ceil",k="ClipByValue",D="Complex",_="Concat",F="Conv2D",P="Conv2DBackpropFilter",M="Conv2DBackpropInput",B="Conv3D",L="Conv3DBackpropFilterV2",V="Conv3DBackpropInputV2",z="Cos",U="Cosh",W="Cumsum",G="CropAndResize",H="DepthToSpace",K="DepthwiseConv2dNative",X="DepthwiseConv2dNativeBackpropFilter",Y="DepthwiseConv2dNativeBackpropInput",Q="Dilation2D",J="Dilation2DBackpropInput",Z="Dilation2DBackpropFilter",tt="Div",et="Elu",nt="EluGrad",at="Erf",st="Equal",ot="Exp",it="Expm1",ct="FFT",ut="Fill",lt="FlipLeftRight",pt="Floor",ht="FloorDiv",ft="FusedBatchNorm",mt="GatherV2",bt="GatherNd",gt="Greater",yt="GreaterEqual",Ot="Identity",xt="IFFT",vt="Imag",wt="IsFinite",jt="IsInf",Et="IsNan",$t="Less",Ct="LessEqual",Nt="LinSpace",Rt="Log",St="Log1p",Tt="LogicalAnd",It="LogicalNot",At="LogicalOr",kt="LogSoftmax",Dt="LRN",_t="LRNBackprop",Ft="Max",Pt="Maximum",Mt="MaxPool",Bt="MaxPoolBackprop",Lt="MaxPool3D",Vt="MaxPool3DBackprop",zt="MaxPoolWithArgmax",Ut="Min",Wt="Minimum",Gt="Mod",Ht="Multiply",qt="Negate",Kt="NotEqual",Xt="NonMaxSuppressionV3",Yt="NonMaxSuppressionV4",Qt="NonMaxSuppressionV5",Jt="OnesLike",Zt="OneHot",te="PadV2",ee="Pow",ne="Prelu",re="Prod",ae="Range",se="Real",oe="Reciprocal",ie="Relu",ce="Reshape",ue="ResizeNearestNeighbor",le="ResizeNearestNeighborGrad",de="ResizeBilinear",pe="ResizeBilinearGrad",he="Relu6",fe="Reverse",me="Round",be="Rsqrt",ge="ScatterNd",ye="SelectV2",Oe="Selu",xe="Slice",ve="Sin",we="Sinh",je="Sign",Ee="Sigmoid",$e="Softplus",Ce="Sqrt",Ne="Sum",Re="SpaceToBatchND",Se="SplitV",Te="Softmax",Ie="SquaredDifference",Ae="Square",ke="Sub",De="SparseToDense",_e="StridedSlice",Fe="Tan",Pe="Tanh",Me="Tile",Be="TopK",Le="Transpose",Ve="Unique",ze="Unpack",Ue="UnsortedSegmentSum",We="ZerosLike",Ge="Step",He="FromPixels",qe="RotateWithOffset",Ke="_FusedMatMul",Xe="FusedConv2D",Ye="FusedDepthwiseConv2D"},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(224);function o(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const o=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const c=(...t)=>{r.a.startScope(n);try{const e=o(...t);return e instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r.a.endScope(e),e}catch(t){throw r.a.endScope(null),t}};return Object.defineProperty(c,"name",{value:n,configurable:!0}),c}},function(t,e,n){"use strict";n.d(e,"c",(function(){return d})),n.d(e,"a",(function(){return m})),n.d(e,"b",(function(){return y}));var r=n(224),o=n(244),c=n(223),l=n(225);function d(t,e){let n=t;if(Object(l.isTypedArray)(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||Object(l.isTypedArray)(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&Object(o.b)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&h(t,r,[]),r}function h(t,e,n){if(n=n||[],!Array.isArray(t)&&!Object(l.isTypedArray)(t))return void Object(l.assert)(0===e.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`));Object(l.assert)(e.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`)),Object(l.assert)(t.length===e[0],(()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`));const r=e.slice(1);for(let i=0;i<t.length;++i)h(t[i],r,n.concat(i))}function f(t,e,n,r){if(null!=t&&("numeric"!==t&&t!==e||"numeric"===t&&"string"===e))throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}function m(t,e,n,o="numeric"){if(t instanceof c.a)return f(o,t.dtype,e,n),t;let h=Object(l.inferDtype)(t);if("string"!==h&&["bool","int32","float32"].indexOf(o)>=0&&(h=o),f(o,h,e,n),null==t||!Object(l.isTypedArray)(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){const r=null==t?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const m=d(t,h);Object(l.isTypedArray)(t)||Array.isArray(t)||(t=[t]);const y="string"!==h?Object(l.toTypedArray)(t,h):Object(l.flatten)(t,[],!0);return r.a.makeTensor(y,m,h)}function y(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map(((t,i)=>m(t,`${e}[${i}]`,n)),r)}},function(t,e,n){"use strict";n.d(e,"b",(function(){return f})),n.d(e,"f",(function(){return x})),n.d(e,"e",(function(){return v})),n.d(e,"d",(function(){return w})),n.d(e,"a",(function(){return j})),n.d(e,"c",(function(){return E}));var r=n(225);function o(t,e,n,o){const l=Object(r.computeStrides)(e),f=function(t,e,n,o){const l=Object(r.sizeFromShape)(e),d=o[o.length-1],f=new Array(d).fill(0),m=e.length,y="complex64"===n?h(t):t;if(m>1)for(let t=0;t<l/d;t++){const e=t*d;for(let t=0;t<d;t++)f[t]=Math.max(f[t],c(y[e+t],0,n).length)}return f}(t,e,n,l),m=e.length,y=d(t,e,n,l,f),O=["Tensor"];return o&&(O.push(`  dtype: ${n}`),O.push(`  rank: ${m}`),O.push(`  shape: [${e}]`),O.push("  values:")),O.push(y.map((t=>"    "+t)).join("\n")),O.join("\n")}function c(t,e,n){let o;return o=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:Object(r.isString)(t)?`'${t}'`:"bool"===n?l(t):parseFloat(t.toFixed(7)).toString(),Object(r.rightPad)(o,e)}function l(t){return 0===t?"false":"true"}function d(t,e,n,r,o,f=!0){const m="complex64"===n?2:1,y=e[0],O=e.length;if(0===O){if("complex64"===n){return[c(h(t)[0],0,n)]}return"bool"===n?[l(t[0])]:[t[0].toString()]}if(1===O){if(y>20){const e=3*m;let r=Array.from(t.slice(0,e)),l=Array.from(t.slice((y-3)*m,y*m));return"complex64"===n&&(r=h(r),l=h(l)),["["+r.map(((t,i)=>c(t,o[i],n))).join(", ")+", ..., "+l.map(((t,i)=>c(t,o[y-3+i],n))).join(", ")+"]"]}return["["+("complex64"===n?h(t):Array.from(t)).map(((t,i)=>c(t,o[i],n))).join(", ")+"]"]}const x=e.slice(1),v=r.slice(1),w=r[0]*m,j=[];if(y>20){for(let i=0;i<3;i++){const e=i*w,r=e+w;j.push(...d(t.slice(e,r),x,n,v,o,!1))}j.push("...");for(let i=y-3;i<y;i++){const e=i*w,r=e+w;j.push(...d(t.slice(e,r),x,n,v,o,i===y-1))}}else for(let i=0;i<y;i++){const e=i*w,r=e+w;j.push(...d(t.slice(e,r),x,n,v,o,i===y-1))}const E=2===O?",":"";j[0]="["+j[0]+E;for(let i=1;i<j.length-1;i++)j[i]=" "+j[i]+E;let $=",\n";for(let i=2;i<O;i++)$+="\n";return j[j.length-1]=" "+j[j.length-1]+"]"+(f?"":$),j}function h(t){const e=[];for(let i=0;i<t.length;i+=2)e.push([t[i],t[i+1]]);return e}class f{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=r.sizeFromShape(t),null!=n){const t=n.length;r.assert(t===this.size,(()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||r.getArrayFromDType(e,this.size),this.strides=Object(r.computeStrides)(t)}set(t,...e){0===e.length&&(e=[0]),r.assert(e.length===this.rank,(()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`));const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let i=0;for(const e of t){if(e<0||e>=this.shape[i]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}i++}let e=t[t.length-1];for(let i=0;i<t.length-1;++i)e+=this.strides[i]*t[i];return this.values[e]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let i=0;i<t.length-1;++i)e+=this.strides[i]*t[i];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let i=0;i<e.length-1;++i)e[i]=Math.floor(t/this.strides[i]),t-=e[i]*this.strides[i];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return m().makeTensor(this.values,this.shape,this.dtype)}}let m=null,y=null,O=null;function x(t){m=t}function v(t){y=t}function w(t){O=t}class j{constructor(t,e,n,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=r.sizeFromShape(t),this.strides=Object(r.computeStrides)(t),this.dataId=n,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return y.buffer(this.shape,this.dtype,t)}bufferSync(){return y.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return Object(r.toNestedArray)(this.shape,t)}arraySync(){return Object(r.toNestedArray)(this.shape,this.dataSync())}async data(){this.throwIfDisposed();const data=m().read(this.dataId);if("string"===this.dtype){const t=await data;try{return t.map((b=>r.decodeString(b)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return data}dataSync(){this.throwIfDisposed();const data=m().readSync(this.dataId);if("string"===this.dtype)try{return data.map((b=>r.decodeString(b)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return data}async bytes(){this.throwIfDisposed();const data=await m().read(this.dataId);return"string"===this.dtype?data:new Uint8Array(data.buffer)}dispose(){this.isDisposed||(m().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return y.print(this,t)}clone(){return this.throwIfDisposed(),y.clone(this)}toString(t=!1){return o(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),y.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),m().makeVariable(this,t,e,n)}}Object.defineProperty(j,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed});class E extends j{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!r.arraysEqual(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);m().disposeTensor(this),this.dataId=t.dataId,m().incRef(this,null)}dispose(){m().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(E,Symbol.hasInstance,{value:t=>t instanceof j&&null!=t.assign&&t.assign instanceof Function})},function(t,e,n){"use strict";n.d(e,"b",(function(){return j})),n.d(e,"a",(function(){return E}));var r=n(331),o=n(244),c=n(413),l=n(220),d=n(310),h=n(225);class f{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new y)}profileKernel(t,e,n){let r;const o=this.backendTimer.time((()=>{r=n()}));for(let i=0;i<r.length;i++){const output=r[i];output.data().then((e=>{m(e,output.dtype,t)}))}return{kernelName:t,outputs:r,inputs:e,timeMs:o.then((t=>t.kernelMs)),extraInfo:o.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:o,extraInfo:c}=t;n.forEach((t=>{Promise.all([t.data(),r,c]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],o,n[2])}))}))}}function m(t,e,n){if("float32"!==e)return!1;for(let i=0;i<t.length;i++){const e=t[i];if(isNaN(e)||!isFinite(e))return console.warn(`Found ${e} in the result of '${n}'`),!0}return!1}class y{logKernelProfile(t,e,n,r,o,c){const time="number"==typeof r?h.rightPad(`${r}ms`,9):r.error,l=h.rightPad(t,25),d=e.rank,f=e.size,m=h.rightPad(e.shape.toString(),14);let y="";for(const t in o){const input=o[t];if(null!=input){const n=input.shape||e.shape,r=n.length;y+=`${t}: ${r}D ${r>0?n:""} `}}console.log(`%c${l}\t%c${time}\t%c${d}D ${m}\t%c${f}\t%c${y}\t%c${c}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var O=n(223),x=n(234);class v{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class w{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new v}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let i=0;i<t.length;i++){const e=t[i];if(await this.initializeBackend(e).success)return void await this.setBackend(e)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(console.warn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new f(this.backendInstance),!0}setupRegisteredKernels(){Object(d.c)(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){Object(d.c)(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(!n||n instanceof r.b||"function"!=typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then((n=>!(e<this.pendingBackendInitId)&&(this.registry[t]=n,this.pendingBackendInit=null,!0))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(e){return console.warn(`Initialization of backend ${t} failed`),console.warn(e.stack||e.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((a,b)=>this.registryFactory[b].priority-this.registryFactory[a].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let i=0;i<t.length;i++){const e=t[i],{success:n,asyncInit:r}=this.initializeBackend(e);if(r||n)return{name:e,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,o=this.readSync(e);r.disposeData(e),n.backend=t,t.move(e,o,n.shape,n.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(t){throw e(),t}}nextTensorId(){return w.nextTensorId++}nextVariableId(){return w.nextVariableId++}clone(t){const e=this.makeTensorFromDataId(t.dataId,t.shape,t.dtype),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e="float32",n={x:t},r={dtype:e};return E.runKernelFunc((n=>n.cast(t,e)),n,null,l.v,r)}})),[],{}),e}runKernel(t,e,n,r,o){return this.runKernelFunc(null,e,null,t,n,r,o)}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let o=0;n.forEach((t=>{o+="complex64"===t.dtype?3:1}));const c=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],l=r-e-o-c;if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${t}'`)}runKernelFunc(t,e,n,r,o,c,l){let h,f=[];const m=this.isTapeOn();null==r&&(r=null!=this.state.activeScope?this.state.activeScope.name:"");const y=this.state.numBytes,O=this.state.numTensors;let x;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const v=Object(d.b)(r,this.backendName);let w,j;if(null!=v)x=()=>{const t=this.backend.numDataIds();w=v.kernelFunc({inputs:e,attrs:o,backend:this.backend});const n=Array.isArray(w)?w:[w];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,t,n);const d=n.map((({dataId:t,shape:e,dtype:n})=>this.makeTensorFromDataId(t,e,n)));if(m){let t=this.getTensorsForGradient(r,e,d);if(null==t){null==l&&(l=[]);const e=d.filter(((t,i)=>l[i]));t=(c||[]).slice().concat(e)}f=this.saveTensorsForBackwardMode(t)}return d};else{const e=t=>{m&&(f=t.map((t=>this.keep(this.clone(t)))))};x=()=>{const n=this.backend.numDataIds();w=this.tidy((()=>t(this.backend,e)));const o=Array.isArray(w)?w:[w];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,n,o),o}}return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(j=this.profiler.profileKernel(r,e,(()=>x())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(j),h=j.outputs):h=x()})),m&&this.addTapeNode(r,e,h,n,f,o),this.state.profiling&&this.state.activeProfile.kernels.push({name:r,bytesAdded:this.state.numBytes-y,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-O,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(e).map((t=>null!=e[t]?e[t].shape:null)),outputShapes:h.map((t=>t.shape)),kernelTimeMs:j.timeMs,extraInfo:j.extraInfo}),Array.isArray(w)?h:h[0]}saveTensorsForBackwardMode(t){const e=t.map((t=>this.keep(this.clone(t))));return e}getTensorsForGradient(t,e,n){const r=Object(d.a)(t);if(null!=r){const t=r.inputsToSave||[],o=r.outputsToSave||[];let c;r.saveAllInputs?(h.assert(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),c=Object.keys(e).map((t=>e[t]))):c=t.map((t=>e[t]));const l=n.filter(((t,i)=>o[i]));return c.concat(l)}return null}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let o=t;"string"===n&&h.isString(t[0])&&(o=t.map((t=>h.encodeString(t))));const c=r.write(o,e,n),l=new O.a(e,n,c,this.nextTensorId());if(this.incRef(l,r),"string"===n){const t=this.state.tensorInfo.get(c),e=Object(h.bytesFromStringArray)(o);this.state.numBytes+=e-t.bytes,t.bytes=e}return l}makeTensorFromDataId(t,e,n,r){n=n||"float32";const o=new O.a(e,n,t,this.nextTensorId());return this.incRef(o,r),o}makeVariable(t,e=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const o=new O.c(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}incRef(a,t){const e=this.state.tensorInfo.has(a.dataId)?this.state.tensorInfo.get(a.dataId).refCount:0;if(this.state.numTensors++,"string"===a.dtype&&this.state.numStringTensors++,0===e){this.state.numDataBuffers++;let e=0;"complex64"!==a.dtype&&"string"!==a.dtype&&(e=a.size*h.bytesPerElement(a.dtype)),this.state.tensorInfo.set(a.dataId,{backend:t||this.backend,dtype:a.dtype,shape:a.shape,bytes:e,refCount:0}),this.state.numBytes+=e}this.state.tensorInfo.get(a.dataId).refCount++,a instanceof O.c||this.track(a)}disposeTensor(a){if(!this.state.tensorInfo.has(a.dataId))return;this.state.numTensors--,"string"===a.dtype&&this.state.numStringTensors--;const t=this.state.tensorInfo.get(a.dataId);t.refCount<=1?("complex64"!==a.dtype&&(this.state.numBytes-=t.bytes),this.state.numDataBuffers--,t.backend.disposeData(a.dataId),this.state.tensorInfo.delete(a.dataId)):this.state.tensorInfo.get(a.dataId).refCount--}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const t of this.state.activeProfile.kernels)t.kernelTimeMs=await t.kernelTimeMs,t.extraInfo=await t.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,o,c){const l={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:o},f=Object(d.a)(t);null!=f&&(r=f.gradFunc),null!=r&&(l.gradient=t=>(t=t.map(((t,i)=>{if(null==t){const output=n[i],t=h.makeZerosTypedArray(output.size,output.dtype);return this.makeTensor(t,output.shape,output.dtype)}return t})),r(t.length>1?t:t[0],o,c))),this.state.activeTape.push(l)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=Object(x.a)(t),n=new Set(e.map((t=>t.id)));for(let i=0;i<this.state.activeScope.track.length;i++){const t=this.state.activeScope.track[i];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,e,n,r=!1){if(h.assert(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const o=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));h.assert(o instanceof O.a,(()=>"The result y returned by f() must be a tensor."));const c=function(t,e,n){const r={},o={};for(let i=0;i<e.length;i++)r[e[i].id]=!0;for(let i=0;i<t.length;i++){const n=t[i],c=n.inputs;for(const t in c){const input=c[t];let l=!1;for(let t=0;t<e.length;t++)if(r[input.id]){n.outputs.forEach((output=>r[output.id]=!0)),l=!0,o[n.id]=!0;break}if(l)break}}const c={};c[n.id]=!0;const l={};for(let i=t.length-1;i>=0;i--){const e=t[i],n=e.inputs;for(let t=0;t<e.outputs.length;t++)if(c[e.outputs[t].id]){for(const t in n)c[n[t].id]=!0,l[e.id]=!0;break}}const d=[];for(let i=0;i<t.length;i++){const e=t[i];if(o[e.id]&&l[e.id]){const t={};for(const n in e.inputs){const o=e.inputs[n];r[o.id]&&(t[n]=o)}const n=Object.assign({},e);n.inputs=t,n.outputs=e.outputs,d.push(n)}}return d}(this.state.activeTape,e,o);if(!r&&0===c.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[o.id]=null==n?function(t){const e=Object(h.makeOnesTypedArray)(Object(h.sizeFromShape)(t),"float32");return E.makeTensor(e,t,"float32")}(o.shape):n,function(t,e,n,r){for(let i=e.length-1;i>=0;i--){const o=e[i],c=[];if(o.outputs.forEach((e=>{const n=t[e.id];null!=n?c.push(n):c.push(null)})),null==o.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const l=o.gradient(c);for(const e in o.inputs){if(!(e in l))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(l)}.`);const c=n((()=>l[e]()));if("float32"!==c.dtype)throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${c.dtype}'`);const d=o.inputs[e];if(!h.arraysEqual(c.shape,d.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${e}' has shape '${c.shape}', which does not match the shape of the input '${d.shape}'`);if(null==t[d.id])t[d.id]=c;else{const e=t[d.id];t[d.id]=r(e,c),e.dispose()}}}}(t,c,(t=>this.tidy(t)),$);const r=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:o,grads:r}}))}customGrad(t){return h.assert(h.isFunction(t),(()=>"The f passed in customGrad(f) must be a function.")),(...e)=>{let n;h.assert(e.every((t=>t instanceof O.a)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};return e.forEach(((input,i)=>{r[i]=input})),this.runKernelFunc(((r,o)=>(n=t(...e,o),h.assert(n.value instanceof O.a,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),h.assert(h.isFunction(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value)),r,((t,r)=>{const o=n.gradFunc(t,r),c=Array.isArray(o)?o:[o];h.assert(c.length===e.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),h.assert(c.every((t=>t instanceof O.a)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const l={};return c.forEach(((t,i)=>{l[i]=()=>t})),l}))}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}async time(t){const e=Object(h.now)(),n=await this.backend.time(t);return n.wallMs=Object(h.now)()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new v;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function j(){const t=Object(c.b)();if(null==t._tfengine){const e=new o.a(t);t._tfengine=new w(e)}return Object(o.c)(t._tfengine.ENV),Object(O.f)((()=>t._tfengine)),t._tfengine}w.nextTensorId=0,w.nextVariableId=0;const E=j();function $(a,b){const t={a:a,b:b};return E.runKernelFunc(((t,e)=>{const n=t.add(a,b);return e([a,b]),n}),t,null,l.d)}},function(t,e,n){"use strict";n.r(e),n.d(e,"shuffle",(function(){return o})),n.d(e,"clamp",(function(){return c})),n.d(e,"nearestLargerEven",(function(){return l})),n.d(e,"sum",(function(){return d})),n.d(e,"randUniform",(function(){return h})),n.d(e,"distSquared",(function(){return f})),n.d(e,"assert",(function(){return m})),n.d(e,"assertShapesMatch",(function(){return y})),n.d(e,"assertNonNull",(function(){return O})),n.d(e,"flatten",(function(){return x})),n.d(e,"sizeFromShape",(function(){return v})),n.d(e,"isScalarShape",(function(){return w})),n.d(e,"arraysEqual",(function(){return j})),n.d(e,"isInt",(function(){return E})),n.d(e,"tanh",(function(){return $})),n.d(e,"sizeToSquarishShape",(function(){return C})),n.d(e,"createShuffledIndices",(function(){return N})),n.d(e,"rightPad",(function(){return R})),n.d(e,"repeatedTry",(function(){return S})),n.d(e,"inferFromImplicitShape",(function(){return T})),n.d(e,"parseAxisParam",(function(){return I})),n.d(e,"squeezeShape",(function(){return A})),n.d(e,"getTypedArrayFromDType",(function(){return k})),n.d(e,"getArrayFromDType",(function(){return D})),n.d(e,"checkConversionForErrors",(function(){return _})),n.d(e,"isValidDtype",(function(){return F})),n.d(e,"hasEncodingLoss",(function(){return P})),n.d(e,"isTypedArray",(function(){return M})),n.d(e,"bytesPerElement",(function(){return B})),n.d(e,"bytesFromStringArray",(function(){return L})),n.d(e,"isString",(function(){return V})),n.d(e,"isBoolean",(function(){return z})),n.d(e,"isNumber",(function(){return U})),n.d(e,"inferDtype",(function(){return W})),n.d(e,"isFunction",(function(){return G})),n.d(e,"nearestDivisor",(function(){return H})),n.d(e,"computeStrides",(function(){return K})),n.d(e,"createScalarValue",(function(){return X})),n.d(e,"toTypedArray",(function(){return Y})),n.d(e,"toNestedArray",(function(){return J})),n.d(e,"makeOnesTypedArray",(function(){return Z})),n.d(e,"makeZerosTypedArray",(function(){return tt})),n.d(e,"makeZerosNestedTypedArray",(function(){return et})),n.d(e,"now",(function(){return nt})),n.d(e,"assertNonNegativeIntegerDimensions",(function(){return at})),n.d(e,"fetch",(function(){return st})),n.d(e,"encodeString",(function(){return ot})),n.d(e,"decodeString",(function(){return it})),n.d(e,"locToIndex",(function(){return ct})),n.d(e,"indexToLoc",(function(){return ut}));var r=n(244);function o(t){let e=t.length,n=0,r=0;for(;e>0;)r=Math.random()*e|0,e--,n=t[e],t[e]=t[r],t[r]=n}function c(t,e,n){return Math.max(t,Math.min(e,n))}function l(t){return t%2==0?t:t+1}function d(t){let e=0;for(let i=0;i<t.length;i++)e+=t[i];return e}function h(a,b){const t=Math.random();return b*t+(1-t)*a}function f(a,b){let t=0;for(let i=0;i<a.length;i++){const e=Number(a[i])-Number(b[i]);t+=e*e}return t}function m(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function y(t,e,n=""){m(j(t,e),(()=>n+` Shapes ${t} and ${e} must match`))}function O(a){m(null!=a,(()=>"The input to the tensor constructor must be a non-null value."))}function x(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||M(t)&&!n)for(let i=0;i<t.length;++i)x(t[i],e,n);else e.push(t);return e}function v(t){if(0===t.length)return 1;let e=t[0];for(let i=1;i<t.length;i++)e*=t[i];return e}function w(t){return 0===t.length}function j(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(t[i]!==e[i])return!1;return!0}function E(a){return a%1==0}function $(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function C(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function N(t){const e=new Uint32Array(t);for(let i=0;i<t;++i)e[i]=i;return o(e),e}function R(a,t){return t<=a.length?a:a+" ".repeat(t-a.length)}function S(t,e=(t=>0),n){return new Promise(((r,o)=>{let c=0;const l=()=>{if(t())return void r();c++;const d=e(c);null!=n&&c>=n?o():setTimeout(l,d)};l()}))}function T(t,e){let n=1,r=-1;for(let i=0;i<t.length;++i)if(t[i]>=0)n*=t[i];else if(-1===t[i]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(t[i]<0)throw Error(`Shapes can not be < 0. Found ${t[i]} at dim ${i}`);if(-1===r){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const o=t.slice();return o[r]=e/n,o}function I(t,e){const n=e.length;return m((t=null==t?e.map(((s,i)=>i)):[].concat(t)).every((t=>t>=-n&&t<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`)),m(t.every((t=>E(t))),(()=>`All values in axis param must be integers but got axis ${t}`)),t.map((a=>a<0?n+a:a))}function A(t,e){const n=[],r=[],o=null!=e&&Array.isArray(e)&&0===e.length,c=null==e||o?null:I(e,t).sort();let l=0;for(let i=0;i<t.length;++i){if(null!=c){if(c[l]===i&&1!==t[i])throw new Error(`Can't squeeze axis ${i} since its dim '${t[i]}' is not 1`);(null==c[l]||c[l]>i)&&1===t[i]&&(n.push(t[i]),r.push(i)),c[l]<=i&&l++}1!==t[i]&&(n.push(t[i]),r.push(i))}return{newShape:n,keptDims:r}}function k(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);n=new Uint8Array(e)}return n}function D(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);n=new Array(e)}return n}function _(t,e){for(let i=0;i<t.length;i++){const n=t[i];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${e} being uploaded contains ${n}.`)}}function F(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}function P(t,e){return"complex64"!==e&&(("float32"!==e||"complex64"===t)&&(("int32"!==e||"float32"===t||"complex64"===t)&&("bool"!==e||"bool"!==t)))}function M(a){return a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array}function B(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function L(t){if(null==t)return 0;let e=0;return t.forEach((t=>e+=t.length)),e}function V(t){return"string"==typeof t||t instanceof String}function z(t){return"boolean"==typeof t}function U(t){return"number"==typeof t}function W(t){return Array.isArray(t)?W(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":U(t)?"float32":V(t)?"string":z(t)?"bool":"float32"}function G(t){return!!(t&&t.constructor&&t.call&&t.apply)}function H(t,e){for(let i=e;i<t;++i)if(t%i==0)return i;return t}function K(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let i=e-3;i>=0;--i)n[i]=n[i+1]*t[i+1];return n}function X(t,e){return"string"===e?ot(t):Y([t],e)}function Y(a,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(a)&&(a=x(a)),Object(r.b)().getBool("DEBUG")&&_(a,t),function(a,t){return a instanceof Float32Array&&"float32"===t||a instanceof Int32Array&&"int32"===t||a instanceof Uint8Array&&"bool"===t}(a,t))return a;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(a);if("int32"===t)return new Int32Array(a);if("bool"===t){const t=new Uint8Array(a.length);for(let i=0;i<t.length;++i)0!==Math.round(a[i])&&(t[i]=1);return t}throw new Error(`Unknown data type ${t}`)}function Q(t,e,a){const n=new Array;if(1===e.length){const r=e[0];for(let i=0;i<r;i++)n[i]=a[t+i]}else{const r=e[0],o=e.slice(1),c=o.reduce(((t,e)=>t*e));for(let i=0;i<r;i++)n[i]=Q(t+i*c,o,a)}return n}function J(t,a){if(0===t.length)return a[0];const e=t.reduce(((t,e)=>t*e));if(0===e)return[];if(e!==a.length)throw new Error(`[${t}] does not match the input size ${a.length}.`);return Q(0,t,a)}function Z(t,e){const n=tt(t,e);for(let i=0;i<n.length;i++)n[i]=1;return n}function tt(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function et(t,e){const n=t.reduce(((t,e)=>t*e),1);if(null==e||"float32"===e)return J(t,new Float32Array(n));if("int32"===e)return J(t,new Int32Array(n));if("bool"===e)return J(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function nt(){return Object(r.b)().platform.now()}function at(t){t.forEach((e=>{m(Number.isInteger(e)&&e>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`))}))}function st(path,t){return Object(r.b)().platform.fetch(path,t)}function ot(s,t="utf-8"){return t=t||"utf-8",Object(r.b)().platform.encode(s,t)}function it(t,e="utf-8"){return e=e||"utf-8",Object(r.b)().platform.decode(t,e)}function ct(t,e,n){if(0===e)return 0;if(1===e)return t[0];let r=t[t.length-1];for(let i=0;i<t.length-1;++i)r+=n[i]*t[i];return r}function ut(t,e,n){if(0===e)return[];if(1===e)return[t];const r=new Array(e);for(let i=0;i<r.length-1;++i)r[i]=Math.floor(t/n[i]),t-=r[i]*n[i];return r[r.length-1]=t,r}},function(t,e,n){"use strict";n.d(e,"M",(function(){return at.a})),n.d(e,"N",(function(){return at.b})),n.d(e,"wb",(function(){return Dt.a})),n.d(e,"Db",(function(){return Dt.b})),n.d(e,"Q",(function(){return _t.a})),n.d(e,"T",(function(){return _t.b})),n.d(e,"U",(function(){return _t.c})),n.d(e,"V",(function(){return _t.d})),n.d(e,"W",(function(){return _t.e})),n.d(e,"X",(function(){return _t.f})),n.d(e,"Z",(function(){return _t.g})),n.d(e,"db",(function(){return _t.i})),n.d(e,"ib",(function(){return _t.k})),n.d(e,"jb",(function(){return _t.l})),n.d(e,"kb",(function(){return _t.m})),n.d(e,"lb",(function(){return _t.n})),n.d(e,"ob",(function(){return _t.o})),n.d(e,"pb",(function(){return _t.p})),n.d(e,"qb",(function(){return _t.q})),n.d(e,"rb",(function(){return _t.r})),n.d(e,"tb",(function(){return _t.s})),n.d(e,"ub",(function(){return _t.t})),n.d(e,"vb",(function(){return _t.u})),n.d(e,"xb",(function(){return _t.v})),n.d(e,"yb",(function(){return _t.w})),n.d(e,"zb",(function(){return _t.x})),n.d(e,"Cb",(function(){return _t.z})),n.d(e,"Fb",(function(){return _t.A})),n.d(e,"Bb",(function(){return _t.y})),n.d(e,"eb",(function(){return _t.j})),n.d(e,"ab",(function(){return Ft.c})),n.d(e,"Ab",(function(){return Ft.g})),n.d(e,"gb",(function(){return Ft.e})),n.d(e,"cb",(function(){return Ft.d})),n.d(e,"mb",(function(){return Ft.f})),n.d(e,"nb",(function(){return Ct.e})),n.d(e,"bb",(function(){return h.b})),n.d(e,"S",(function(){return o})),n.d(e,"fb",(function(){return r})),n.d(e,"Eb",(function(){return T})),n.d(e,"R",(function(){return c})),n.d(e,"sb",(function(){return kt})),n.d(e,"Y",(function(){return je})),n.d(e,"hb",(function(){return l})),n.d(e,"s",(function(){return Ie.b})),n.d(e,"j",(function(){return Ie.a})),n.d(e,"a",(function(){return $t.a})),n.d(e,"b",(function(){return $t.d})),n.d(e,"c",(function(){return $t.m})),n.d(e,"d",(function(){return $t.o})),n.d(e,"e",(function(){return $t.r})),n.d(e,"f",(function(){return $t.v})),n.d(e,"g",(function(){return $t.w})),n.d(e,"h",(function(){return $t.y})),n.d(e,"i",(function(){return $t.G})),n.d(e,"k",(function(){return $t.R})),n.d(e,"l",(function(){return $t.W})),n.d(e,"m",(function(){return $t.X})),n.d(e,"n",(function(){return $t.ab})),n.d(e,"o",(function(){return $t.bb})),n.d(e,"q",(function(){return $t.eb})),n.d(e,"r",(function(){return $t.mb})),n.d(e,"t",(function(){return $t.wb})),n.d(e,"u",(function(){return $t.Cb})),n.d(e,"v",(function(){return $t.Db})),n.d(e,"w",(function(){return $t.Gb})),n.d(e,"x",(function(){return $t.Hb})),n.d(e,"y",(function(){return $t.Mb})),n.d(e,"z",(function(){return $t.Ob})),n.d(e,"A",(function(){return $t.Pb})),n.d(e,"B",(function(){return $t.Qb})),n.d(e,"C",(function(){return $t.Zb})),n.d(e,"D",(function(){return $t.dc})),n.d(e,"F",(function(){return $t.lc})),n.d(e,"H",(function(){return $t.tc})),n.d(e,"G",(function(){return $t.rc})),n.d(e,"J",(function(){return $t.Bc})),n.d(e,"I",(function(){return $t.Ac})),n.d(e,"K",(function(){return $t.Ec})),n.d(e,"L",(function(){return $t.Gc})),n.d(e,"O",(function(){return $t.Kc})),n.d(e,"P",(function(){return $t.Lc})),n.d(e,"p",(function(){return $t.db})),n.d(e,"E",(function(){return $t.jc}));var r={};n.r(r),n.d(r,"copyModel",(function(){return Y})),n.d(r,"listModels",(function(){return K})),n.d(r,"moveModel",(function(){return Q})),n.d(r,"removeModel",(function(){return X})),n.d(r,"browserFiles",(function(){return ut})),n.d(r,"browserHTTPRequest",(function(){return xt})),n.d(r,"concatenateArrayBuffers",(function(){return f.d})),n.d(r,"decodeWeights",(function(){return f.e})),n.d(r,"encodeWeights",(function(){return f.f})),n.d(r,"fromMemory",(function(){return jt})),n.d(r,"getLoadHandlers",(function(){return v})),n.d(r,"getModelArtifactsInfoForJSON",(function(){return f.g})),n.d(r,"getSaveHandlers",(function(){return x})),n.d(r,"http",(function(){return Ot})),n.d(r,"isHTTPScheme",(function(){return gt})),n.d(r,"loadWeights",(function(){return ft})),n.d(r,"registerLoadRouter",(function(){return O})),n.d(r,"registerSaveRouter",(function(){return y})),n.d(r,"weightsLoaderFactory",(function(){return mt})),n.d(r,"withSaveHandler",(function(){return Et}));var o={};n.r(o),n.d(o,"toPixels",(function(){return It})),n.d(o,"fromPixels",(function(){return At}));var c={};n.r(c),n.d(c,"axesAreInnerMostDims",(function(){return Lt.b})),n.d(c,"combineLocations",(function(){return Lt.c})),n.d(c,"computeOutAndReduceShapes",(function(){return Lt.d})),n.d(c,"expandShapeToKeepDim",(function(){return Lt.e})),n.d(c,"assertAxesAreInnerMostDims",(function(){return Lt.a})),n.d(c,"getAxesPermutation",(function(){return Lt.f})),n.d(c,"getUndoAxesPermutation",(function(){return Lt.h})),n.d(c,"getInnerMostAxes",(function(){return Lt.g})),n.d(c,"getBroadcastDims",(function(){return Vt.b})),n.d(c,"getReductionAxes",(function(){return Vt.c})),n.d(c,"assertAndGetBroadcastShape",(function(){return Vt.a})),n.d(c,"assertParamsConsistent",(function(){return zt.a})),n.d(c,"computeOutShape",(function(){return zt.b})),n.d(c,"computeDilation2DInfo",(function(){return Ut.d})),n.d(c,"computePool2DInfo",(function(){return Ut.e})),n.d(c,"computePool3DInfo",(function(){return Ut.f})),n.d(c,"computeConv2DInfo",(function(){return Ut.a})),n.d(c,"computeConv3DInfo",(function(){return Ut.b})),n.d(c,"computeDefaultPad",(function(){return Ut.c})),n.d(c,"tupleValuesAreOne",(function(){return Ut.i})),n.d(c,"eitherStridesOrDilationsAreOne",(function(){return Ut.h})),n.d(c,"convertConv2DDataFormat",(function(){return Ut.g})),n.d(c,"getFusedDyActivation",(function(){return Wt.c})),n.d(c,"getFusedBiasGradient",(function(){return Wt.b})),n.d(c,"applyActivation",(function(){return Wt.a})),n.d(c,"shouldFuse",(function(){return Wt.d})),n.d(c,"PARALLELIZE_THRESHOLD",(function(){return Gt.a})),n.d(c,"computeOptimalWindowSize",(function(){return Gt.b})),n.d(c,"slice_util",(function(){return kt})),n.d(c,"upcastType",(function(){return Dt.b})),n.d(c,"getImageCenter",(function(){return Ht})),n.d(c,"getReshaped",(function(){return qt})),n.d(c,"getPermuted",(function(){return Kt})),n.d(c,"getReshapedPermuted",(function(){return Xt})),n.d(c,"getSliceBeginCoords",(function(){return Yt})),n.d(c,"getSliceSize",(function(){return Qt})),n.d(c,"prepareAndValidate",(function(){return Jt})),n.d(c,"validateUpdateShape",(function(){return Zt.c})),n.d(c,"validateInput",(function(){return Zt.b})),n.d(c,"calculateShapes",(function(){return Zt.a})),n.d(c,"SELU_SCALEALPHA",(function(){return te})),n.d(c,"SELU_SCALE",(function(){return ee})),n.d(c,"ERF_P",(function(){return ne})),n.d(c,"ERF_A1",(function(){return re})),n.d(c,"ERF_A2",(function(){return ae})),n.d(c,"ERF_A3",(function(){return se})),n.d(c,"ERF_A4",(function(){return oe})),n.d(c,"ERF_A5",(function(){return ie})),n.d(c,"warn",(function(){return ce})),n.d(c,"log",(function(){return ue})),n.d(c,"mergeRealAndImagArrays",(function(){return le})),n.d(c,"splitRealAndImagArrays",(function(){return de})),n.d(c,"complexWithEvenIndex",(function(){return pe})),n.d(c,"complexWithOddIndex",(function(){return he})),n.d(c,"getComplexWithIndex",(function(){return fe})),n.d(c,"assignToTypedArray",(function(){return me})),n.d(c,"exponents",(function(){return be})),n.d(c,"exponent",(function(){return ge})),n.d(c,"prepareSplitSize",(function(){return ye.a})),n.d(c,"segment_util",(function(){return Oe})),n.d(c,"castTensor",(function(){return xe})),n.d(c,"reshapeTensor",(function(){return ve})),n.d(c,"linspaceImpl",(function(){return we}));var l={};n.r(l),n.d(l,"nonMaxSuppressionV3Impl",(function(){return Ee.a})),n.d(l,"nonMaxSuppressionV4Impl",(function(){return Ee.b})),n.d(l,"nonMaxSuppressionV5Impl",(function(){return Ee.c})),n.d(l,"split",(function(){return Ce})),n.d(l,"tile",(function(){return Ne})),n.d(l,"topkImpl",(function(){return Se})),n.d(l,"whereImpl",(function(){return Te.a}));var d=n(224),h=(n(311),n(244)),f=n(262);class m{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==m.instance&&(m.instance=new m),m.instance}static registerSaveRouter(t){m.getInstance().saveRouters.push(t)}static registerLoadRouter(t){m.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return m.getHandlers(t,"save")}static getLoadHandlers(t,e){return m.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?m.getInstance().loadRouters:m.getInstance().saveRouters).forEach((e=>{const o=e(t,n);null!==o&&r.push(o)})),r}}const y=t=>m.registerSaveRouter(t),O=t=>m.registerLoadRouter(t),x=t=>m.getSaveHandlers(t),v=(t,e)=>m.getLoadHandlers(t,e),w="tensorflowjs",j="models_store",E="model_info_store";function $(){if(!Object(h.b)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function C(t){const e=t.result;e.createObjectStore(j,{keyPath:"modelPath"}),e.createObjectStore(E,{keyPath:"modelPath"})}class N{constructor(t){if(this.indexedDB=$(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise(((t,n)=>{const r=this.indexedDB.open(w,1);r.onupgradeneeded=()=>C(r),r.onsuccess=()=>{const o=r.result;if(null==e){const e=o.transaction(j,"readonly"),r=e.objectStore(j).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return o.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(r.result.modelArtifacts)},r.onerror=t=>(o.close(),n(r.error)),e.oncomplete=()=>o.close()}else{const r=Object(f.g)(e),c=o.transaction(E,"readwrite");let l=c.objectStore(E);const d=l.put({modelPath:this.modelPath,modelArtifactsInfo:r});let h;d.onsuccess=()=>{h=o.transaction(j,"readwrite");const d=h.objectStore(j).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r});d.onsuccess=()=>t({modelArtifactsInfo:r}),d.onerror=t=>{l=c.objectStore(E);const e=l.delete(this.modelPath);e.onsuccess=()=>(o.close(),n(d.error)),e.onerror=t=>(o.close(),n(d.error))}},d.onerror=t=>(o.close(),n(d.error)),c.oncomplete=()=>{null==h?o.close():h.oncomplete=()=>o.close()}}},r.onerror=t=>n(r.error)}))}}N.URL_SCHEME="indexeddb://";const R=t=>{return Object(h.b)().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(N.URL_SCHEME)?(e=t.slice(N.URL_SCHEME.length),new N(e)):null;var e};m.registerSaveRouter(R),m.registerLoadRouter(R);class S{constructor(){this.indexedDB=$()}async listModels(){return new Promise(((t,e)=>{const n=this.indexedDB.open(w,1);n.onupgradeneeded=()=>C(n),n.onsuccess=()=>{const r=n.result,o=r.transaction(E,"readonly"),c=o.objectStore(E).getAll();c.onsuccess=()=>{const e={};for(const t of c.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},c.onerror=t=>(r.close(),e(c.error)),o.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)}))}async removeModel(path){var t;return path=(t=path).startsWith(N.URL_SCHEME)?t.slice(N.URL_SCHEME.length):t,new Promise(((t,e)=>{const n=this.indexedDB.open(w,1);n.onupgradeneeded=()=>C(n),n.onsuccess=()=>{const r=n.result,o=r.transaction(E,"readwrite"),c=o.objectStore(E),l=c.get(path);let d;l.onsuccess=()=>{if(null==l.result)return r.close(),e(new Error(`Cannot find model with path '${path}' in IndexedDB.`));{const n=c.delete(path),o=()=>{d=r.transaction(j,"readwrite");const n=d.objectStore(j).delete(path);n.onsuccess=()=>t(l.result.modelArtifactsInfo),n.onerror=t=>e(l.error)};n.onsuccess=o,n.onerror=t=>(o(),r.close(),e(l.error))}},l.onerror=t=>(r.close(),e(l.error)),o.oncomplete=()=>{null==d?r.close():d.oncomplete=()=>r.close()}},n.onerror=t=>e(n.error)}))}}var T=n(225);const I="/",A="tensorflowjs_models",k="info",D="model_topology",_="weight_specs",F="weight_data",P="model_metadata";function M(path){return{info:[A,path,k].join(I),topology:[A,path,D].join(I),weightSpecs:[A,path,_].join(I),weightData:[A,path,F].join(I),modelMetadata:[A,path,P].join(I)}}function B(t){const e=t.split(I);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(I)}class L{constructor(t){if(!Object(h.b)().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=M(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=Object(f.g)(t);try{return this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,Object(f.a)(t.weightData)),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata})),{modelArtifactsInfo:r}}catch(t){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;const o=this.LS.getItem(this.keys.modelMetadata);if(null!=o){const t=JSON.parse(o);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,e.userDefinedMetadata=t.userDefinedMetadata}const c=this.LS.getItem(this.keys.weightData);if(null==c)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=Object(f.b)(c),e}}L.URL_SCHEME="localstorage://";const V=t=>{return Object(h.b)().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(L.URL_SCHEME)?(e=t.slice(L.URL_SCHEME.length),new L(e)):null;var e};m.registerSaveRouter(V),m.registerLoadRouter(V);class z{constructor(){Object(T.assert)(Object(h.b)().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Object(T.assert)("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const t={},e=A+I,n=I+k;for(let i=0;i<this.LS.length;++i){const r=this.LS.key(i);if(r.startsWith(e)&&r.endsWith(n)){t[B(r)]=JSON.parse(this.LS.getItem(r))}}return t}async removeModel(path){var t;const e=M(path=(t=path).startsWith(L.URL_SCHEME)?t.slice(L.URL_SCHEME.length):t);if(null==this.LS.getItem(e.info))throw new Error(`Cannot find model at path '${path}'`);const n=JSON.parse(this.LS.getItem(e.info));return this.LS.removeItem(e.info),this.LS.removeItem(e.topology),this.LS.removeItem(e.weightSpecs),this.LS.removeItem(e.weightData),n}}const U="://";class W{constructor(){this.managers={}}static getInstance(){return null==W.instance&&(W.instance=new W),W.instance}static registerManager(t,e){Object(T.assert)(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith(U)&&(t=t.slice(0,t.indexOf(U))),Object(T.assert)(t.length>0,(()=>"scheme must not be an empty string."));const n=W.getInstance();Object(T.assert)(null==n.managers[t],(()=>`A model store manager is already registered for scheme '${t}'.`)),n.managers[t]=e}static getManager(t){const e=this.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}function G(t){if(-1===t.indexOf(U))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${W.getSchemes().join(",")}`);return{scheme:t.split(U)[0],path:t.split(U)[1]}}async function H(t,e,n=!1){Object(T.assert)(t!==e,(()=>`Old path and new path are the same: '${t}'`));const r=m.getLoadHandlers(t);Object(T.assert)(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${t}.`)),Object(T.assert)(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`));const o=r[0],c=m.getSaveHandlers(e);Object(T.assert)(c.length>0,(()=>`Copying failed because no save handler is found for destination URL ${e}.`)),Object(T.assert)(c.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`));const l=c[0],d=G(t).scheme,h=G(t).path,f=d===G(t).scheme,y=await o.load();n&&f&&await W.getManager(d).removeModel(h);const O=await l.save(y);return n&&!f&&await W.getManager(d).removeModel(h),O.modelArtifactsInfo}async function K(){const t=W.getSchemes(),e={};for(const n of t){const t=await W.getManager(n).listModels();for(const path in t){e[n+U+path]=t[path]}}return e}async function X(t){const e=G(t);return W.getManager(e.scheme).removeModel(e.path)}async function Y(t,e){return H(t,e,!1)}async function Q(t,e){return H(t,e,!0)}class J{fetch(path,t){return fetch(path,t)}now(){return performance.now()}encode(text,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(text)}decode(t,e){return new TextDecoder(e).decode(t)}}if(Object(h.b)().get("IS_BROWSER")){Object(h.b)().setPlatform("browser",new J);try{W.registerManager(L.URL_SCHEME,new z)}catch(t){}try{W.registerManager(N.URL_SCHEME,new S)}catch(t){}}n(519);var Z=n(268),tt=n(230),et=n(286),nt=n(366),at=n(223);Object(d.b)();const st={buffer:Z.a,cast:tt.a,clone:et.a,print:nt.a};Object(at.e)(st);function ot(t){return new Promise((t=>setTimeout(t))).then(t)}class it{constructor(t){if(!Object(h.b)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(it.URL_SCHEME)&&(t=t.slice(it.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelTopologyFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n},o=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),c=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor;if(c.download=this.modelTopologyFileName,c.href=o,await ot((()=>c.dispatchEvent(new MouseEvent("click")))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=e,await ot((()=>t.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Object(f.g)(t)}}}}it.URL_SCHEME="downloads://";class ct{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.files=t}async load(){const t=this.files[0],e=this.files.slice(1);return new Promise(((n,r)=>{const o=new FileReader;o.onload=o=>{const c=JSON.parse(o.target.result),l=c.modelTopology;if(null==l)return void r(new Error(`modelTopology field is missing from file ${t.name}`));0===e.length&&n({modelTopology:l});const d=c.weightsManifest;if(null==d)return void r(new Error(`weightManifest field is missing from file ${t.name}`));let h;try{h=this.checkManifestAndWeightFiles(d,e)}catch(t){return void r(t)}const m=[],y=[],O=[];d.forEach((t=>{t.paths.forEach((path=>{y.push(path),O.push(null)})),m.push(...t.weights)})),d.forEach((t=>{t.paths.forEach((path=>{const t=new FileReader;t.onload=t=>{const e=t.target.result,r=y.indexOf(path);O[r]=e,-1===O.indexOf(null)&&n({modelTopology:l,weightSpecs:m,weightData:Object(f.d)(O),format:c.format,generatedBy:c.generatedBy,convertedBy:c.convertedBy,userDefinedMetadata:c.userDefinedMetadata})},t.onerror=t=>r(`Failed to weights data from file of path '${path}'.`),t.readAsArrayBuffer(h[path])}))}))},o.onerror=e=>r(`Failed to read model topology and weights manifest JSON from file '${t.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),o.readAsText(t)}))}checkManifestAndWeightFiles(t,e){const n=[],r=e.map((t=>Object(f.c)(t.name))),o={};for(const c of t)c.paths.forEach((path=>{const t=Object(f.c)(path);if(-1!==n.indexOf(t))throw new Error(`Duplicate file basename found in weights manifest: '${t}'`);if(n.push(t),-1===r.indexOf(t))throw new Error(`Weight file with basename '${t}' is not provided.`);o[path]=e[r.indexOf(t)]}));if(n.length!==e.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${e.length}).`);return o}}function ut(t){return new ct(t)}function lt(t,e,n,r){!function(t){Object(T.assert)(null!=t&&Array.isArray(t)&&t.length>0,(()=>"promises must be a none empty array"))}(t),function(t,e){Object(T.assert)(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${t}`)),Object(T.assert)(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${e}`)),Object(T.assert)(e>=t,(()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction ${e}`))}(n=null==n?0:n,r=null==r?1:r);let o=0;return Promise.all(t.map((c=>(c.then((c=>{const l=n+ ++o/t.length*(r-n);return e(l),c})),c))))}m.registerSaveRouter((t=>Object(h.b)().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(it.URL_SCHEME)?function(t="model"){return new it(t)}(t.slice(it.URL_SCHEME.length)):null));var pt=n(415);async function ht(t,e){null==e&&(e={});const n=null==e.fetchFunc?Object(h.b)().platform.fetch:e.fetchFunc,r=t.map((t=>n(t,e.requestInit,{isBinary:!0}))),o=(null==e.onProgress?await Promise.all(r):await lt(r,e.onProgress,0,.5)).map((t=>t.arrayBuffer()));return null==e.onProgress?await Promise.all(o):await lt(o,e.onProgress,.5,1)}async function ft(t,e="",n,r){return mt((t=>ht(t,{requestInit:r})))(t,e,n)}function mt(t){return async(e,n="",r)=>{const o=e.map((()=>!1)),c={},l=null!=r?r.map((()=>!1)):[],d=[];if(e.forEach(((t,e)=>{let n=0;t.weights.forEach((t=>{const h="quantization"in t?t.quantization.dtype:t.dtype,f=pt.a[h]*T.sizeFromShape(t.shape),m=()=>{o[e]=!0,null==c[e]&&(c[e]=[]),c[e].push({manifestEntry:t,groupOffset:n,sizeBytes:f})};null!=r?r.forEach(((e,n)=>{e===t.name&&(m(),l[n]=!0)})):m(),d.push(t.name),n+=f}))})),!l.every((t=>t))){const t=r.filter(((t,i)=>!l[i]));throw new Error(`Could not find weights in manifest with names: ${t.join(", ")}. \nManifest JSON has weights with names: ${d.join(", ")}.`)}const h=o.reduce(((t,e,i)=>(e&&t.push(i),t)),[]),m=[];h.forEach((i=>{e[i].paths.forEach((t=>{const e=n+(n.endsWith("/")?"":"/")+t;m.push(e)}))}));const y=await t(m),O={};let x=0;return h.forEach((i=>{const t=e[i].paths.length;let n=0;for(let i=0;i<t;i++)n+=y[x+i].byteLength;const r=new ArrayBuffer(n),o=new Uint8Array(r);let l=0;for(let i=0;i<t;i++){const t=new Uint8Array(y[x+i]);o.set(t,l),l+=t.byteLength}c[i].forEach((t=>{const e=r.slice(t.groupOffset,t.groupOffset+t.sizeBytes),n=Object(f.e)(e,[t.manifestEntry]);for(const t in n)O[t]=n[t]})),x+=t})),O}}class bt{constructor(path,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Object(T.assert)("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=Object(h.b)().platform.fetch,Object(T.assert)(null!=path&&path.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(path)&&Object(T.assert)(2===path.length,(()=>`URL paths for http must have a length of 2, (actual length is ${path.length}).`)),this.path=path,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata,weightsManifest:n};e.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const o=await this.fetch(this.path,e);if(o.ok)return{modelArtifactsInfo:Object(f.g)(t),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(t){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=e.modelTopology,r=e.weightsManifest,o=e.generatedBy,c=e.convertedBy,l=e.format,d=e.userDefinedMetadata;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let h,f;if(null!=r){const t=await this.loadWeights(r);[h,f]=t}const m={modelTopology:n,weightSpecs:h,weightData:f,userDefinedMetadata:d,generatedBy:o,convertedBy:c,format:l},y=e.modelInitializer;return y&&(m.modelInitializer=y),m}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),o=n>e?t.substring(n):"";return[r+"/",o]}(e),o=this.weightPathPrefix||n,c=[];for(const e of t)c.push(...e.weights);const l=[],d=[];for(const e of t)for(const path of e.paths)null!=this.weightUrlConverter?d.push(this.weightUrlConverter(path)):l.push(o+path+r);this.weightUrlConverter&&l.push(...await Promise.all(d));const h=await ht(l,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[c,Object(f.d)(h)]}}function gt(t){return null!=t.match(bt.URL_SCHEME_REGEX)}bt.URL_SCHEME_REGEX=/^https?:\/\//;const yt=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every((t=>gt(t))):gt(t),n)return Ot(t,e)}return null};function Ot(path,t){return new bt(path,t)}function xt(path,t){return Ot(path,t)}m.registerSaveRouter(yt),m.registerLoadRouter(yt);class vt{constructor(t){this.modelArtifacts=t}async load(){return this.modelArtifacts}}class wt{constructor(t){this.saveHandler=t}async save(t){return this.saveHandler(t)}}function jt(t,e,n,r){if(1===arguments.length){return null!=t.modelTopology||null!=t.weightSpecs?new vt(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new vt({modelTopology:t}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new vt({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r})}function Et(t){return new wt(t)}var $t=n(220),Ct=n(310),Nt=n(222),Rt=n(221),St=n(375);let Tt;async function It(img,canvas){let t=Object(Nt.a)(img,"img","toPixels");if(!(img instanceof at.a)){const e=t;t=Object(tt.a)(e,"int32"),e.dispose()}if(2!==t.rank&&3!==t.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const[e,n]=t.shape.slice(0,2),r=2===t.rank?1:t.shape[2];if(r>4||2===r)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${r}`);if("float32"!==t.dtype&&"int32"!==t.dtype)throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);const data=await t.data(),o="float32"===t.dtype?255:1,c=new Uint8ClampedArray(n*e*4);for(let i=0;i<e*n;++i){const e=[0,0,0,255];for(let n=0;n<r;n++){const c=data[i*r+n];if("float32"===t.dtype){if(c<0||c>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${c}.`)}else if("int32"===t.dtype&&(c<0||c>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${c}.`);1===r?(e[0]=c*o,e[1]=c*o,e[2]=c*o):e[n]=c*o}const n=4*i;c[n+0]=Math.round(e[0]),c[n+1]=Math.round(e[1]),c[n+2]=Math.round(e[2]),c[n+3]=Math.round(e[3])}if(null!=canvas){canvas.width=n,canvas.height=e;const t=canvas.getContext("2d"),r=new ImageData(c,n,e);t.putImageData(r,0,0)}return t!==img&&t.dispose(),c}const At=Object(Rt.a)({fromPixels_:function(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,o=!1,c=!1,l=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&t instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement)o=!0;else if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement)c=!0;else{if(null==t.getContext)throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);l=!0}if(o){const e=2;if(o&&t.readyState<e)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=Object(Ct.b)($t.db,d.a.backendName)){const n={pixels:t},r={numChannels:e};return d.a.runKernel($t.db,n,r)}const[h,f]=o?[t.videoWidth,t.videoHeight]:[t.width,t.height];let m,y;if(l?m=t.getContext("2d").getImageData(0,0,h,f).data:r||n?m=t.data:(c||o)&&(null==Tt&&(Tt=document.createElement("canvas").getContext("2d")),Tt.canvas.width=h,Tt.canvas.height=f,Tt.drawImage(t,0,0,h,f),m=Tt.getImageData(0,0,h,f).data),4===e)y=new Int32Array(m);else{const t=h*f;y=new Int32Array(t*e);for(let i=0;i<t;i++)for(let t=0;t<e;++t)y[i*e+t]=m[4*i+t]}const O=[f,h,e];return Object(St.a)(y,O,"int32")}});var kt=n(278),Dt=n(277),_t=n(228),Ft=n(273),Pt=n(232),Mt=n(288),Bt=n(269),Lt=n(239),Vt=n(231),zt=n(367),Ut=n(237),Wt=n(283),Gt=n(376);function Ht(t,e,n){return[n*("number"==typeof t?t:t[0]),e*("number"==typeof t?t:t[1])]}function qt(t,e,n,r=!0){let o=[];if(r)o=o.concat(e.slice(0)),o.push(t[0]/n),o=o.concat(t.slice(1));else{o=o.concat(t[0]);const n=e.length;for(let i=0;i<n;++i)o=o.concat([t[i+1]/e[i],e[i]]);o=o.concat(t.slice(n+1))}return o}function Kt(t,e,n=!0){const r=[];if(n){r.push(e);for(let i=e+1;i<t;++i)i<=2*e?(r.push(i),r.push(i-(e+1))):r.push(i)}else{const n=[],o=[];for(let i=1;i<t;++i)i>=2*e+1||i%2==1?o.push(i):n.push(i);r.push(...n),r.push(0),r.push(...o)}return r}function Xt(t,e,n,r=!0){const o=[];r?o.push(t[0]/n):o.push(t[0]*n);for(let i=1;i<t.length;++i)i<=e.length?r?o.push(e[i-1]*t[i]):o.push(t[i]/e[i-1]):o.push(t[i]);return o}function Yt(t,e){const n=[0];for(let i=0;i<e;++i)n.push(t[i][0]);return n}function Qt(t,e,n){const r=t.slice(0,1);for(let i=0;i<n;++i)r.push(t[i+1]-e[i][0]-e[i][1]);return r}function Jt(t,e){if(t.rank<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[e.rank-1]>t.rank)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[e.rank-1]} vs. ${t.rank}`);if(0===t.size)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const n=e.shape,r=n[n.length-1];let o=1;for(let i=0;i<n.length-1;++i)o*=n[i];const c=t.shape,l=n.slice();l.pop();let d=1;for(let i=r;i<t.rank;++i)d*=c[i],l.push(c[i]);const h=[...Object(T.computeStrides)(t.shape).map((t=>t/d)),1].slice(0,r);return[l,o,d,h]}var Zt=n(322);const te=1.7580993408473768,ee=1.0507009873554805,ne=.3275911,re=.254829592,ae=-.284496736,se=1.421413741,oe=-1.453152027,ie=1.061405429;function ce(...t){Object(h.b)().getBool("IS_TEST")||console.warn(...t)}function ue(...t){Object(h.b)().getBool("IS_TEST")||console.log(...t)}function le(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(2*t.length);for(let i=0;i<n.length;i+=2)n[i]=t[i/2],n[i+1]=e[i/2];return n}function de(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let i=0;i<t.length;i+=2)e[i/2]=t[i],n[i/2]=t[i+1];return{real:e,imag:n}}function pe(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let i=0;i<t.length;i+=4)n[Math.floor(i/4)]=t[i],r[Math.floor(i/4)]=t[i+1];return{real:n,imag:r}}function he(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let i=2;i<t.length;i+=4)n[Math.floor(i/4)]=t[i],r[Math.floor(i/4)]=t[i+1];return{real:n,imag:r}}function fe(t,e){return{real:t[2*e],imag:t[2*e+1]}}function me(data,t,e,n){data[2*n]=t,data[2*n+1]=e}function be(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let i=0;i<Math.ceil(t/2);i++){const o=(e?2:-2)*Math.PI*(i/t);n[i]=Math.cos(o),r[i]=Math.sin(o)}return{real:n,imag:r}}function ge(t,e,n){const r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}}var ye=n(369),Oe=n(377);function xe(t,e,n){if("complex64"===e){if("complex64"===t.dtype)return t.clone();const e=Object(Bt.a)(t.shape),r=Object(tt.a)(t,"float32"),o=n.complex(r,e);return e.dispose(),r.dispose(),o}if(!Object(T.hasEncodingLoss)(t.dtype,e))return d.a.makeTensorFromDataId(t.dataId,t.shape,e);if("complex64"===t.dtype){const r=n.real(t),o=Object(tt.a)(r,e);return r.dispose(),o}if("int32"===e)return n.int(t);if("bool"===e){const e=Object(Pt.a)(0,t.dtype),r=n.notEqual(t,e);return e.dispose(),r}throw new Error(`Error in Cast: failed to cast ${t.dtype} to ${e}`)}function ve(t,e){return d.a.makeTensorFromDataId(t.dataId,e,t.dtype)}function we(t,e,n){const r=(e-t)/(n-1),o=Object(T.makeZerosTypedArray)(n,"float32");o[0]=t;for(let i=1;i<o.length;i++)o[i]=o[i-1]+r;return Object(Mt.a)(o,"float32")}var je=n(363),Ee=n(285),$e=n(259);function Ce(t,e,n){const r=new Array(t.rank).fill(0),o=t.shape.slice();return e.map((s=>{const e=[...o];e[n]=s;const c=Object($e.a)(t,r,e);return r[n]+=s,c}))}function Ne(t,e){const n=new Array(t.rank);for(let i=0;i<n.length;i++)n[i]=t.shape[i]*e[i];const r=Object(Z.a)(n,t.dtype);for(let i=0;i<r.values.length;++i){const e=r.indexToLoc(i),n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=e[r]%t.shape[r];const o=t.locToIndex(n);r.values[i]=t.values[o]}return r.toTensor()}var Re=n(312);function Se(t,e,n,r,o){const c=e[e.length-1],[l,d]=[t.length/c,c],h=Object(T.getTypedArrayFromDType)(n,l*r),f=Object(T.getTypedArrayFromDType)("int32",l*r);for(let b=0;b<l;b++){const e=b*d,n=t.subarray(e,e+d),o=[];for(let i=0;i<n.length;i++)o.push({value:n[i],index:i});o.sort(((a,b)=>b.value-a.value));const c=b*r,l=h.subarray(c,c+r),m=f.subarray(c,c+r);for(let i=0;i<r;i++)l[i]=o[i].value,m[i]=o[i].index}const m=e.slice();return m[m.length-1]=r,[Object(Re.a)(h,m,n),Object(Re.a)(f,m,"int32")]}var Te=n(378),Ie=n(331),Ae=n(229),ke=n(295);const De={kernelName:$t.a,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(Ae.a)(t,Object(ke.a)(Object(tt.a)(n,"float32"),-1))}}};var div=n(235),_e=n(246),Fe=n(272),Pe=n(250),sub=n(233);const Me={kernelName:$t.b,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const a=Object(Pe.a)(Object(tt.a)(n,"float32")),b=Object(Fe.a)(Object(sub.a)(Object(Pt.a)(1),a));return Object(_e.a)(Object(div.a)(t,b))}}}},Be={kernelName:$t.c,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const a=Object(Fe.a)(Object(sub.a)(Object(Pe.a)(Object(tt.a)(n,"float32")),1));return Object(div.a)(t,a)}}}};var Le=n(227),Ve=n(236);const ze={kernelName:$t.d,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[a,b]=e,n=Vt.a(a.shape,b.shape);return{a:()=>{let e=t;const r=Vt.c(a.shape,n);return r.length>0&&(e=Object(Ve.a)(e,r)),Object(Le.a)(e,a.shape)},b:()=>{let e=t;const r=Vt.c(b.shape,n);return r.length>0&&(e=Object(Ve.a)(e,r)),Object(Le.a)(e,b.shape)}}}},Ue={kernelName:$t.e,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach(((e,i)=>{n[i]=()=>t.clone()})),n}};var We=n(238);const Ge={kernelName:$t.h,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(We.a)(n)}}},He={kernelName:$t.i,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(We.a)(n)}}},qe={kernelName:$t.j,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(div.a)(t,Object(Fe.a)(Object(sub.a)(Object(Pt.a)(1),Object(Pe.a)(Object(tt.a)(n,"float32")))))}}};var Ke=n(245);const Xe={kernelName:$t.k,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const a=Object(Fe.a)(Object(Ke.a)(Object(Pt.a)(1),Object(Pe.a)(Object(tt.a)(n,"float32"))));return Object(div.a)(t,a)}}}},Ye={kernelName:$t.m,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[a,b]=e,n=Object(Vt.a)(a.shape,b.shape);return{a:()=>{const e=Object(Ke.a)(Object(Pe.a)(a),Object(Pe.a)(b));let r=Object(Ae.a)(t,Object(div.a)(b,e));const o=Object(Vt.c)(a.shape,n);return o.length>0&&(r=Object(Ve.a)(r,o)),Object(Le.a)(r,a.shape)},b:()=>{const e=Object(Ke.a)(Object(Pe.a)(a),Object(Pe.a)(b));let r=Object(_e.a)(Object(Ae.a)(t,Object(div.a)(a,e)));const o=Object(Vt.c)(b.shape,n);return o.length>0&&(r=Object(Ve.a)(r,o)),Object(Le.a)(r,b.shape)}}}},Qe={kernelName:$t.l,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(div.a)(t,Object(Ke.a)(Object(Pe.a)(Object(tt.a)(n,"float32")),1))}}},Je={kernelName:$t.n,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(div.a)(t,Object(sub.a)(Object(Pt.a)(1),Object(Pe.a)(Object(tt.a)(n,"float32"))))}}};const Ze=Object(Rt.a)({avgPool3dBackprop_:function(t,input,e,n,r=[1,1,1],o,c){const l=Object(Nt.a)(t,"dy","avgPool3dBackprop"),h=Object(Nt.a)(input,"input","avgPool3dBackprop");let f=l,m=h,y=!1;4===h.rank&&(y=!0,f=Object(Le.a)(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),m=Object(Le.a)(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),T.assert(5===f.rank,(()=>`Error in avgPool3dBackprop: dy must be rank 5 but got rank ${f.rank}.`)),T.assert(5===m.rank,(()=>`Error in avgPool3dBackprop: input must be rank 5 but got rank ${m.rank}.`)),T.assert(Ut.h(n,r),(()=>`Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides ${n} and dilations '${r}'`)),null!=c&&T.assert(T.isInt(o),(()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${c} but got pad ${o}.`));const O={dy:f,input:m},x={filterSize:e,strides:n,dilations:r,pad:o,dimRoundingMode:c},v=d.a.runKernelFunc((t=>{const l=Ut.f(m.shape,e,n,r,o,c);return t.avgPool3dBackprop(f,m,l)}),O,null,$t.q,x);return y?Object(Le.a)(v,[v.shape[1],v.shape[2],v.shape[3],v.shape[4]]):v}}),tn={kernelName:$t.p,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:o,strides:c,dilations:l,pad:d,dimRoundingMode:h}=n,f=null==l?[1,1,1]:l;return{x:()=>Ze(t,r,o,c,f,d,h)}}};const en=Object(Rt.a)({avgPoolBackprop_:function(t,input,e,n,r){const o=Object(Nt.a)(t,"dy","avgPoolBackprop"),c=Object(Nt.a)(input,"input","avgPoolBackprop");T.assert(c.rank===o.rank,(()=>`Rank of input (${c.rank}) does not match rank of dy (${o.rank})`));let l=c,h=o,f=!1;3===c.rank&&(f=!0,l=Object(Le.a)(c,[1,c.shape[0],c.shape[1],c.shape[2]]),h=Object(Le.a)(o,[1,o.shape[0],o.shape[1],o.shape[2]])),T.assert(4===h.rank,(()=>`Error in avgPoolBackprop: dy must be rank 4 but got rank ${h.rank}.`)),T.assert(4===l.rank,(()=>`Error in avgPoolBackprop: input must be rank 4 but got rank ${l.rank}.`));const m={dy:h,input:l},y={filterSize:e,strides:n,pad:r},O=d.a.runKernelFunc((t=>{const o=Ut.e(l.shape,e,n,1,r);return t.avgPoolBackprop(h,l,o)}),m,null,$t.r,y);return f?Object(Le.a)(O,[O.shape[1],O.shape[2],O.shape[3]]):O}}),nn={kernelName:$t.o,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:o,strides:c,pad:l}=n;return{x:()=>en(t,r,o,c,l)}}};var rn=n(282);const an={kernelName:$t.s,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[a,b]=e,{transposeA:r,transposeB:o}=n;return r||o?!r&&o?{a:()=>Object(rn.a)(t,b,!1,!1),b:()=>Object(rn.a)(t,a,!0,!1)}:r&&!o?{a:()=>Object(rn.a)(b,t,!1,!0),b:()=>Object(rn.a)(a,t,!1,!1)}:{a:()=>Object(rn.a)(b,t,!0,!0),b:()=>Object(rn.a)(t,a,!0,!0)}:{a:()=>Object(rn.a)(t,b,!1,!0),b:()=>Object(rn.a)(a,t,!0,!1)}}};var sn=n(323);const on={kernelName:$t.t,gradFunc:(t,e,n)=>{const{blockShape:r,crops:o}=n;return{x:()=>Object(sn.a)(t,r,o)}}},cn={kernelName:$t.u,gradFunc:(t,e,n)=>{const r=n,o=r.inputShape,c=r.shape,l=Array.from(c);for(let i=o.length-1;i>=0;i--)if(o[i]===c[i])l[i]=1;else if(1!==o[i])throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${c}].`);const d=[];for(let i=0;i<l.length;i++)l[i]>1&&d.push(i);return{x:()=>Object(Ve.a)(t,d,!0)}}},un={kernelName:$t.v,gradFunc:t=>({x:()=>t.clone()})},ln={kernelName:$t.w,gradFunc:t=>({x:()=>Object(We.a)(t)})};var dn=n(271),pn=n(270),hn=n(280),fn=n(260);const mn={kernelName:$t.x,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{clipValueMin:o,clipValueMax:c}=n;return{x:()=>Object(fn.a)(Object(hn.a)(Object(dn.a)(r,o),Object(pn.a)(r,c)),t,Object(We.a)(t))}}};var bn=n(290);const gn={kernelName:$t.z,saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map((t=>t.shape)),{axis:o}=n,c=Object(T.parseAxisParam)(o,e[0].shape)[0],l=r.map((s=>s[c]));return Object(bn.a)(t,l,c).map((t=>()=>t))}};var yn=n(374),On=n(373);const xn={kernelName:$t.A,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,o]=e,{dilations:c,strides:l,pad:d,dataFormat:h}=n;return T.assert(Ut.i(c),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${c}'`)),{x:()=>Object(On.a)(r.shape,t,o,l,d,h),filter:()=>Object(yn.a)(r,t,o.shape,l,d,h)}}};var vn=n(284);const wn={kernelName:$t.C,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,filter]=e,{strides:o,pad:c,dataFormat:l,dimRoundingMode:d}=n;return{dy:()=>Object(vn.a)(t,filter,o,c,l,1,d),filter:()=>Object(yn.a)(t,r,filter.shape,o,c,l,d)}}};const jn=Object(Rt.a)({conv3DBackpropFilter_:function(t,e,n,r,o){let c=t;4===t.rank&&(c=Object(Le.a)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let l=e;4===l.rank&&(l=Object(Le.a)(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),T.assert(5===c.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${c.shape}.`)),T.assert(5===l.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${l.shape}.`)),T.assert(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),T.assert(c.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${c.shape[4]}) must match input depth in filter (${n[3]}.`)),T.assert(l.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${l.shape[4]}) must match output depth for filter (${n[4]}).`));const h={x:c,y:l},f={strides:r,pad:o};return d.a.runKernelFunc((t=>{const e=Ut.b(c.shape,n,r,1,o);return t.conv3dDerFilter(c,l,e)}),h,null,$t.E,f)}});const En=Object(Rt.a)({conv3DBackpropInput_:function(t,e,filter,n,r){T.assert(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let o=t,c=e,l=!1;4===e.rank&&(l=!0,c=Object(Le.a)(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,t[0],t[1],t[2],t[3]]);const h=o[4],f=c.shape[4];T.assert(5===o.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`)),T.assert(5===c.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${c.rank}`)),T.assert(5===filter.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${filter.rank}`)),T.assert(h===filter.shape[3],(()=>`Error in conv3dDerInput: depth of input (${h}) must match input depth for filter ${filter.shape[3]}.`)),T.assert(f===filter.shape[4],(()=>`Error in conv3dDerInput: depth of output (${f}) must match output depth for filter ${filter.shape[4]}.`));const m={dy:c},y={pad:r},O=d.a.runKernelFunc((t=>{const e=Ut.b(o,filter.shape,n,1,r);return t.conv3dDerInput(c,filter,e)}),m,null,$t.F,y);return l?Object(Le.a)(O,[O.shape[1],O.shape[2],O.shape[3],O.shape[4]]):O}}),$n={kernelName:$t.D,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:o,pad:c}=n;T.assert(Object(Ut.i)(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[l,d]=e;return{x:()=>En(l.shape,t,d,o,c),filter:()=>jn(l,t,d.shape,o,c)}}};var Cn=n(379);const Nn={kernelName:$t.G,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(Ae.a)(Object(_e.a)(Object(Cn.a)(Object(tt.a)(n,"float32"))),t)}}};var Rn=n(380);const Sn={kernelName:$t.H,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(Ae.a)(Object(Rn.a)(Object(tt.a)(n,"float32")),t)}}};var Tn=n(346),In=n(241);const An={kernelName:$t.J,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:o,exclusive:c,reverse:l}=n;return{x:()=>{const e=Object(Lt.f)([o],r.rank);let n=Object(Tn.a)(t,o,c,!l);return null!=e&&(n=Object(In.a)(n,e)),n}}}};var kn=n(420),Dn=n(419);const _n={kernelName:$t.L,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:o,pad:c,dimRoundingMode:l}=n,d=null==r?[1,1]:r;T.assert(Ut.i(d),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${d}'`));const[h,filter]=e;T.assert(4===h.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${h.rank}.`)),T.assert(4===filter.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${filter.rank}.`)),T.assert(h.shape[3]===filter.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${filter.shape[2]}.`)),T.assert(Ut.h(o,d),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${d}'.`)),null!=l&&T.assert(T.isInt(c),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${l} but got pad ${c}.`));const f=Ut.a(h.shape,filter.shape,o,d,c,l,!0);return{x:()=>Object(Dn.a)(h.shape,t,filter,f),filter:()=>Object(kn.a)(h,t,filter.shape,f)}}},Fn={kernelName:$t.O,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,filter]=e,o={x:r,filter:filter,dy:t},c={x:r,filter:filter,dy:t};return{x:()=>d.a.runKernel($t.Q,o,n),filter:()=>d.a.runKernel($t.P,c,n)}}},Pn={kernelName:$t.R,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[a,b]=e,n=Vt.a(a.shape,b.shape);return{a:()=>{const e=Object(div.a)(t,Object(tt.a)(b,"float32")),r=Vt.c(a.shape,n);return r.length>0?Object(Le.a)(Object(Ve.a)(e,r),a.shape):e},b:()=>{let e=Object(Ae.a)(t,Object(tt.a)(a,"float32"));const r=Vt.c(b.shape,n);r.length>0&&(e=Object(Le.a)(Object(Ve.a)(e,r),b.shape));const o=Object(Pe.a)(b);return Object(_e.a)(Object(div.a)(e,Object(tt.a)(o,"float32")))}}}},Mn={kernelName:$t.S,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r=e=>e.eluDer(t,n),o={dy:t,y:n};return{x:()=>d.a.runKernelFunc(r,o,null,$t.T)}}};var Bn=n(263);const Ln={kernelName:$t.V,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,a=Object(Ae.a)(Object(Bn.a)(Object(_e.a)(Object(Pe.a)(n))),2/Math.sqrt(Math.PI));return{x:()=>Object(Ae.a)(t,a)}}},Vn={kernelName:$t.W,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(Ae.a)(t,n)}}},zn={kernelName:$t.X,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(Ae.a)(t,Object(Bn.a)(n))}}},Un={kernelName:$t.bb,gradFunc:t=>({x:()=>Object(We.a)(t)})},Wn={kernelName:$t.cb,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[a,b]=e,n=Object(Vt.a)(a.shape,b.shape);return{a:()=>{const e=Object(div.a)(t,Object(tt.a)(b,"float32")),r=Object(Vt.c)(a.shape,n);return r.length>0?Object(Le.a)(Object(Ve.a)(e,r),a.shape):e},b:()=>{let e=Object(Ae.a)(t,Object(tt.a)(a,"float32"));const r=Object(Vt.c)(b.shape,n);r.length>0&&(e=Object(Le.a)(Object(Ve.a)(e,r),b.shape));const o=Object(Pe.a)(b);return Object(_e.a)(Object(div.a)(e,Object(tt.a)(o,"float32")))}}}};var Gn=n(381),Hn=n(318);const qn={kernelName:$t.eb,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[o,c,l,d]=e,h=null==d?Object(Pt.a)(1):d,f=Object(Vt.c)(c.shape,o.shape),m=[];if(1===c.rank){for(let i=0;i<o.shape.length-1;++i)m.push(o.shape[i]);m.push(1)}const y=Object(sub.a)(o,c),O=Object(Ae.a)(t,h),x=Object(Gn.a)(Object(Ke.a)(l,Object(Pt.a)(r))),v=Object(Ae.a)(Object(Ae.a)(Object(Ae.a)(x,x),x),Object(Pt.a)(-.5));return{x:()=>1===c.rank?Object(Le.a)(Object(Ae.a)(Object(Ae.a)(t,Object(Hn.a)(Object(Le.a)(x,[1,1,1,c.shape[0]]),m)),h),o.shape):Object(Le.a)(Object(Ae.a)(Object(Ae.a)(t,x),h),o.shape),mean:()=>{let t=Object(Ae.a)(Object(Ae.a)(x,Object(Pt.a)(-1)),O);return 1===c.rank&&(t=Object(Ve.a)(t,f)),Object(Le.a)(t,c.shape)},variance:()=>{let t=Object(Ae.a)(Object(Ae.a)(v,y),O);return 1===c.rank&&(t=Object(Ve.a)(t,f)),Object(Le.a)(t,c.shape)},scale:()=>{const e=Object(Ae.a)(y,x);let n=Object(Ae.a)(t,e);return 1===c.rank&&(n=Object(Ve.a)(n,f)),Object(Le.a)(n,c.shape)},offset:()=>{let e=t;return 1===c.rank&&(e=Object(Ve.a)(e,f)),Object(Le.a)(e,c.shape)}}}};var Kn=n(347);const Xn={kernelName:$t.ib,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[r,o]=e,{axis:c}=n,l=Object(T.parseAxisParam)(c,r.shape)[0];return{x:()=>{const e=r.shape,n=o.size,d=e.slice(0,l),h=d.length,f=e.slice(c,e.length).slice(1),m=f.length,y=Yn(0,h),O=Yn(h+1,h+1+m),x=Qn([d,[n],f]),v=Object(Le.a)(t,x),w=Object(Le.a)(o,[n]),j=Qn([[h],y,O]),E=Object(In.a)(v,j);let $=Object(Kn.a)(E,w,r.shape[l]);const C=Object(Lt.h)(j);return $=Object(In.a)($,C),$},indices:()=>o}}};function Yn(t,e){const n=[];for(let i=t;i<e;++i)n.push(i);return n}function Qn(t){const e=[];for(let i=0;i<t.length;++i)for(let n=0;n<t[i].length;++n)e.push(t[i][n]);return e}const Jn={kernelName:$t.kb,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[a,b]=e;return{a:()=>Object(We.a)(a),b:()=>Object(We.a)(b)}}},Zn={kernelName:$t.mb,gradFunc:t=>({x:()=>Object(tt.a)(t,"float32")})},er={kernelName:$t.ob,gradFunc:t=>({x:()=>Object(We.a)(t)})},nr={kernelName:$t.pb,gradFunc:t=>({x:()=>Object(We.a)(t)})},rr={kernelName:$t.qb,gradFunc:t=>({x:()=>Object(We.a)(t)})},ar={kernelName:$t.xb,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(div.a)(t,Object(Ke.a)(n,1))}}},sr={kernelName:$t.wb,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(div.a)(t,Object(tt.a)(n,"float32"))}}},or={kernelName:$t.yb,inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{axis:o}=n;return{logits:()=>{const e=Object(Bn.a)(r);return Object(sub.a)(t,Object(Ae.a)(Object(Ve.a)(t,o,!0),e))}}}};const ir=Object(Rt.a)({localResponseNormalizationBackprop_:function(t,e,n,r=5,o=1,c=1,l=.5){const h={x:t,y:e,dy:n},f={depthRadius:r,bias:o,alpha:c,beta:l};return d.a.runKernelFunc((d=>d.LRNGrad(n,t,e,r,o,c,l)),h,null,$t.sb,f)}}),cr={kernelName:$t.rb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,o]=e,{depthRadius:c,bias:l,alpha:d,beta:h}=n;return{x:()=>ir(r,o,t,c,l,d,h)}}};var ur=n(297);function lr(t,e,n,r,o){return e.rank<n.rank&&(e=Object(Le.a)(e,Lt.e(e.shape,r))),t.rank<n.rank&&(t=Object(Le.a)(t,Lt.e(t.shape,r))),{x:()=>{const r=Object(Ae.a)(t,Object(tt.a)(Object(ur.a)(n,e),t.dtype));return null==o?r:Object(In.a)(r,o)}}}const dr={kernelName:$t.Cb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:o}=r,[c,l]=e,d=T.parseAxisParam(o,c.shape),h=Lt.f(d,c.rank),f=lr(t,l,c,d,h);return{x:()=>{let t=f.x();return null!=h&&(t=Object(In.a)(t)),t}}}};var pr=n(324);const fr={kernelName:$t.Ib,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[a,b]=e;return{a:()=>Object(Ae.a)(t,Object(tt.a)(Object(dn.a)(a,b),"float32")),b:()=>Object(Ae.a)(t,Object(tt.a)(Object(pr.a)(a,b),"float32"))}}};const mr=Object(Rt.a)({maxPool3dBackprop_:function(t,input,output,e,n,r=[1,1,1],o,c){const l=Object(Nt.a)(t,"dy","maxPool3dBackprop"),h=Object(Nt.a)(input,"input","maxPool3dBackprop"),f=Object(Nt.a)(output,"output","maxPool3dBackprop");let m=l,y=h,O=f,x=!1;4===h.rank&&(x=!0,m=Object(Le.a)(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),y=Object(Le.a)(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]]),O=Object(Le.a)(f,[1,f.shape[0],f.shape[1],f.shape[2],f.shape[3]])),T.assert(5===m.rank,(()=>`Error in maxPool3dBackprop: dy must be rank 5 but got rank ${m.rank}.`)),T.assert(5===y.rank,(()=>`Error in maxPool3dBackprop: input must be rank 5 but got rank ${y.rank}.`)),T.assert(5===O.rank,(()=>`Error in maxPool3dBackprop: output must be rank 5 but got rank ${O.rank}.`)),T.assert(Ut.h(n,r),(()=>`Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides ${n} and dilations '${r}'`)),null!=c&&T.assert(T.isInt(o),(()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${c} but got pad ${o}.`));const v={dy:m,input:y,output:O},w={filterSize:e,strides:n,dilations:r,pad:o,dimRoundingMode:c},j=d.a.runKernelFunc((t=>{const l=Ut.f(y.shape,e,n,r,o,c);return t.maxPool3dBackprop(m,y,O,l)}),v,null,$t.Fb,w);return x?Object(Le.a)(j,[j.shape[1],j.shape[2],j.shape[3],j.shape[4]]):j}}),gr={kernelName:$t.Eb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,o]=e,{filterSize:c,strides:l,dilations:d,pad:h,dimRoundingMode:f}=n,m=null==d?[1,1,1]:d;return{x:()=>mr(t,r,o,c,l,m,h,f)}}};const yr=Object(Rt.a)({maxPoolBackprop_:function(t,input,output,e,n,r,o){const c=Object(Nt.a)(t,"dy","maxPoolBackprop"),l=Object(Nt.a)(input,"input","maxPoolBackprop"),h=Object(Nt.a)(output,"output","maxPoolBackprop");T.assert(l.rank===c.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${c.rank})`)),T.assert(4===c.rank,(()=>`Error in maxPoolBackprop: dy must be rank 4 but got rank ${c.rank}.`)),T.assert(4===l.rank,(()=>`Error in maxPoolBackprop: input must be rank 4 but got rank ${l.rank}.`)),null!=o&&T.assert(T.isInt(r),(()=>`Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`));const f={dy:c,input:l,output:h},m={filterSize:e,strides:n,pad:r,dimRoundingMode:o};return d.a.runKernelFunc((t=>{const d=Ut.e(l.shape,e,n,1,r,o);return t.maxPoolBackprop(c,l,h,d)}),f,null,$t.Gb,m)}}),Or={kernelName:$t.Db,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,o]=e,{filterSize:c,strides:l,pad:d}=n;return{x:()=>yr(t,r,o,c,l,d)}}},xr={kernelName:$t.Jb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:o}=r,[c,l]=e,d=T.parseAxisParam(o,c.shape),h=Lt.f(d,c.rank),f=lr(t,l,c,d,h);return{x:()=>{let t=f.x();return null!=h&&(t=Object(In.a)(t)),t}}}};var vr=n(264);const wr={kernelName:$t.Kb,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[a,b]=e;return{a:()=>Object(Ae.a)(t,Object(tt.a)(Object(pn.a)(a,b),"float32")),b:()=>Object(Ae.a)(t,Object(tt.a)(Object(vr.a)(a,b),"float32"))}}};var jr=n(382);const Er={kernelName:$t.Lb,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[a,b]=e,n=Object(Vt.a)(a.shape,b.shape);return{a:()=>{const e=Object(Vt.c)(a.shape,n);return e.length>0?Object(Le.a)(Object(Ve.a)(t,e),a.shape):t},b:()=>{const e=Object(Ae.a)(t,Object(_e.a)(Object(jr.a)(Object(div.a)(a,b)))),r=Object(Vt.c)(b.shape,n);return r.length>0?Object(Le.a)(Object(Ve.a)(e,r),b.shape):e}}}},$r={kernelName:$t.Mb,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[a,b]=e,n=Object(Vt.a)(a.shape,b.shape);return{a:()=>{const e=Object(Ae.a)(t,Object(tt.a)(b,"float32")),r=Object(Vt.c)(a.shape,n);return r.length>0?Object(Le.a)(Object(Ve.a)(e,r),a.shape):e},b:()=>{const e=Object(Ae.a)(t,Object(tt.a)(a,"float32")),r=Object(Vt.c)(b.shape,n);return r.length>0?Object(Le.a)(Object(Ve.a)(e,r),b.shape):e}}}},Cr={kernelName:$t.Nb,gradFunc:t=>({x:()=>Object(_e.a)(t)})},Nr={kernelName:$t.Sb,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>Object(Bt.a)(n.shape,"float32")}}},Rr={kernelName:$t.Tb,gradFunc:t=>({x:()=>Object(We.a)(t)})},Sr={kernelName:$t.Ub,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:o}=n,c=o.map((p=>p[0]));return{x:()=>Object($e.a)(t,c,r.shape)}}};var Tr=n(294),Ir=n(281);const Ar={kernelName:$t.Vb,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[a,b,n]=e,base=a,r=b,o=Vt.a(base.shape,r.shape);return{a:()=>{const e=Object(tt.a)(r,"float32");let n=Object(Ae.a)(t,Object(Ae.a)(e,Object(Ir.a)(base,Object(sub.a)(e,Object(Pt.a)(1)))));const c=Vt.c(base.shape,o);return c.length>0&&(n=Object(Ve.a)(n,c)),Object(Le.a)(n,base.shape)},b:()=>{const e=Object(vr.a)(base,0),c=Object(fn.a)(e,Object(Tr.a)(base),Object(We.a)(base));let l=Object(Ae.a)(t,Object(Ae.a)(n,c));const d=Vt.c(r.shape,o);return d.length>0&&(l=Object(Ve.a)(l,d)),Object(Le.a)(l,r.shape)}}}},kr={kernelName:$t.Wb,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,mask=Object(vr.a)(n,0);return{x:()=>Object(fn.a)(mask,t,Object(Ae.a)(t,r)),alpha:()=>{let e=Object(fn.a)(mask,Object(We.a)(t),Object(Ae.a)(t,n));const o=Object(Vt.c)(r.shape,t.shape);return o.length>0&&(e=Object(Ve.a)(e,o)),Object(Le.a)(e,r.shape)}}}},Dr={kernelName:$t.ac,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(div.a)(t,Object(_e.a)(Object(Pe.a)(n)))}}},_r={kernelName:$t.cc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,mask=Object(Ae.a)(Object(pn.a)(n,6),Object(ke.a)(n));return{x:()=>Object(Ae.a)(t,Object(tt.a)(mask,"float32"))}}},Fr={kernelName:$t.bc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(Ae.a)(t,Object(tt.a)(Object(ke.a)(n),"float32"))}}},Pr={kernelName:$t.dc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(Le.a)(t,n.shape)}}},Mr={kernelName:$t.ec,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,o=e=>{const{alignCorners:o}=n;return e.resizeBilinearBackprop(t,r,o)},c={images:r};return{images:()=>d.a.runKernelFunc(o,c,null,$t.fc,n)}}},Br={kernelName:$t.gc,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,o=e=>{const{alignCorners:o}=n;return e.resizeNearestNeighborBackprop(t,r,o)},c={images:r};return{images:()=>d.a.runKernelFunc(o,c,null,$t.hc,n)}}};var Lr=n(317);const Vr={kernelName:$t.ic,gradFunc:(t,e,n)=>{const{dims:r}=n,o=Object(T.parseAxisParam)(r,t.shape);return{x:()=>Object(Lr.a)(t,o)}}},zr={kernelName:$t.kc,gradFunc:t=>({x:()=>Object(We.a)(t)})},Ur={kernelName:$t.lc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(_e.a)(Object(div.a)(t,Object(Ae.a)(Object(Ir.a)(n,1.5),2)))}}};var Wr=n(325);const Gr={kernelName:$t.nc,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>Object(tt.a)(Object(We.a)(n),"float32"),t:()=>Object(Ae.a)(t,Object(tt.a)(n,t.dtype)),e:()=>Object(Ae.a)(t,Object(tt.a)(Object(Wr.a)(n),t.dtype))}}},Hr={kernelName:$t.oc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const mask=Object(vr.a)(n,Object(Pt.a)(0)),e=Object(Pt.a)(te),r=Object(Pt.a)(ee),o=Object(Ae.a)(t,r),c=Object(Ae.a)(Object(Ae.a)(t,e),Object(Bn.a)(Object(tt.a)(n,"float32")));return Object(fn.a)(mask,o,c)}}}},qr={kernelName:$t.pc,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(Ae.a)(t,Object(Ae.a)(n,Object(sub.a)(Object(Pt.a)(1),n)))}}},Kr={kernelName:$t.qc,gradFunc:t=>({x:()=>Object(We.a)(t)})};var Xr=n(348);const Yr={kernelName:$t.rc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(Ae.a)(Object(Xr.a)(Object(tt.a)(n,"float32")),t)}}};var Qr=n(383);const Jr={kernelName:$t.sc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(Ae.a)(Object(Qr.a)(Object(tt.a)(n,"float32")),t)}}};var Zr=n(349);const ta={kernelName:$t.tc,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{begin:o,size:c}=n,l=r.shape,[d,h]=Object(kt.parseSliceParams)(r,o,c),f=[];for(let i=0;i<t.rank;i++)f.push([d[i],l[i]-d[i]-h[i]]);return{x:()=>Object(Zr.a)(t,f)}}},ea={kernelName:$t.uc,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{dim:o}=n,c=Object(Ae.a)(t,r);return{logits:()=>Object(sub.a)(c,Object(Ae.a)(Object(Ve.a)(c,[o],true),r))}}};var na=n(333);const ra={kernelName:$t.vc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(Ae.a)(t,Object(na.a)(n))}}};var aa=n(326);const sa={kernelName:$t.wc,gradFunc:(t,e,n)=>{const{blockShape:r,paddings:o}=n;return{x:()=>Object(aa.a)(t,r,o)}}};var oa=n(258);const ia={kernelName:$t.yc,gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>Object(oa.a)(t,r)}}},ca={kernelName:$t.zc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(div.a)(t,Object(Ae.a)(Object(Fe.a)(Object(tt.a)(n,"float32")),2))}}},ua={kernelName:$t.Ac,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(Ae.a)(t,Object(Ae.a)(Object(tt.a)(n,"float32"),2))}}},la={kernelName:$t.Bc,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[a,b]=e,n=Object(Pt.a)(2);return{a:()=>Object(Ae.a)(t,Object(Ae.a)(n,Object(sub.a)(a,b))),b:()=>Object(Ae.a)(t,Object(Ae.a)(n,Object(sub.a)(b,a)))}}},da={kernelName:$t.Cc,gradFunc:t=>({x:()=>Object(We.a)(t)})},pa={kernelName:$t.Ec,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[a,b]=e,n=Vt.a(a.shape,b.shape);return{a:()=>{let e=t;const r=Vt.c(a.shape,n);return r.length>0&&(e=Object(Ve.a)(e,r)),Object(Le.a)(e,a.shape)},b:()=>{let e=t;const r=Vt.c(b.shape,n);return r.length>0&&(e=Object(Ve.a)(e,r)),Object(Le.a)(Object(_e.a)(e),b.shape)}}}};var ha=n(292);const fa={kernelName:$t.Fc,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,o=r.shape.slice(),{axis:c}=n;Object(T.parseAxisParam)(c,r.shape).forEach((t=>{o[t]=1}));const l=Object(Le.a)(t,o),d=Object(Ae.a)(l,Object(ha.a)(r.shape,"float32"));return{x:()=>d}}},ma={kernelName:$t.Gc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(div.a)(t,Object(Pe.a)(Object(Xr.a)(n)))}}},ba={kernelName:$t.Hc,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Object(Ae.a)(Object(sub.a)(Object(Pt.a)(1),Object(Pe.a)(n)),t)}}},ga={kernelName:$t.Ic,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:o}=n;return{x:()=>{let e=Object(We.a)(r);if(1===r.rank)for(let i=0;i<o[0];++i)e=Object(Ke.a)(e,Object($e.a)(t,[i*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let i=0;i<o[0];++i)for(let n=0;n<o[1];++n)e=Object(Ke.a)(e,Object($e.a)(t,[i*r.shape[0],n*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let i=0;i<o[0];++i)for(let n=0;n<o[1];++n)for(let c=0;c<o[2];++c)e=Object(Ke.a)(e,Object($e.a)(t,[i*r.shape[0],n*r.shape[1],c*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let i=0;i<o[0];++i)for(let n=0;n<o[1];++n)for(let c=0;c<o[2];++c)for(let l=0;l<o[3];++l)e=Object(Ke.a)(e,Object($e.a)(t,[i*r.shape[0],n*r.shape[1],c*r.shape[2],l*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return e}}}},ya={kernelName:$t.Kc,gradFunc:(t,e,n)=>{const r=n,{perm:o}=r,c=Lt.h(o);return{x:()=>Object(In.a)(t,c)}}};var Oa=n(279);const xa={kernelName:$t.Mc,gradFunc:(t,e,n)=>{const r=n,{axis:o}=r;return{value:()=>Object(Oa.a)(t,o)}}};var va=n(289),wa=n(350),ja=n(298);const Ea=[De,Me,Be,ze,Ue,Ge,He,qe,Xe,Ye,Qe,Je,tn,nn,an,on,cn,un,ln,mn,gn,wn,xn,$n,Nn,Sn,An,_n,Fn,Pn,Mn,Ln,Vn,zn,Wn,Un,qn,Xn,Jn,Zn,er,nr,rr,ar,sr,or,cr,dr,dr,fr,gr,Or,xr,wr,Er,$r,Cr,Nr,Rr,Sr,Sr,Ar,kr,Dr,_r,Fr,Pr,Mr,Br,Vr,zr,Ur,Gr,Hr,qr,Kr,Yr,Jr,ta,ea,ra,sa,sa,ia,ia,ca,la,ua,da,pa,fa,ma,ba,ga,ya,xa,{kernelName:$t.Nc,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=Object(ja.a)(e,Object(We.a)(e)),r=Object(wa.a)(t,n);let o=Object(dn.a)(e,Object(Pt.a)(0,"int32"));const c=r.rank-o.rank;for(let i=0;i<c;++i)o=Object(va.a)(o,i+1);o=Object(hn.a)(o,Object(ha.a)(r.shape,"bool"));const l=Object(We.a)(r);return Object(fn.a)(o,r,l)}(t,n)}}},{kernelName:$t.Oc,gradFunc:t=>({x:()=>Object(We.a)(t)})}];for(const t of Ea)Object(Ct.d)(t);var $a=n(291);at.a.prototype.abs=function(){return this.throwIfDisposed(),Object($a.a)(this)};var Ca=n(421);at.a.prototype.acos=function(){return this.throwIfDisposed(),Object(Ca.a)(this)};var Na=n(422);at.a.prototype.acosh=function(){return this.throwIfDisposed(),Object(Na.a)(this)};var Ra=n(423);at.a.prototype.addStrict=function(t){return this.throwIfDisposed(),Object(Ra.a)(this,t)},at.a.prototype.add=function(b){return this.throwIfDisposed(),Object(Ke.a)(this,b)};var Sa=n(384);at.a.prototype.all=function(t,e){return this.throwIfDisposed(),Object(Sa.a)(this,t,e)};var Ta=n(385);at.a.prototype.any=function(t,e){return this.throwIfDisposed(),Object(Ta.a)(this,t,e)};var Ia=n(386);at.a.prototype.argMax=function(t){return this.throwIfDisposed(),Object(Ia.a)(this,t)};var Aa=n(387);at.a.prototype.argMin=function(t){return this.throwIfDisposed(),Object(Aa.a)(this,t)},at.a.prototype.asScalar=function(){return this.throwIfDisposed(),Object(T.assert)(1===this.size,(()=>"The array must have only 1 element.")),Object(Le.a)(this,[])},at.a.prototype.asType=function(t){return this.throwIfDisposed(),Object(tt.a)(this,t)},at.a.prototype.as1D=function(){return this.throwIfDisposed(),Object(Le.a)(this,[this.size])},at.a.prototype.as2D=function(t,e){return this.throwIfDisposed(),Object(Le.a)(this,[t,e])},at.a.prototype.as3D=function(t,e,n){return this.throwIfDisposed(),Object(Le.a)(this,[t,e,n])},at.a.prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),Object(Le.a)(this,[t,e,n,r])},at.a.prototype.as5D=function(t,e,n,r,o){return this.throwIfDisposed(),Object(Le.a)(this,[t,e,n,r,o])};var ka=n(424);at.a.prototype.asin=function(){return this.throwIfDisposed(),Object(ka.a)(this)};var Da=n(425);at.a.prototype.asinh=function(){return this.throwIfDisposed(),Object(Da.a)(this)};var _a=n(426);at.a.prototype.atan=function(){return this.throwIfDisposed(),Object(_a.a)(this)};var Fa=n(388);at.a.prototype.atan2=function(b){return this.throwIfDisposed(),Object(Fa.a)(this,b)};var Pa=n(427);at.a.prototype.atanh=function(){return this.throwIfDisposed(),Object(Pa.a)(this)};var Ma=n(352);at.a.prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),Object(Ma.a)(this,t,e,n,r)},at.a.prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),Object(aa.a)(this,t,e)};var Ba=n(411);at.a.prototype.batchNorm=function(t,e,n,r,o){return this.throwIfDisposed(),Object(Ba.a)(this,t,e,n,r,o)};var La=n(337);at.a.prototype.broadcastTo=function(t){return this.throwIfDisposed(),Object(La.a)(this,t)},at.a.prototype.cast=function(t){return this.throwIfDisposed(),Object(tt.a)(this,t)};var Va=n(428);at.a.prototype.ceil=function(){return this.throwIfDisposed(),Object(Va.a)(this)};var za=n(429);at.a.prototype.clipByValue=function(t,e){return this.throwIfDisposed(),Object(za.a)(this,t,e)},at.a.prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof at.a&&(t=[t]),Object(oa.a)([this,...t],e)};var Ua=n(389);at.a.prototype.conv1d=function(filter,t,e,n,r,o){return this.throwIfDisposed(),Object(Ua.a)(this,filter,t,e,n,r,o)};var Wa=n(390);at.a.prototype.conv2dTranspose=function(filter,t,e,n,r){return this.throwIfDisposed(),Object(Wa.a)(this,filter,t,e,n,r)},at.a.prototype.conv2d=function(filter,t,e,n,r,o){return this.throwIfDisposed(),Object(vn.a)(this,filter,t,e,n,r,o)},at.a.prototype.cos=function(){return this.throwIfDisposed(),Object(Xr.a)(this)},at.a.prototype.cosh=function(){return this.throwIfDisposed(),Object(Qr.a)(this)},at.a.prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),Object(Tn.a)(this,t,e,n)};var Ga=n(391);at.a.prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),Object(Ga.a)(this,t,e)};var Ha=n(296);at.a.prototype.depthwiseConv2D=function(filter,t,e,n,r,o){return Object(Ft.a)("depthwiseConv2D is deprecated, use depthwiseConv2d instead"),this.throwIfDisposed(),Object(Ha.a)(this,filter,t,e,n,r,o)},at.a.prototype.depthwiseConv2d=function(filter,t,e,n,r,o){return this.throwIfDisposed(),Object(Ha.a)(this,filter,t,e,n,r,o)};var qa=n(392);at.a.prototype.dilation2d=function(filter,t,e,n,r){return this.throwIfDisposed(),Object(qa.a)(this,filter,t,e,n,r)};var Ka=n(393);at.a.prototype.divNoNan=function(b){return this.throwIfDisposed(),Object(Ka.a)(this,b)},at.a.prototype.divStrict=function(t){return this.throwIfDisposed(),Object(Ra.b)(this,t)},at.a.prototype.div=function(b){return this.throwIfDisposed(),Object(div.a)(this,b)};var Xa=n(394);at.a.prototype.dot=function(b){return this.throwIfDisposed(),Object(Xa.a)(this,b)};var Ya=n(343);at.a.prototype.elu=function(){return this.throwIfDisposed(),Object(Ya.a)(this)};var Qa=n(430);at.a.prototype.equalStrict=function(t){return this.throwIfDisposed(),Object(Qa.a)(this,t)},at.a.prototype.equal=function(b){return this.throwIfDisposed(),Object(ur.a)(this,b)};var Ja=n(431);at.a.prototype.erf=function(){return this.throwIfDisposed(),Object(Ja.a)(this)},at.a.prototype.exp=function(){return this.throwIfDisposed(),Object(Bn.a)(this)},at.a.prototype.expandDims=function(t){return this.throwIfDisposed(),Object(va.a)(this,t)};var Za=n(432);at.a.prototype.expm1=function(){return this.throwIfDisposed(),Object(Za.a)(this)};var ts=n(334);at.a.prototype.fft=function(){return this.throwIfDisposed(),Object(ts.a)(this)},at.a.prototype.flatten=function(){return this.throwIfDisposed(),Object(Le.a)(this,[this.size])},at.a.prototype.floor=function(){return this.throwIfDisposed(),Object(jr.a)(this)};var es=n(332);at.a.prototype.floorDiv=function(b){return this.throwIfDisposed(),Object(es.a)(this,b)},at.a.prototype.gather=function(t,e){return this.throwIfDisposed(),Object(wa.a)(this,t,e)},at.a.prototype.greaterEqualStrict=function(t){return this.throwIfDisposed(),Object(Qa.b)(this,t)},at.a.prototype.greaterEqual=function(b){return this.throwIfDisposed(),Object(dn.a)(this,b)},at.a.prototype.greaterStrict=function(t){return this.throwIfDisposed(),Object(Qa.c)(this,t)},at.a.prototype.greater=function(b){return this.throwIfDisposed(),Object(vr.a)(this,b)};var ns=n(335);at.a.prototype.ifft=function(){return this.throwIfDisposed(),Object(ns.a)(this)};var rs=n(370);at.a.prototype.irfft=function(){return this.throwIfDisposed(),Object(rs.a)(this)};var as=n(433);at.a.prototype.isFinite=function(){return this.throwIfDisposed(),Object(as.a)(this)};var ss=n(434);at.a.prototype.isInf=function(){return this.throwIfDisposed(),Object(ss.a)(this)};var os=n(435);at.a.prototype.isNaN=function(){return this.throwIfDisposed(),Object(os.a)(this)};var is=n(395);at.a.prototype.leakyRelu=function(t){return this.throwIfDisposed(),Object(is.a)(this,t)},at.a.prototype.lessEqualStrict=function(t){return this.throwIfDisposed(),Object(Qa.d)(this,t)},at.a.prototype.lessEqual=function(b){return this.throwIfDisposed(),Object(pn.a)(this,b)},at.a.prototype.lessStrict=function(t){return this.throwIfDisposed(),Object(Qa.e)(this,t)},at.a.prototype.less=function(b){return this.throwIfDisposed(),Object(pr.a)(this,b)};var cs=n(396);at.a.prototype.localResponseNormalization=function(t,e,n,r){return this.throwIfDisposed(),Object(cs.a)(this,t,e,n,r)};var us=n(436);at.a.prototype.logSigmoid=function(){return this.throwIfDisposed(),Object(us.a)(this)};var ls=n(437);at.a.prototype.logSoftmax=function(t){return this.throwIfDisposed(),Object(ls.a)(this,t)};var ds=n(342);at.a.prototype.logSumExp=function(t,e){return this.throwIfDisposed(),Object(ds.a)(this,t,e)},at.a.prototype.log=function(){return this.throwIfDisposed(),Object(Tr.a)(this)};var ps=n(372);at.a.prototype.log1p=function(){return this.throwIfDisposed(),Object(ps.a)(this)},at.a.prototype.logicalAnd=function(b){return this.throwIfDisposed(),Object(hn.a)(this,b)},at.a.prototype.logicalNot=function(){return this.throwIfDisposed(),Object(Wr.a)(this)};var hs=n(353);at.a.prototype.logicalOr=function(b){return this.throwIfDisposed(),Object(hs.a)(this,b)};var fs=n(398);at.a.prototype.logicalXor=function(b){return this.throwIfDisposed(),Object(fs.a)(this,b)},at.a.prototype.matMul=function(b,t,e){return this.throwIfDisposed(),Object(rn.a)(this,b,t,e)};var ms=n(354);at.a.prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),Object(ms.a)(this,t,e,n,r)};var bs=n(287);at.a.prototype.max=function(t,e){return this.throwIfDisposed(),Object(bs.a)(this,t,e)},at.a.prototype.maximumStrict=function(t){return this.throwIfDisposed(),Object(Ra.c)(this,t)},at.a.prototype.maximum=function(b){return this.throwIfDisposed(),Object(ja.a)(this,b)};var gs=n(341);at.a.prototype.mean=function(t,e){return this.throwIfDisposed(),Object(gs.a)(this,t,e)};var ys=n(340);at.a.prototype.min=function(t,e){return this.throwIfDisposed(),Object(ys.a)(this,t,e)},at.a.prototype.minimumStrict=function(t){return this.throwIfDisposed(),Object(Ra.d)(this,t)};var Os=n(320);at.a.prototype.minimum=function(b){return this.throwIfDisposed(),Object(Os.a)(this,b)},at.a.prototype.modStrict=function(t){return this.throwIfDisposed(),Object(Ra.e)(this,t)};var xs=n(351);at.a.prototype.mod=function(b){return this.throwIfDisposed(),Object(xs.a)(this,b)},at.a.prototype.mulStrict=function(t){return this.throwIfDisposed(),Object(Ra.f)(this,t)},at.a.prototype.mul=function(b){return this.throwIfDisposed(),Object(Ae.a)(this,b)},at.a.prototype.neg=function(){return this.throwIfDisposed(),Object(_e.a)(this)};var vs=n(339);at.a.prototype.norm=function(t,e,n){return this.throwIfDisposed(),Object(vs.a)(this,t,e,n)},at.a.prototype.notEqualStrict=function(t){return this.throwIfDisposed(),Object(Qa.f)(this,t)};var ws=n(319);at.a.prototype.notEqual=function(b){return this.throwIfDisposed(),Object(ws.a)(this,b)};var js=n(399);at.a.prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),Object(js.a)(this,t,e,n)};var Es=n(438);at.a.prototype.onesLike=function(){return this.throwIfDisposed(),Object(Es.a)(this)},at.a.prototype.pad=function(t,e){return this.throwIfDisposed(),Object(Zr.a)(this,t,e)};var $s=n(400);at.a.prototype.pool=function(t,e,n,r,o){return this.throwIfDisposed(),Object($s.a)(this,t,e,n,r,o)},at.a.prototype.powStrict=function(t){return this.throwIfDisposed(),Object(Ra.g)(this,t)},at.a.prototype.pow=function(t){return this.throwIfDisposed(),Object(Ir.a)(this,t)};var Cs=n(345);at.a.prototype.prelu=function(t){return this.throwIfDisposed(),Object(Cs.a)(this,t)};var Ns=n(401);at.a.prototype.prod=function(t,e){return this.throwIfDisposed(),Object(Ns.a)(this,t,e)};var Rs=n(439);at.a.prototype.reciprocal=function(){return this.throwIfDisposed(),Object(Rs.a)(this)};var Ss=n(293);at.a.prototype.relu=function(){return this.throwIfDisposed(),Object(Ss.a)(this)};var Ts=n(344);at.a.prototype.relu6=function(){return this.throwIfDisposed(),Object(Ts.a)(this)},at.a.prototype.reshapeAs=function(t){return this.throwIfDisposed(),Object(Le.a)(this,t.shape)},at.a.prototype.reshape=function(t){return this.throwIfDisposed(),Object(Le.a)(this,t)};var Is=n(418);at.a.prototype.resizeBilinear=function(t,e){return this.throwIfDisposed(),Object(Is.a)(this,t,e)};var As=n(417);at.a.prototype.resizeNearestNeighbor=function(t,e){return this.throwIfDisposed(),Object(As.a)(this,t,e)},at.a.prototype.reverse=function(t){return this.throwIfDisposed(),Object(Lr.a)(this,t)};var ks=n(336);at.a.prototype.rfft=function(){return this.throwIfDisposed(),Object(ks.a)(this)};var Ds=n(440);at.a.prototype.round=function(){return this.throwIfDisposed(),Object(Ds.a)(this)},at.a.prototype.rsqrt=function(){return this.throwIfDisposed(),Object(Gn.a)(this)};var _s=n(402);at.a.prototype.selu=function(){return this.throwIfDisposed(),Object(_s.a)(this)};var Fs=n(403);at.a.prototype.separableConv2d=function(t,e,n,r,o,c){return this.throwIfDisposed(),Object(Fs.a)(this,t,e,n,r,o,c)},at.a.prototype.sigmoid=function(){return this.throwIfDisposed(),Object(na.a)(this)};var Ps=n(441);at.a.prototype.sign=function(){return this.throwIfDisposed(),Object(Ps.a)(this)},at.a.prototype.sin=function(){return this.throwIfDisposed(),Object(Cn.a)(this)},at.a.prototype.sinh=function(){return this.throwIfDisposed(),Object(Rn.a)(this)},at.a.prototype.slice=function(t,e){return this.throwIfDisposed(),Object($e.a)(this,t,e)};var Ms=n(416);at.a.prototype.softmax=function(t){return this.throwIfDisposed(),Object(Ms.a)(this,t)};var Bs=n(397);at.a.prototype.softplus=function(){return this.throwIfDisposed(),Object(Bs.a)(this)},at.a.prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),Object(sn.a)(this,t,e)},at.a.prototype.split=function(t,e){return this.throwIfDisposed(),Object(bn.a)(this,t,e)},at.a.prototype.sqrt=function(){return this.throwIfDisposed(),Object(Fe.a)(this)},at.a.prototype.square=function(){return this.throwIfDisposed(),Object(Pe.a)(this)};var Ls=n(321);at.a.prototype.squaredDifference=function(b){return this.throwIfDisposed(),Object(Ls.a)(this,b)},at.a.prototype.squaredDifferenceStrict=function(t){return this.throwIfDisposed(),Object(Ra.h)(this,t)};var Vs=n(338);at.a.prototype.squeeze=function(t){return this.throwIfDisposed(),Object(Vs.a)(this,t)},at.a.prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof at.a?[this,t]:[this,...t];return Object(Oa.a)(n,e)},at.a.prototype.step=function(t){return this.throwIfDisposed(),Object(ke.a)(this,t)};var zs=n(442);at.a.prototype.stridedSlice=function(t,e,n,r,o,c,l,d){return this.throwIfDisposed(),Object(zs.a)(this,t,e,n,r,o,c,l,d)},at.a.prototype.subStrict=function(t){return this.throwIfDisposed(),Object(Ra.i)(this,t)},at.a.prototype.sub=function(b){return this.throwIfDisposed(),Object(sub.a)(this,b)},at.a.prototype.sum=function(t,e){return this.throwIfDisposed(),Object(Ve.a)(this,t,e)};var Us=n(443);at.a.prototype.tan=function(){return this.throwIfDisposed(),Object(Us.a)(this)};var Ws=n(444);at.a.prototype.tanh=function(){return this.throwIfDisposed(),Object(Ws.a)(this)},at.a.prototype.tile=function(t){return this.throwIfDisposed(),Object(Hn.a)(this,t)},at.a.prototype.toBool=function(){return this.throwIfDisposed(),Object(tt.a)(this,"bool")},at.a.prototype.toFloat=function(){return this.throwIfDisposed(),Object(tt.a)(this,"float32")},at.a.prototype.toInt=function(){return this.throwIfDisposed(),Object(tt.a)(this,"int32")};var Gs=n(404);at.a.prototype.topk=function(t,e){return this.throwIfDisposed(),Object(Gs.a)(this,t,e)},at.a.prototype.transpose=function(t){return this.throwIfDisposed(),Object(In.a)(this,t)};var Hs=n(405);at.a.prototype.unique=function(t){return this.throwIfDisposed(),Object(Hs.a)(this,t)},at.a.prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),Object(Kn.a)(this,t,e)};var qs=n(316);at.a.prototype.unstack=function(t){return this.throwIfDisposed(),Object(qs.a)(this,t)},at.a.prototype.where=function(t,e){return this.throwIfDisposed(),Object(fn.a)(t,this,e)},at.a.prototype.zerosLike=function(){return this.throwIfDisposed(),Object(We.a)(this)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221);const h=Object(d.a)({reshape_:function(t,e){const n=Object(c.a)(t,"x","reshape",null),d={x:n},h={shape:e};return r.a.runKernelFunc(((t,r)=>(e=l.inferFromImplicitShape(e,n.size),l.assert(n.size===l.sizeFromShape(e),(()=>"new shape and old shape must have the same number of elements.")),r([n]),t.reshape(n,e))),d,null,o.dc,h)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return o.a})),n.d(e,"b",(function(){return c.a})),n.d(e,"c",(function(){return l.a})),n.d(e,"d",(function(){return d.a})),n.d(e,"e",(function(){return h.a})),n.d(e,"f",(function(){return m})),n.d(e,"g",(function(){return div.a})),n.d(e,"i",(function(){return y.a})),n.d(e,"k",(function(){return O.a})),n.d(e,"l",(function(){return x.a})),n.d(e,"m",(function(){return v.a})),n.d(e,"n",(function(){return w.a})),n.d(e,"o",(function(){return j.a})),n.d(e,"p",(function(){return E.a})),n.d(e,"q",(function(){return $.a})),n.d(e,"r",(function(){return C.a})),n.d(e,"s",(function(){return N.a})),n.d(e,"t",(function(){return R.a})),n.d(e,"u",(function(){return sub.a})),n.d(e,"v",(function(){return S.a})),n.d(e,"w",(function(){return T.a})),n.d(e,"x",(function(){return D})),n.d(e,"z",(function(){return _.a})),n.d(e,"A",(function(){return F.a})),n.d(e,"y",(function(){return P.a})),n.d(e,"j",(function(){return ne})),n.d(e,"h",(function(){return r}));var r={};n.r(r),n.d(r,"conv2d",(function(){return Z})),n.d(r,"depthwiseConv2d",(function(){return at})),n.d(r,"matMul",(function(){return ot}));var o=n(245),c=n(268),l=n(286),d=n(267),h=n(258),f=n(221);const m=Object(f.a)({concat2d_:function(t,e){return Object(h.a)(t,e)}});var div=n(235),y=n(314),O=n(287),x=n(229),v=n(368),w=n(315),j=n(227),E=n(232),$=n(333),C=n(259),N=n(416),R=n(279),sub=n(233),S=n(312),T=n(288),I=n(222),A=n(225),k=n(313);function D(t,e,n){if(Object(A.assertNonNull)(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Object(I.c)(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Object(k.a)(t,e,r,n)}var _=n(316),F=n(269),P=n(241),M=n(336),B=n(334),L=n(335),V=n(370),z=n(224),U=n(253),W=n(220),G=n(234),H=n(231),K=n(284),X=n(374),Y=n(373),Q=n(237),J=n(283);const Z=Object(f.a)({fusedConv2d_:function({x:t,filter:filter,strides:e,pad:n,dataFormat:r="NHWC",dilations:c=[1,1],dimRoundingMode:l,bias:d,activation:h="linear",preluActivationWeights:f}){if(h=h||"linear",!1===Object(J.d)(z.a.state.gradientDepth,h)){let m=Object(K.a)(t,filter,e,n,r,c,l);return null!=d&&(m=Object(o.a)(m,d)),Object(J.a)(m,h,f)}const m=Object(I.a)(t,"x","conv2d"),y=Object(I.a)(filter,"filter","conv2d");let O=m,x=!1;3===m.rank&&(x=!0,O=Object(j.a)(m,[1,m.shape[0],m.shape[1],m.shape[2]])),A.assert(4===O.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${O.rank}.`)),A.assert(4===y.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${y.rank}.`)),null!=l&&A.assert(A.isInt(n),(()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${l} but got pad ${n}.`)),A.assert(O.shape[3]===y.shape[2],(()=>`Error in conv2d: depth of input (${O.shape[3]}) must match input depth for filter ${y.shape[2]}.`)),A.assert(Q.h(e,c),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${c}'`)),A.assert("NHWC"===r,(()=>`Error in conv2d: got dataFormat of ${r} but only NHWC is currently supported.`));const v=Q.a(O.shape,y.shape,e,c,n,l);let w,E;null!=d&&(w=Object(I.a)(d,"bias","fused conv2d"),[w]=Object(G.b)(w,m),H.a(v.outShape,w.shape)),null!=f&&(E=Object(I.a)(f,"prelu weights","fused conv2d"));const $=(t,r)=>{const[o,l,d,f]=r,m=Object(J.c)(t,d,h);A.assert(Q.i(c),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${c}'`));const y=[Object(Y.a)(l.shape,m,o,e,n),Object(X.a)(l,m,o.shape,e,n)];if(null!=f){const t=Object(J.b)(f,m);y.push(t)}return y},C=t=>t.fusedConv2d({input:O,filter:y,convInfo:v,bias:w,activation:h,preluActivationWeights:E}),N={x:O,filter:y,bias:w,preluActivationWeights:E},R={strides:e,pad:n,dataFormat:r,dilations:c,dimRoundingMode:l,activation:h};if(null==d){const t=Object(U.a)(((t,filter,e)=>{let n=z.a.runKernelFunc(C,N,null,W.fb,R);return e([filter,t,n]),x&&(n=Object(j.a)(n,[n.shape[1],n.shape[2],n.shape[3]])),{value:n,gradFunc:$}}));return t(O,y)}{const t=Object(U.a)(((t,filter,e,n)=>{let r=z.a.runKernelFunc(C,N,null,W.fb,R);return n([filter,t,r,e]),x&&(r=Object(j.a)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:$}}));return t(O,y,w)}}});var tt=n(296),et=n(420),nt=n(419);const at=Object(f.a)({fusedDepthwiseConv2d_:function({x:t,filter:filter,strides:e,pad:n,dataFormat:r="NHWC",dilations:c=[1,1],dimRoundingMode:l,bias:d,activation:h="linear",preluActivationWeights:f}){if(!1===Object(J.d)(z.a.state.gradientDepth,h)){let m=Object(tt.a)(t,filter,e,n,r,c,l);return null!=d&&(m=Object(o.a)(m,d)),Object(J.a)(m,h,f)}const m=Object(I.a)(t,"x","depthwiseConv2d"),y=Object(I.a)(filter,"filter","depthwiseConv2d");let O=m,x=!1;3===m.rank&&(x=!0,O=Object(j.a)(m,[1,m.shape[0],m.shape[1],m.shape[2]])),A.assert(4===O.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${O.rank}.`)),A.assert(4===y.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${y.rank}.`)),A.assert(O.shape[3]===y.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${O.shape[3]}) must match the inChannels dimension in filter ${y.shape[2]}.`)),null==c&&(c=[1,1]),A.assert(Q.h(e,c),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${c}'`)),null!=l&&A.assert(A.isInt(n),(()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${l} but got pad ${n}.`));const v=Q.a(O.shape,y.shape,e,c,n,l,!0);let w,E;null!=d&&(w=Object(I.a)(d,"bias","fused conv2d"),[w]=Object(G.b)(w,m),H.a(v.outShape,w.shape)),null!=f&&(E=Object(I.a)(f,"prelu weights","fused depthwiseConv2d"));const $=(t,e)=>{A.assert(Q.i(c),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${c}'`));const[n,r,o,l]=e,d=Object(J.c)(t,o,h),f=Object(nt.a)(r.shape,d,n,v),m=Object(et.a)(r,d,n.shape,v);if(null!=l){return[f,m,Object(J.b)(w,d)]}return[f,m]},C=t=>t.fusedDepthwiseConv2D({input:O,filter:y,convInfo:v,bias:w,activation:h,preluActivationWeights:E}),N={x:O,filter:y,bias:w,preluActivationWeights:E},R={strides:e,pad:n,dataFormat:r,dilations:c,dimRoundingMode:l,activation:h};if(null==d){const t=Object(U.a)(((t,filter,e)=>{let n=z.a.runKernelFunc(C,N,null,W.gb,R);return e([filter,t,n]),x&&(n=Object(j.a)(n,[n.shape[1],n.shape[2],n.shape[3]])),{value:n,gradFunc:$}}));return t(O,y)}{const t=Object(U.a)(((t,filter,e,n)=>{let r=z.a.runKernelFunc(C,N,null,W.gb,R);return n([filter,t,r,e]),x&&(r=Object(j.a)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:$}}));return t(O,y,w)}}});var st=n(282);const ot=Object(f.a)({fusedMatMul_:function({a:a,b:b,transposeA:t=!1,transposeB:e=!1,bias:n,activation:r="linear",preluActivationWeights:c}){if(!1===Object(J.d)(z.a.state.gradientDepth,r)){let l=Object(st.a)(a,b,t,e);return null!=n&&(l=Object(o.a)(l,n)),Object(J.a)(l,r,c)}let l=Object(I.a)(a,"a","fused matMul"),d=Object(I.a)(b,"b","fused matMul");[l,d]=Object(G.b)(l,d);const h=t?l.shape[l.rank-2]:l.shape[l.rank-1],f=e?d.shape[d.rank-1]:d.shape[d.rank-2],m=t?l.shape[l.rank-1]:l.shape[l.rank-2],y=e?d.shape[d.rank-2]:d.shape[d.rank-1],O=l.shape.slice(0,-2),x=d.shape.slice(0,-2),v=A.sizeFromShape(O),w=A.sizeFromShape(x);A.assert(l.rank>=2&&d.rank>=2&&l.rank===d.rank,(()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${l.rank} and ${d.rank}.`)),A.assert(A.arraysEqual(O,x),(()=>`Error in fused matMul: outer dimensions (${O}) and (${x}) of Tensors with shapes ${l.shape} and ${d.shape} must match.`)),A.assert(h===f,(()=>`Error in fused matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${l.shape} and ${d.shape} and transposeA=${t} and transposeB=${e} must match.`));const E=l.shape.slice(0,-2).concat([m,y]),$=t?Object(j.a)(l,[v,h,m]):Object(j.a)(l,[v,m,h]),C=e?Object(j.a)(d,[w,y,f]):Object(j.a)(d,[w,f,y]);let N,R;null!=n&&(N=Object(I.a)(n,"bias","fused matMul"),[N]=Object(G.b)(N,l),H.a(E,N.shape)),null!=c&&(R=Object(I.a)(c,"prelu weights","fused matMul"));const S=(o,c)=>{const[l,d,h,f]=c,m=Object(J.c)(Object(j.a)(o,h.shape),h,r);let y,O;if(t||e?!t&&e?(y=Object(st.a)(m,d,!1,!1),O=Object(st.a)(m,l,!0,!1)):t&&!e?(y=Object(st.a)(d,m,!1,!0),O=Object(st.a)(l,m,!1,!1)):(y=Object(st.a)(d,m,!0,!0),O=Object(st.a)(m,l,!0,!0)):(y=Object(st.a)(m,d,!1,!0),O=Object(st.a)(l,m,!0,!1)),null!=n){return[y,O,Object(J.b)(f,m)]}return[y,O]},T=n=>n.fusedBatchMatMul({a:$,b:C,transposeA:t,transposeB:e,bias:N,activation:r,preluActivationWeights:R}),k={a:$,b:C,bias:N,preluActivationWeights:R},D={transposeA:t,transposeB:e,activation:r};if(null==n){const t=Object(U.a)(((t,e,n)=>{const r=z.a.runKernelFunc(T,k,null,W.Pc,D);return n([t,e,r]),{value:Object(j.a)(r,E),gradFunc:S}}));return t($,C)}{const t=Object(U.a)(((t,e,n,r)=>{const o=z.a.runKernelFunc(T,k,null,W.Pc,D);return r([t,e,o,n]),{value:Object(j.a)(o,E),gradFunc:S}}));return t($,C,N)}}});function it(t,a,b){const e=1-t%2,n=new Float32Array(t);for(let i=0;i<t;++i){const r=2*Math.PI*i/(t+e-1);n[i]=a-b*Math.cos(r)}return Object(T.a)(n,"float32")}Object(f.a)({hammingWindow_:function(t){return it(t,.54,.46)}});const ct=Object(f.a)({hannWindow_:function(t){return it(t,.5,.5)}});var ut=n(371);const lt=Object(f.a)({frame_:function(t,e,n,r=!1,o=0){let c=0;const output=[];for(;c+e<=t.size;)output.push(Object(C.a)(t,c,e)),c+=n;if(r)for(;c<t.size;){const r=c+e-t.size,l=Object(h.a)([Object(C.a)(t,c,e-r),Object(ut.a)([r],o)]);output.push(l),c+=n}return 0===output.length?D([],[0,e]):Object(j.a)(Object(h.a)(output),[output.length,e])}});Object(f.a)({stft_:function(t,e,n,r,o=ct){var c;null==r&&(c=e,r=Math.floor(Math.pow(2,Math.ceil(Math.log(c)/Math.log(2)))));const l=lt(t,e,n),d=Object(x.a)(l,o(e)),output=[];for(let i=0;i<l.shape[0];i++)output.push(Object(M.a)(Object(C.a)(d,[i,0],[1,e]),r));return Object(h.a)(output)}});const pt=Object(f.a)({cropAndResize_:function(image,t,e,n,r,o){const c=Object(I.a)(image,"image","cropAndResize"),l=Object(I.a)(t,"boxes","cropAndResize","float32"),d=Object(I.a)(e,"boxInd","cropAndResize","int32");r=r||"bilinear",o=o||0;const h=l.shape[0];A.assert(4===c.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${c.rank}.`)),A.assert(2===l.rank&&4===l.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${h},4] but had shape ${l.shape}.`)),A.assert(1===d.rank&&d.shape[0]===h,(()=>`Error in cropAndResize: boxInd must be have size [${h}] but had shape ${l.shape}.`)),A.assert(2===n.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`)),A.assert(n[0]>=1&&n[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${n}`)),A.assert("bilinear"===r||"nearest"===r,(()=>`method must be bilinear or nearest, but was ${r}`));const f={image:c,boxes:l,boxInd:d},m={method:r,extrapolationValue:o,cropSize:n};return z.a.runKernelFunc((t=>t.cropAndResize(c,l,d,n,r,o)),f,null,W.I,m)}});const ht=Object(f.a)({flipLeftRight_:function(image){const t=Object(I.a)(image,"image","flipLeftRight","float32");A.assert(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const e={image:t};return z.a.runKernel(W.ab,e,{})}});const ft=Object(f.a)({rotateWithOffset_:function(image,t,e=0,n=.5){const r=Object(I.a)(image,"image","rotateWithOffset","float32");A.assert(4===r.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`));const o={image:r},c={radians:t,fillValue:e,center:n};return z.a.runKernel(W.jc,o,c)}});function mt(t,e,n,r,o,c){null==r&&(r=.5),null==o&&(o=Number.NEGATIVE_INFINITY),null==c&&(c=0);const l=t.shape[0];return n=Math.min(n,l),A.assert(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),A.assert(2===t.rank,(()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`)),A.assert(4===t.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`)),A.assert(1===e.rank,(()=>"scores must be a 1D tensor")),A.assert(e.shape[0]===l,(()=>`scores has incompatible shape with boxes. Expected ${l}, but was ${e.shape[0]}`)),A.assert(0<=c&&c<=1,(()=>`softNmsSigma must be in [0, 1], but was '${c}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:o,softNmsSigma:c}}const bt=Object(f.a)({nonMaxSuppression_:function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY){const c=Object(I.a)(t,"boxes","nonMaxSuppression"),l=Object(I.a)(e,"scores","nonMaxSuppression"),d=mt(c,l,n,r,o);n=d.maxOutputSize,r=d.iouThreshold,o=d.scoreThreshold;const h={maxOutputSize:n,iouThreshold:r,scoreThreshold:o};return z.a.runKernelFunc((b=>b.nonMaxSuppression(c,l,n,r,o)),{boxes:c,scores:l},null,W.Ob,h)}});var gt=n(285);const yt=async function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY){const c=Object(I.a)(t,"boxes","nonMaxSuppressionAsync"),l=Object(I.a)(e,"scores","nonMaxSuppressionAsync"),d=mt(c,l,n,r,o);n=d.maxOutputSize,r=d.iouThreshold,o=d.scoreThreshold;const h=await Promise.all([c.data(),l.data()]),f=h[0],m=h[1],y=Object(gt.a)(f,m,n,r,o);return c!==t&&c.dispose(),l!==e&&l.dispose(),y};const Ot=Object(f.a)({nonMaxSuppressionWithScore_:function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY,c=0){const l=Object(I.a)(t,"boxes","nonMaxSuppression"),d=Object(I.a)(e,"scores","nonMaxSuppression"),h=mt(l,d,n,r,o,c),f={boxes:l,scores:d},m={maxOutputSize:n=h.maxOutputSize,iouThreshold:r=h.iouThreshold,scoreThreshold:o=h.scoreThreshold,softNmsSigma:c=h.softNmsSigma},y=z.a.runKernel(W.Qb,f,m);return{selectedIndices:y[0],selectedScores:y[1]}}});const xt=async function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY,c=0){const l=Object(I.a)(t,"boxes","nonMaxSuppressionAsync"),d=Object(I.a)(e,"scores","nonMaxSuppressionAsync"),h=mt(l,d,n,r,o,c);n=h.maxOutputSize,r=h.iouThreshold,o=h.scoreThreshold,c=h.softNmsSigma;const f=await Promise.all([l.data(),d.data()]),m=f[0],y=f[1],O=Object(gt.c)(m,y,n,r,o,c);return l!==t&&l.dispose(),d!==e&&d.dispose(),O};const vt=Object(f.a)({nonMaxSuppressionPadded_:function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY,c=!1){const l=Object(I.a)(t,"boxes","nonMaxSuppression"),d=Object(I.a)(e,"scores","nonMaxSuppression"),h=mt(l,d,n,r,o,null),f={boxes:l,scores:d},m={maxOutputSize:h.maxOutputSize,iouThreshold:h.iouThreshold,scoreThreshold:h.scoreThreshold,padToMaxOutputSize:c},y=z.a.runKernel(W.Pb,f,m);return{selectedIndices:y[0],validOutputs:y[1]}}});const wt=async function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY,c=!1){const l=Object(I.a)(t,"boxes","nonMaxSuppressionAsync"),d=Object(I.a)(e,"scores","nonMaxSuppressionAsync"),h=mt(l,d,n,r,o,null),f=h.maxOutputSize,m=h.iouThreshold,y=h.scoreThreshold,[O,x]=await Promise.all([l.data(),d.data()]),v=Object(gt.b)(O,x,f,m,y,c);return l!==t&&l.dispose(),d!==e&&d.dispose(),v};var jt=n(418),Et=n(417),$t=n(271),Ct=n(270),Nt=n(280),Rt=n(260);Object(f.a)({bandPart_:function(a,t,e){Object(A.assert)(t%1==0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),Object(A.assert)(e%1==0,(()=>`bandPart(): numUpper must be an integer, got ${e}.`));const n=Object(I.a)(a,"a","bandPart");Object(A.assert)(n.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`));const r=n.shape,[o,c]=n.shape.slice(-2);if(!(t<=o))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`);if(!(e<=c))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${c}).`);t<0&&(t=o),e<0&&(e=c);const i=Object(j.a)(Object(v.a)(0,o,1,"int32"),[-1,1]),l=Object(v.a)(0,c,1,"int32"),d=Object(sub.a)(i,l),h=Object(Nt.a)(Object(Ct.a)(d,Object(E.a)(+t,"int32")),Object($t.a)(d,Object(E.a)(-e,"int32"))),f=Object(F.a)([o,c],n.dtype);return Object(j.a)(Object(R.a)(Object(_.a)(Object(j.a)(n,[-1,o,c])).map((t=>Object(Rt.a)(h,t,f)))),r)}});var St=n(339),Tt=n(290),It=n(338),At=n(236);Object(f.a)({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,Object(A.assert)(null!=t&&t.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=t[0].shape[0];for(let i=1;i<t.length;++i)Object(A.assert)(t[i].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[i].shape[0]} vs. ${n})`))}else e=!0,t=Object(Tt.a)(t,t.shape[0],0).map((t=>Object(It.a)(t,[0])));Object(A.assert)(t.length<=t[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`));const n=[],r=t;for(let i=0;i<t.length;++i)n.push(z.a.tidy((()=>{let t=r[i];if(i>0)for(let e=0;e<i;++e){const r=Object(x.a)(Object(At.a)(Object(x.a)(n[e],t)),n[e]);t=Object(sub.a)(t,r)}return Object(div.a)(t,Object(St.a)(t,"euclidean"))})));return e?Object(R.a)(n,0):n}});var kt=n(273),Dt=n(289),_t=n(318);const Ft=Object(f.a)({eye_:function(t,e,n,r="float32"){null==e&&(e=t);const o=Object(c.a)([t,e],r),l=t<=e?t:e;for(let i=0;i<l;++i)o.set(1,i,i);const d=Object(j.a)(o.toTensor(),[t,e]);if(null==n)return d;if(1===n.length)return Object(_t.a)(Object(Dt.a)(d,0),[n[0],1,1]);if(2===n.length)return Object(_t.a)(Object(Dt.a)(Object(Dt.a)(d,0),0),[n[0],n[1],1,1]);if(3===n.length)return Object(_t.a)(Object(Dt.a)(Object(Dt.a)(Object(Dt.a)(d,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});var Pt=n(264),Mt=n(246);function Bt(t,e=!1){return z.a.tidy((()=>{Object(A.assert)(2===t.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`));const n=t.shape[0],r=t.shape[1];let q=Ft(n),o=Object(l.a)(t);const c=D([[1]],[1,1]);let d=Object(l.a)(c);const f=n>=r?r:n;for(let t=0;t<f;++t){const e=o,f=d,m=q;[d,o,q]=z.a.tidy((()=>{const e=Object(C.a)(o,[t,t],[n-t,1]),f=Object(St.a)(e),m=Object(C.a)(o,[t,t],[1,1]),s=Object(Rt.a)(Object(Pt.a)(m,0),D([[-1]]),D([[1]])),y=Object(sub.a)(m,Object(x.a)(s,f)),O=Object(div.a)(e,y);d=1===O.shape[0]?Object(l.a)(c):Object(h.a)([c,Object(C.a)(O,[1,0],[O.shape[0]-1,O.shape[1]])],0);const v=Object(Mt.a)(Object(div.a)(Object(st.a)(s,y),f)),w=Object(C.a)(o,[t,0],[n-t,r]),j=Object(x.a)(v,d),E=Object(P.a)(d);if(0===t)o=Object(sub.a)(w,Object(st.a)(j,Object(st.a)(E,w)));else{const e=Object(sub.a)(w,Object(st.a)(j,Object(st.a)(E,w)));o=Object(h.a)([Object(C.a)(o,[0,0],[t,r]),e],0)}const $=Object(P.a)(j),N=Object(C.a)(q,[0,t],[n,q.shape[1]-t]);if(0===t)q=Object(sub.a)(N,Object(st.a)(Object(st.a)(N,d),$));else{const e=Object(sub.a)(N,Object(st.a)(Object(st.a)(N,d),$));q=Object(h.a)([Object(C.a)(q,[0,0],[n,t]),e],1)}return[d,o,q]})),Object(kt.b)([e,f,m])}return!e&&n>r&&(q=Object(C.a)(q,[0,0],[n,r]),o=Object(C.a)(o,[0,0],[r,r])),[q,o]}))}Object(f.a)({qr_:function(t,e=!1){if(Object(A.assert)(t.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`)),2===t.rank)return Bt(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce(((t,e)=>t*e)),r=Object(_.a)(Object(j.a)(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),o=[],c=[];r.forEach((t=>{const[n,r]=Bt(t,e);o.push(n),c.push(r)}));return[Object(j.a)(Object(R.a)(o,0),t.shape),Object(j.a)(Object(R.a)(c,0),t.shape)]}}});var Lt=n(291),Vt=n(261),zt=n(230),Ut=n(341),Wt=n(319),Gt=n(292);const Ht=Object(f.a)({computeWeightedLoss_:function(t,e,n=Vt.a.SUM_BY_NONZERO_WEIGHTS){const r=Object(I.a)(t,"losses","computeWeightedLoss");let o=null;null!=e&&(o=Object(I.a)(e,"weights","computeWeightedLoss"));const c=null==o?r:Object(x.a)(r,o);if(n===Vt.a.NONE)return c;if(n===Vt.a.SUM)return Object(At.a)(c);if(n===Vt.a.MEAN){if(null==o)return Object(Ut.a)(c);{const t=r.size/o.size,e=Object(div.a)(Object(At.a)(c),Object(At.a)(o));return t>1?Object(div.a)(e,Object(E.a)(t)):e}}if(n===Vt.a.SUM_BY_NONZERO_WEIGHTS){if(null==o)return Object(div.a)(Object(At.a)(c),Object(E.a)(r.size));{const t=Object(x.a)(o,Object(Gt.a)(r.shape)),e=Object(zt.a)(Object(At.a)(Object(Wt.a)(t,Object(E.a)(0))),"float32");return Object(div.a)(Object(At.a)(c),e)}}throw Error(`Unknown reduction: ${n}`)}});Object(f.a)({absoluteDifference_:function(t,e,n,r=Vt.a.SUM_BY_NONZERO_WEIGHTS){const o=Object(I.a)(t,"labels","absoluteDifference"),c=Object(I.a)(e,"predictions","absoluteDifference");let l=null;null!=n&&(l=Object(I.a)(n,"weights","absoluteDifference")),Object(A.assertShapesMatch)(o.shape,c.shape,"Error in absoluteDifference: ");const d=Object(Lt.a)(Object(sub.a)(o,c));return Ht(d,l,r)}});Object(f.a)({cosineDistance_:function(t,e,n,r,o=Vt.a.SUM_BY_NONZERO_WEIGHTS){const c=Object(I.a)(t,"labels","cosineDistance"),l=Object(I.a)(e,"predictions","cosineDistance");let d=null;null!=r&&(d=Object(I.a)(r,"weights","cosineDistance")),Object(A.assertShapesMatch)(c.shape,l.shape,"Error in cosineDistance: ");const h=Object(E.a)(1),f=Object(sub.a)(h,Object(At.a)(Object(x.a)(c,l),n,!0));return Ht(f,d,o)}});var qt=n(293);Object(f.a)({hingeLoss_:function(t,e,n,r=Vt.a.SUM_BY_NONZERO_WEIGHTS){let o=Object(I.a)(t,"labels","hingeLoss");const c=Object(I.a)(e,"predictions","hingeLoss");let l=null;null!=n&&(l=Object(I.a)(n,"weights","hingeLoss")),Object(A.assertShapesMatch)(o.shape,c.shape,"Error in hingeLoss: ");const d=Object(E.a)(1);o=Object(sub.a)(Object(x.a)(Object(E.a)(2),o),d);const h=Object(qt.a)(Object(sub.a)(d,Object(x.a)(o,c)));return Ht(h,l,r)}});var Kt=n(320),Xt=n(250);Object(f.a)({huberLoss_:function(t,e,n,r=1,c=Vt.a.SUM_BY_NONZERO_WEIGHTS){const l=Object(I.a)(t,"labels","huberLoss"),d=Object(I.a)(e,"predictions","huberLoss");let h=null;null!=n&&(h=Object(I.a)(n,"weights","huberLoss")),Object(A.assertShapesMatch)(l.shape,d.shape,"Error in huberLoss: ");const f=Object(E.a)(r),m=Object(Lt.a)(Object(sub.a)(d,l)),y=Object(Kt.a)(m,f),O=Object(sub.a)(m,y),v=Object(o.a)(Object(x.a)(Object(E.a)(.5),Object(Xt.a)(y)),Object(x.a)(f,O));return Ht(v,h,c)}});var Yt=n(294);Object(f.a)({logLoss_:function(t,e,n,r=1e-7,c=Vt.a.SUM_BY_NONZERO_WEIGHTS){const l=Object(I.a)(t,"labels","logLoss"),d=Object(I.a)(e,"predictions","logLoss");let h=null;null!=n&&(h=Object(I.a)(n,"weights","logLoss")),Object(A.assertShapesMatch)(l.shape,d.shape,"Error in logLoss: ");const f=Object(E.a)(1),m=Object(E.a)(r),y=Object(Mt.a)(Object(x.a)(l,Object(Yt.a)(Object(o.a)(d,m)))),O=Object(x.a)(Object(sub.a)(f,l),Object(Yt.a)(Object(o.a)(Object(sub.a)(f,d),m))),v=Object(sub.a)(y,O);return Ht(v,h,c)}});var Qt=n(321);Object(f.a)({meanSquaredError_:function(t,e,n,r=Vt.a.SUM_BY_NONZERO_WEIGHTS){const o=Object(I.a)(t,"labels","meanSquaredError"),c=Object(I.a)(e,"predictions","meanSquaredError");let l=null;null!=n&&(l=Object(I.a)(n,"weights","meanSquaredError")),Object(A.assertShapesMatch)(o.shape,c.shape,"Error in meanSquaredError: ");const d=Object(Qt.a)(o,c);return Ht(d,l,r)}});var Jt=n(263),Zt=n(372);Object(f.a)({sigmoidCrossEntropy_:function(t,e,n,r=0,c=Vt.a.SUM_BY_NONZERO_WEIGHTS){let l=Object(I.a)(t,"multiClassLabels","sigmoidCrossEntropy");const d=Object(I.a)(e,"logits","sigmoidCrossEntropy");let h=null;if(null!=n&&(h=Object(I.a)(n,"weights","sigmoidCrossEntropy")),Object(A.assertShapesMatch)(l.shape,d.shape,"Error in sigmoidCrossEntropy: "),r>0){const t=Object(E.a)(r),e=Object(E.a)(1),n=Object(E.a)(.5);l=Object(o.a)(Object(x.a)(l,Object(sub.a)(e,t)),Object(x.a)(n,t))}const f=function(t,e){const n=Object(I.a)(t,"labels","sigmoidCrossEntropyWithLogits"),r=Object(I.a)(e,"logits","sigmoidCrossEntropyWithLogits");Object(A.assertShapesMatch)(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const c=Object(qt.a)(r),l=Object(x.a)(r,n),d=Object(Zt.a)(Object(Jt.a)(Object(Mt.a)(Object(Lt.a)(r))));return Object(o.a)(Object(sub.a)(c,l),d)}(l,d);return Ht(f,h,c)}});var te=n(239),ee=n(342);Object(f.a)({softmaxCrossEntropy_:function(t,e,n,r=0,c=Vt.a.SUM_BY_NONZERO_WEIGHTS){let l=Object(I.a)(t,"onehotLabels","softmaxCrossEntropy");const d=Object(I.a)(e,"logits","softmaxCrossEntropy");let h=null;if(null!=n&&(h=Object(I.a)(n,"weights","softmaxCrossEntropy")),Object(A.assertShapesMatch)(l.shape,d.shape,"Error in softmaxCrossEntropy: "),r>0){const t=Object(E.a)(r),e=Object(E.a)(1),n=Object(E.a)(l.shape[1]);l=Object(o.a)(Object(x.a)(l,Object(sub.a)(e,t)),Object(div.a)(t,n))}const f=function(t,e,n=-1){if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);const r=Object(U.a)(((t,e,r)=>{const o=Object(ee.a)(e,[n],!0),c=Object(sub.a)(Object(zt.a)(e,"float32"),o);r([t,c]);const l=Object(Mt.a)(Object(x.a)(c,t));return{value:Object(At.a)(l,[n]),gradFunc:(t,e)=>{const[r,o]=e,c=Object(te.e)(t.shape,[n]);return[Object(x.a)(Object(j.a)(t,c),Object(sub.a)(Object(zt.a)(r,"float32"),Object(Jt.a)(o))),Object(x.a)(Object(j.a)(t,c),Object(sub.a)(Object(Jt.a)(o),Object(zt.a)(r,"float32")))]}}}));return r(t,e)}(l,d);return Ht(f,h,c)}}),B.a,L.a,M.a,V.a;const ne={flipLeftRight:ht,resizeNearestNeighbor:Et.a,resizeBilinear:jt.a,rotateWithOffset:ft,cropAndResize:pt,nonMaxSuppression:bt,nonMaxSuppressionAsync:yt,nonMaxSuppressionWithScore:Ot,nonMaxSuppressionWithScoreAsync:xt,nonMaxSuppressionPadded:vt,nonMaxSuppressionPaddedAsync:wt}},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(221);const h=Object(d.a)({mul_:function(a,b){let t=Object(l.a)(a,"a","mul"),e=Object(l.a)(b,"b","mul");[t,e]=Object(c.b)(t,e);const n={a:t,b:e};return r.a.runKernelFunc(((n,r)=>{const o=n.multiply(t,e);return r([t,e]),o}),n,null,o.Mb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221);const h=Object(d.a)({cast_:function(t,e){const n=Object(c.a)(t,"x","cast");if(!l.isValidDtype(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const d={x:n},h={dtype:e};return r.a.runKernelFunc((t=>t.cast(n,e)),d,null,o.v,h)}})},function(t,e,n){"use strict";function r(t,e){const n=t.length,r=[];for(let i=0;i<n;i++){const o=n-1-i,a=t[o]||1;(e[e.length-1-i]||1)>1&&1===a&&r.unshift(o)}return r}function o(t,e){const n=[];for(let i=0;i<e.length;i++){const r=t[t.length-i-1],o=e.length-i-1,c=e[o];(null==r||1===r&&c>1)&&n.unshift(o)}return n}function c(t,e){const n=[],r=Math.max(t.length,e.length);for(let i=0;i<r;i++){let a=t[t.length-i-1];null==a&&(a=1);let b=e[e.length-i-1];if(null==b&&(b=1),1===a)n.unshift(b);else if(1===b)n.unshift(a);else{if(a!==b){throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`)}n.unshift(a)}}return n}n.d(e,"b",(function(){return r})),n.d(e,"c",(function(){return o})),n.d(e,"a",(function(){return c}))},function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(225),o=n(313);function c(t,e){if((Object(r.isTypedArray)(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&Object(r.isTypedArray)(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Object(o.a)(t,[],[],e)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return sub}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(221);const sub=Object(d.a)({sub_:function(a,b){let t=Object(l.a)(a,"a","sub"),e=Object(l.a)(b,"b","sub");[t,e]=Object(c.b)(t,e);const n={a:t,b:e};return r.a.runKernelFunc(((n,r)=>{const o=n.subtract(t,e);return r([t,e]),o}),n,null,o.Ec)}})},function(t,e,n){"use strict";n.d(e,"b",(function(){return c})),n.d(e,"a",(function(){return l}));var r=n(223),o=n(277);n(225);function c(a,b){if(a.dtype===b.dtype)return[a,b];const t=Object(o.b)(a.dtype,b.dtype);return[a.cast(t),b.cast(t)]}function l(t){const e=[];return d(t,e,new Set),e}function d(t,e,n){if(null==t)return;if(t instanceof r.a)return void e.push(t);if(o=t,!Array.isArray(o)&&"object"!=typeof o)return;var o;const c=t;for(const t in c){const r=c[t];n.has(r)||(n.add(r),d(r,e,n))}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return div}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(332),h=n(221);const div=Object(h.a)({div_:function(a,b){let t=Object(l.a)(a,"a","div"),e=Object(l.a)(b,"b","div");if([t,e]=Object(c.b)(t,e),"int32"===t.dtype&&"int32"===e.dtype)return Object(d.a)(t,e);const n={a:t,b:e};return r.a.runKernelFunc(((n,r)=>{const o=n.realDivide(t,e);return r([t,e]),o}),n,null,o.R,{})}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return O}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(239),h=n(230),f=n(221),m=n(227),y=n(241);const O=Object(f.a)({sum_:function(t,e=null,n=!1){let f=Object(c.a)(t,"x","sum");"bool"===f.dtype&&(f=Object(h.a)(f,"int32"));const O={x:f},x={axis:e,keepDims:n};return r.a.runKernelFunc(((t,r)=>{r([f]);const o=Object(l.parseAxisParam)(e,f.shape),c=Object(d.f)(o,f.rank);let h=o,O=f;null!=c&&(O=Object(y.a)(f,c),h=Object(d.g)(h.length,f.rank));let x=t.sum(O,h);if(n){const t=Object(d.e)(x.shape,o);x=Object(m.a)(x,t)}return x}),O,null,o.Fc,x)}})},function(t,e,n){"use strict";n.d(e,"d",(function(){return o})),n.d(e,"e",(function(){return c})),n.d(e,"f",(function(){return l})),n.d(e,"a",(function(){return d})),n.d(e,"b",(function(){return h})),n.d(e,"c",(function(){return f})),n.d(e,"i",(function(){return v})),n.d(e,"h",(function(){return w})),n.d(e,"g",(function(){return j}));var r=n(225);function o(t,e,n,r,o="NHWC",c){return d(t,[...e,t[3]],n,c,r,null,null,j(o))}function c(t,e,n,r,o,c,l="channelsLast"){const[h,f]=m(e);let y;if("channelsLast"===l)y=[h,f,t[3],t[3]];else{if("channelsFirst"!==l)throw new Error(`Unknown dataFormat ${l}`);y=[h,f,t[1],t[1]]}return d(t,y,n,r,o,c,!1,l)}function l(t,e,n,r,o,c,l="NDHWC"){const[d,f,m]=y(e);let O,x;if("NDHWC"===l)x="channelsLast",O=[d,f,m,t[4],t[4]];else{if("NCDHW"!==l)throw new Error(`Unknown dataFormat ${l}`);x="channelsFirst",O=[d,f,m,t[1],t[1]]}return h(t,O,n,r,o,!1,x,c)}function d(t,e,n,o,c,l,d=!1,h="channelsLast"){let[y,v,w,j]=[-1,-1,-1,-1];if("channelsLast"===h)[y,v,w,j]=t;else{if("channelsFirst"!==h)throw new Error(`Unknown dataFormat ${h}`);[y,j,v,w]=t}const[E,$,,C]=e,[N,R]=m(n),[S,T]=m(o),I=O(E,S),A=O($,T),{padInfo:k,outHeight:D,outWidth:_}=function(t,e,n,o,c,l,d,h,m){let y,O,v;if("number"==typeof t){y={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const c=function(t,e,n,o,c){null==o&&(o=f(t,e,n));const l=t[0],d=t[1],h=x((l-e+2*o)/n+1,c);r.assert(r.isInt(h),(()=>`The output # of rows (${h}) must be an integer. Change the stride and/or zero pad parameters`));const m=x((d-e+2*o)/n+1,c);return r.assert(r.isInt(m),(()=>`The output # of columns (${m}) must be an integer. Change the stride and/or zero pad parameters`)),[h,m]}([e,n],l,o,t,h);O=c[0],v=c[1]}else if("same"===t){O=Math.ceil(e/o),v=Math.ceil(n/c);const t=Math.max(0,(O-1)*o+l-e),r=Math.max(0,(v-1)*c+d-n),h=Math.floor(t/2),f=t-h,m=Math.floor(r/2);y={top:h,bottom:f,left:m,right:r-m,type:"SAME"}}else if("valid"===t)y={top:0,bottom:0,left:0,right:0,type:"VALID"},O=Math.ceil((e-l+1)/o),v=Math.ceil((n-d+1)/c);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const r="channelsLast"===m?t[1][0]:t[2][0],f="channelsLast"===m?t[1][1]:t[2][1],w="channelsLast"===m?t[2][0]:t[3][0],j="channelsLast"===m?t[2][1]:t[3][1];y={top:r,bottom:f,left:w,right:j,type:0===r&&0===f&&0===w&&0===j?"VALID":"EXPLICIT"},O=x((e-l+r+f)/o+1,h),v=x((n-d+w+j)/c+1,h)}}return{padInfo:y,outHeight:O,outWidth:v}}(c,v,w,N,R,I,A,l,h),F=d?C*j:C;let P;return"channelsFirst"===h?P=[y,F,D,_]:"channelsLast"===h&&(P=[y,D,_,F]),{batchSize:y,dataFormat:h,inHeight:v,inWidth:w,inChannels:j,outHeight:D,outWidth:_,outChannels:F,padInfo:k,strideHeight:N,strideWidth:R,filterHeight:E,filterWidth:$,effectiveFilterHeight:I,effectiveFilterWidth:A,dilationHeight:S,dilationWidth:T,inShape:t,outShape:P,filterShape:e}}function h(t,e,n,o,c,l=!1,d="channelsLast",h){let[m,v,w,j,E]=[-1,-1,-1,-1,-1];if("channelsLast"===d)[m,v,w,j,E]=t;else{if("channelsFirst"!==d)throw new Error(`Unknown dataFormat ${d}`);[m,E,v,w,j]=t}const[$,C,N,,R]=e,[S,T,I]=y(n),[A,k,D]=y(o),_=O($,A),F=O(C,k),P=O(N,D),{padInfo:M,outDepth:B,outHeight:L,outWidth:V}=function(t,e,n,o,c,l,d,h,m,y,O){let v,w,j,E;if("number"==typeof t){v={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const l=function(t,e,n,o,c,l){null==c&&(c=f(t,e,o));const d=t[0],h=t[1],m=t[2],y=x((d-e+2*c)/o+1,l);r.assert(r.isInt(y),(()=>`The output # of depths (${y}) must be an integer. Change the stride and/or zero pad parameters`));const O=x((h-e+2*c)/o+1,l);r.assert(r.isInt(O),(()=>`The output # of rows (${O}) must be an integer. Change the stride and/or zero pad parameters`));const v=x((m-e+2*c)/o+1,l);return r.assert(r.isInt(v),(()=>`The output # of columns (${v}) must be an integer. Change the stride and/or zero pad parameters`)),[y,O,v,n]}([e,n,o,1],h,1,c,t,O);w=l[0],j=l[1],E=l[2]}else if("same"===t){w=Math.ceil(e/c),j=Math.ceil(n/l),E=Math.ceil(o/d);const t=(w-1)*c+h-e,r=(j-1)*l+m-n,f=(E-1)*d+y-o,O=Math.floor(t/2),x=t-O,$=Math.floor(r/2),C=r-$,N=Math.floor(f/2);v={top:$,bottom:C,left:N,right:f-N,front:O,back:x,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);v={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},w=Math.ceil((e-h+1)/c),j=Math.ceil((n-m+1)/l),E=Math.ceil((o-y+1)/d)}return{padInfo:v,outDepth:w,outHeight:j,outWidth:E}}(c,v,w,j,S,T,I,_,F,P,h),z=l?R*E:R;let U;return"channelsFirst"===d?U=[m,z,B,L,V]:"channelsLast"===d&&(U=[m,B,L,V,z]),{batchSize:m,dataFormat:d,inDepth:v,inHeight:w,inWidth:j,inChannels:E,outDepth:B,outHeight:L,outWidth:V,outChannels:z,padInfo:M,strideDepth:S,strideHeight:T,strideWidth:I,filterDepth:$,filterHeight:C,filterWidth:N,effectiveFilterDepth:_,effectiveFilterHeight:F,effectiveFilterWidth:P,dilationDepth:A,dilationHeight:k,dilationWidth:D,inShape:t,outShape:U,filterShape:e}}function f(t,e,n,r=1){const o=O(e,r);return Math.floor((t[0]*(n-1)-n+o)/2)}function m(param){return"number"==typeof param?[param,param,param]:2===param.length?[param[0],param[1],1]:param}function y(param){return"number"==typeof param?[param,param,param]:param}function O(t,e){return e<=1?t:t+(t-1)*(e-1)}function x(t,e){if(!e)return t;switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function v(param){const[t,e,n]=m(param);return 1===t&&1===e&&1===n}function w(t,e){return v(t)||v(e)}function j(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({zerosLike_:function(t){const e=Object(c.a)(t,"x","zerosLike"),n={x:e};return r.a.runKernelFunc((t=>t.zerosLike(e)),n,null,o.Oc)}})},function(t,e,n){"use strict";n.d(e,"b",(function(){return o})),n.d(e,"c",(function(){return c})),n.d(e,"d",(function(){return l})),n.d(e,"e",(function(){return d})),n.d(e,"a",(function(){return h})),n.d(e,"f",(function(){return f})),n.d(e,"h",(function(){return m})),n.d(e,"g",(function(){return y}));var r=n(225);function o(t,e){for(let i=0;i<t.length;++i)if(t[t.length-i-1]!==e-1-i)return!1;return!0}function c(t,e,n){const r=t.length+e.length,o=[];let c=0,l=0;for(let d=0;d<r;d++)-1===n.indexOf(d)?o.push(t[c++]):o.push(e[l++]);return o}function l(t,e){const n=[],r=t.length;for(let o=0;o<r;o++)-1===e.indexOf(o)&&n.push(t[o]);return[n,e.map((e=>t[e]))]}function d(t,e){return c(t,e.map((t=>1)),e)}function h(t,e,n){r.assert(o(e,n),(()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`))}function f(t,e){if(o(t,e))return null;const n=[];for(let i=0;i<e;++i)-1===t.indexOf(i)&&n.push(i);return t.forEach((t=>n.push(t))),n}function m(t){return t.map(((t,i)=>[i,t])).sort(((a,b)=>a[1]-b[1])).map((t=>t[0]))}function y(t,e){const n=[];for(let i=e-t;i<e;++i)n.push(i);return n}},function(t,e,n){"use strict";n.d(e,"d",(function(){return o})),n.d(e,"e",(function(){return c})),n.d(e,"f",(function(){return l})),n.d(e,"b",(function(){return d})),n.d(e,"g",(function(){return f})),n.d(e,"c",(function(){return m})),n.d(e,"a",(function(){return y}));var r=n(226);function o(t,e,n,o){const l=e.inputParams[t];if(l&&void 0!==l.inputIndexStart){const t=l.inputIndexStart,d=0===l.inputIndexEnd?void 0:void 0===l.inputIndexEnd?t+1:l.inputIndexEnd;if("tensor"===l.type)return c(e.inputNames[l.inputIndexStart],n,o);if("tensors"===l.type){return e.inputNames.slice(t,d).map((t=>c(t,n,o)))}const h=c(e.inputNames.slice(t)[0],n,o),data=h.dataSync();return"number"===l.type?data[0]:r.Eb.toNestedArray(h.shape,data)}const d=e.attrParams[t];return d&&d.value}function c(t,e,n){const[r,o]=f(t),c=n.currentContextIds.find((t=>!!e[h(r,t)]));return void 0!==c?e[h(r,c)][o]:void 0}function l(t,e,n){return e[h(t,n.currentContextId)]}function d(t,e){const[n,r]=f(t);return[h(n,e&&e.currentContextId),r]}function h(t,e){return e?`${t}-${e}`:t}function f(t){const e=t.split(":");if(1===e.length)return[t,0];return[e[0],Number(e[e.length-1])]}function m(t,e,n){let r=o("pad",t,e,n);if("explicit"===r){r=o("explicitPaddings",t,e,n);const c=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)c[i][0]=r[2*i],c[i][1]=r[2*i+1];return c}return r}function y(t){return t.kept?t:Object(r.U)(t)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221);const h=Object(d.a)({transpose_:function(t,e){const n=Object(c.a)(t,"x","transpose");if(null==e&&(e=n.shape.map(((s,i)=>i)).reverse()),l.assert(n.rank===e.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`)),e.forEach((t=>{l.assert(t>=0&&t<n.rank,(()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${e}`))})),n.rank<=1)return n.clone();const d={x:n},h={perm:e};return r.a.runKernelFunc((t=>t.transpose(n,e)),d,null,o.Kc,h)}})},,,function(t,e,n){"use strict";n.d(e,"a",(function(){return o})),n.d(e,"b",(function(){return c})),n.d(e,"c",(function(){return d}));const r="tfjsflags";class o{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(e instanceof Promise)throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=function(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((s,...t)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,t[0],t[1]),t.join("=")))),e}(this.global.location.search);if(r in t){t.tfjsflags.split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)}))}}}function c(){return l}let l=null;function d(t){l=t}},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(221);const h=Object(d.a)({add_:function(a,b){let t=Object(l.a)(a,"a","add"),e=Object(l.a)(b,"b","add");[t,e]=Object(c.b)(t,e);const n={a:t,b:e};return r.a.runKernelFunc(((n,r)=>{const o=n.add(t,e);return r([t,e]),o}),n,null,o.d)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({neg_:function(t){const e=Object(c.a)(t,"x","neg"),n={x:e};return r.a.runKernelFunc((t=>t.neg(e)),n,null,o.Nb)}})},,,,function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(224),o=n(222),c=n(221);const l=Object(c.a)({square_:function(t){const e=Object(o.a)(t,"x","square"),n=[e];return r.a.runKernelFunc(((t,n)=>(n([e]),t.square(e))),{x:e},null,"Square",{},n,[])}})},,,function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(224);n(223),n(222),n(225);function o(t){return r.a.customGrad(t)}},function(t,e){t.exports=function(){throw new Error("define cannot be used indirect")}},,,,function(t,e,n){"use strict";n.d(e,"a",(function(){return m}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(367),h=n(221),f=n(312);const m=Object(h.a)({concat_:function(t,e=0){Object(l.assert)(t.length>=1,(()=>"Pass at least one tensor to concat"));let n=Object(c.b)(t,"tensors","concat");"complex64"===n[0].dtype&&n.forEach((t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)}));const h=n,m={axis:e};return r.a.runKernelFunc(((t,r)=>{const o=Object(l.parseAxisParam)(e,n[0].shape)[0],c=Object(d.b)(n.map((t=>t.shape)),o);if(0===Object(l.sizeFromShape)(c))return Object(f.a)([],c);if(n=n.filter((t=>t.size>0)),1===n.length)return n[0];const h=n.map((t=>t.shape));Object(d.a)(h,o);const m=t.concat(n,o);return r(n),m}),h,null,o.z,m)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(221),d=n(278);const h=Object(l.a)({slice_:function(t,e,n){const l=Object(c.a)(t,"x","slice");if(0===l.rank)throw new Error("Slicing scalar is not possible");const h={x:l},f={begin:e,size:n};return r.a.runKernelFunc(((t,r)=>{const[o,c]=d.parseSliceParams(l,e,n);return d.assertParamsValid(l,o,c),r([l]),t.slice(l,o,c)}),h,null,o.tc,f)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return m}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(337),h=n(231),f=n(221);const m=Object(f.a)({where_:function(t,a,b){const e=Object(c.a)(a,"a","where"),n=Object(c.a)(b,"b","where"),f=Object(c.a)(t,"condition","where","bool"),m=Object(h.a)(e.shape,n.shape),y=Object(d.a)(e,m),O=Object(d.a)(n,m);1===f.rank&&Object(l.assert)(f.shape[0]===e.shape[0],(()=>"The first dimension of `a` must match the size of `condition`.")),1!==f.rank&&Object(l.assertShapesMatch)(f.shape,O.shape,"Error in where: ");const x={condition:f,t:y,e:O};return r.a.runKernelFunc(((t,e)=>{const n=t.select(f,y,O);return e([f]),n}),x,null,o.nc)}})},function(t,e,n){"use strict";var r;n.d(e,"a",(function(){return r})),function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(r||(r={}))},function(t,e,n){"use strict";(function(t){n.d(e,"f",(function(){return d})),n.d(e,"e",(function(){return h})),n.d(e,"a",(function(){return O})),n.d(e,"b",(function(){return x})),n.d(e,"d",(function(){return v})),n.d(e,"c",(function(){return w})),n.d(e,"g",(function(){return j}));var r=n(267),o=n(312),c=n(225),l=n(415);async function d(t,e){const n=[],r=[],o=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);for(let i=0;i<o.length;++i){const c=o[i],l=Array.isArray(t)?t[i].tensor:t[c];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${c}': ${l.dtype}`);const d={name:c,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const t=new Promise((async t=>{const e=await l.bytes(),n=e.reduce(((p,t)=>p+t.length),0)+4*e.length,r=new Uint8Array(n);let o=0;for(let i=0;i<e.length;i++){const t=e[i],n=new Uint8Array(new Uint32Array([t.length]).buffer);r.set(n,o),o+=4,r.set(t,o),o+=t.length}t(r)}));r.push(t)}else r.push(l.data());null!=e&&(d.group=e),n.push(d)}return{data:f(await Promise.all(r)),specs:n}}function h(t,e){const n={};let d,h=0;for(const f of e){const e=f.name,m=f.dtype,y=f.shape,O=Object(c.sizeFromShape)(y);let x;if("quantization"in f){const n=f.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${f.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${f.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==m)throw new Error(`Weight ${f.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${m}.`)}const r=l.a[n.dtype],o=t.slice(h,h+O*r),c="uint8"===n.dtype?new Uint8Array(o):new Uint16Array(o);if("float32"===m)if("uint8"===n.dtype||"uint16"===n.dtype){x=new Float32Array(c.length);for(let i=0;i<c.length;i++){const t=c[i];x[i]=t*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===d&&(d=E()),x=d(c)}else{if("int32"!==m)throw new Error(`Unsupported dtype in weight '${e}': ${m}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);x=new Int32Array(c.length);for(let i=0;i<c.length;i++){const t=c[i];x[i]=Math.round(t*n.scale+n.min)}}h+=O*r}else if("string"===m){const e=Object(c.sizeFromShape)(f.shape);x=[];for(let i=0;i<e;i++){const e=new Uint32Array(t.slice(h,h+4))[0];h+=4;const n=new Uint8Array(t.slice(h,h+e));x.push(n),h+=e}}else{const c=l.a[m],d=t.slice(h,h+O*c);if("float32"===m)x=new Float32Array(d);else if("int32"===m)x=new Int32Array(d);else if("bool"===m)x=new Uint8Array(d);else{if("complex64"!==m)throw new Error(`Unsupported dtype in weight '${e}': ${m}`);{x=new Float32Array(d);const t=new Float32Array(x.length/2),image=new Float32Array(x.length/2);for(let i=0;i<t.length;i++)t[i]=x[2*i],image[i]=x[2*i+1];const c=Object(o.a)(t,y,"float32"),l=Object(o.a)(image,y,"float32");n[e]=Object(r.a)(c,l)}}h+=O*c}"complex64"!==m&&(n[e]=Object(o.a)(x,y,m))}return n}function f(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach((t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`)}));const r=new Uint8Array(e);let o=0;return n.forEach((t=>{r.set(new Uint8Array(t.buffer),o),o+=t.byteLength})),r.buffer}const m=void 0!==t&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function y(e){return m?t.byteLength(e):new Blob([e]).size}function O(e){if(m)return t.from(e).toString("base64");const n=new Uint8Array(e);let s="";for(let i=0,t=n.length;i<t;i++)s+=String.fromCharCode(n[i]);return btoa(s)}function x(e){if(m){const n=t.from(e,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}const s=atob(e),n=new Uint8Array(s.length);for(let i=0;i<s.length;++i)n.set([s.charCodeAt(i)],i);return n.buffer}function v(t){if(1===t.length)return t[0];let e=0;t.forEach((t=>{e+=t.byteLength}));const n=new Uint8Array(e);let r=0;return t.forEach((t=>{n.set(new Uint8Array(t),r),r+=t.byteLength})),n.buffer}function w(path){for(path=path.trim();path.endsWith("/");)path=path.slice(0,path.length-1);const t=path.split("/");return t[t.length-1]}function j(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:y(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:y(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function E(){const t=function(){const t=i=>{let t=i<<13,e=0;for(;0==(8388608&t);)e-=8388608,t<<=1;return t&=-8388609,e+=947912704,t|e},e=new Uint32Array(2048);e[0]=0;for(let i=1;i<1024;i++)e[i]=t(i);for(let i=1024;i<2048;i++)e[i]=939524096+(i-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let i=1;i<31;i++)t[i]=i<<23;for(let i=33;i<63;i++)t[i]=2147483648+(i-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let i=0;i<64;i++)t[i]=1024;return t[0]=t[32]=0,t}();return r=>{const o=new ArrayBuffer(4*r.length),c=new Uint32Array(o);for(let o=0;o<r.length;o++){const l=r[o],d=t[n[l>>10]+(1023&l)]+e[l>>10];c[o]=d}return new Float32Array(o)}}}).call(this,n(414).Buffer)},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({exp_:function(t){const e=Object(c.a)(t,"x","exp"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.exp(e);return n([r]),r}),n,null,o.W)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(231),h=n(221);const f=Object(h.a)({greater_:function(a,b){let t=Object(l.a)(a,"a","greater"),e=Object(l.a)(b,"b","greater");[t,e]=Object(c.b)(t,e),Object(d.a)(t.shape,e.shape);const n={a:t,b:e};return r.a.runKernelFunc((n=>n.greater(t,e)),n,null,o.jb)}})},,,function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221);const h=Object(d.a)({complex_:function(t,e){const n=Object(c.a)(t,"real","complex"),d=Object(c.a)(e,"imag","complex");l.assertShapesMatch(n.shape,d.shape,`real and imag shapes, ${n.shape} and ${d.shape}, must match in call to tf.complex().`);const h={real:n,imag:d};return r.a.runKernelFunc((t=>t.complex(n,d)),h,null,o.y)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(223),o=n(225);function c(t,e="float32",n){return e=e||"float32",o.assertNonNegativeIntegerDimensions(t),new r.b(t,e,n)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(224),o=n(225),c=n(267);function l(t,e="float32"){if("complex64"===e){const e=l(t,"float32"),n=l(t,"float32");return Object(c.a)(e,n)}const n=Object(o.makeZerosTypedArray)(Object(o.sizeFromShape)(t),e);return r.a.makeTensor(n,t,e)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(231),h=n(221);const f=Object(h.a)({lessEqual_:function(a,b){let t=Object(l.a)(a,"a","lessEqual"),e=Object(l.a)(b,"b","lessEqual");[t,e]=Object(c.b)(t,e),Object(d.a)(t.shape,e.shape);const n={a:t,b:e};return r.a.runKernelFunc(((n,r)=>{const o=n.lessEqual(t,e);return r([t,e]),o}),n,null,o.ub)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(231),h=n(221);const f=Object(h.a)({greaterEqual_:function(a,b){let t=Object(l.a)(a,"a","greaterEqual"),e=Object(l.a)(b,"b","greaterEqual");[t,e]=Object(c.b)(t,e),Object(d.a)(t.shape,e.shape);const n={a:t,b:e};return r.a.runKernelFunc(((n,r)=>{const o=n.greaterEqual(t,e);return r([t,e]),o}),n,null,o.kb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({sqrt_:function(t){const e=Object(c.a)(t,"x","sqrt"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.sqrt(e);return n([e]),r}),n,null,o.zc)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d})),n.d(e,"c",(function(){return h})),n.d(e,"g",(function(){return f})),n.d(e,"b",(function(){return m})),n.d(e,"e",(function(){return y})),n.d(e,"d",(function(){return O})),n.d(e,"f",(function(){return x}));var r=n(224),o=n(244),c=n(223),l=n(234);function d(t){Object(o.b)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function h(){return r.a}function f(t,e){return r.a.tidy(t,e)}function m(t){Object(l.a)(t).forEach((t=>t.dispose()))}function y(t){return r.a.keep(t)}function O(){return r.a.backendName}function x(t,e,n=1){return r.a.registerBackend(t,e,n)}Object(c.d)(d)},,,,function(t,e,n){"use strict";var r,o,c,l,d;n.d(e,"b",(function(){return f})),n.d(e,"a",(function(){return m})),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(r||(r={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(o||(o={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(c||(c={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(l||(l={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(d||(d={}));const h={float32:l,int32:o,bool:c,complex64:d};function f(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return h[t][e]}function m(t){return f(t,"int32")}},function(t,e,n){"use strict";n.r(e),n.d(e,"assertParamsValid",(function(){return o})),n.d(e,"maskToAxes",(function(){return c})),n.d(e,"computeOutShape",(function(){return l})),n.d(e,"stridesWithElidedDims",(function(){return d})),n.d(e,"getNormalizedAxes",(function(){return m})),n.d(e,"startIndicesWithElidedDims",(function(){return y})),n.d(e,"stopIndicesWithElidedDims",(function(){return O})),n.d(e,"stridesForAxis",(function(){return x})),n.d(e,"startForAxis",(function(){return v})),n.d(e,"stopForAxis",(function(){return w})),n.d(e,"isSliceContinous",(function(){return j})),n.d(e,"computeFlatOffset",(function(){return E})),n.d(e,"parseSliceParams",(function(){return $}));var r=n(225);function o(input,t,e){const n=input.shape.length;r.assert(n===t.length,(()=>`Error in slice${n}D: Length of begin ${t} must match the rank of the array (${n}).`)),r.assert(n===e.length,(()=>`Error in slice${n}D: Length of size ${e} must match the rank of the array (${n}).`));for(let i=0;i<n;++i)r.assert(t[i]+e[i]<=input.shape[i],(()=>`Error in slice${n}D: begin[${i}] + size[${i}] (${t[i]+e[i]}) would overflow input.shape[${i}] (${input.shape[i]})`))}function c(mask){const t=[];let e=0;for(;mask>0;)1&mask&&t.push(e),mask/=2,e++;return t}function l(t,e,n){const r=[];for(let o=0;o<t.length;o++)r[o]=Math.ceil((e[o]-t[o])/n[o]);return r}function d(t,e,n,r){const o=[...t];for(let i=o.length;i<r.length;i++)o.push(1);for(let i=0;i<n;i++)0===i?o[e]=1:(o.splice(e,0,1),o.pop());return o}function h(t,e,n){return n<=t?n:n-(e-1)}function f(t,e){const n=[];for(let i=0;i<t;i++)n.push(e+i);return n}function m(t,e,n,r,o,c,l,h,f){const m=t.length;let j=new Array(m),E=new Array(m),$=new Array(m);if(e.length&&n>0){const f=e[0],m=n+1;j=y(l,f,m,r,t),E=O(h,f,m,o,t),$=d(c,f,m,t)}else for(let e=0;e<m;e++)j[e]=v(l,r,c,t,e,f),E[e]=w(h,o,c,t,e,f),$[e]=x(c,e,f);return{begin:j,end:E,strides:$}}function y(t,e,n,r,o){const c=[...o],l=f(n,e);for(let o=0;o<c.length;o++)if(l.indexOf(o)>-1)c[o]=0;else{const l=h(e,n,o);let d=r[l];t&1<<l&&(d=0),c[o]=d}return c}function O(t,e,n,o,c){const l=[...c],d=f(n,e);for(let r=0;r<l.length;r++)if(d.indexOf(r)>-1)l[r]=Number.MAX_SAFE_INTEGER;else{const c=h(e,n,r);let d=o[c];t&1<<c&&(d=Number.MAX_SAFE_INTEGER),l[r]=d}for(let i=0;i<l.length;i++){const t=c[i];l[i]<0&&(l[i]+=t),l[i]=r.clamp(0,l[i],c[i])}return l}function x(t,e,n){let r=t[e];return(n&1<<e||null==r)&&(r=1),r}function v(t,e,n,o,c,l){let d=e[c];const h=n[c]||1;(t&1<<c||l&1<<c||null==d)&&(d=h>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const f=o[c];return d<0&&(d+=f),d=r.clamp(0,d,f-1),d}function w(t,e,n,o,c,l){let d=e[c];const h=n[c]||1;(t&1<<c||l&1<<c||null==d)&&(d=h>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const f=o[c];return d<0&&(d+=f),d=h>0?r.clamp(0,d,f):r.clamp(-1,d,f-1),d}function j(t,e,n){let r=n.length;for(let i=0;i<n.length;i++)if(n[i]>1){r=i;break}for(let i=r+1;i<n.length;i++)if(e[i]>0||n[i]!==t[i])return!1;return!0}function E(t,e){let n=t.length>0?t[t.length-1]:1;for(let i=0;i<t.length-1;i++)n+=t[i]*e[i];return n}function $(t,e,n){let o;const c=t.shape.length;let l;return o="number"==typeof e?[e,...new Array(c-1).fill(0)]:e.length<c?e.concat(new Array(c-e.length).fill(0)):e.slice(),o.forEach((t=>{r.assert(-1!==t,(()=>"slice() does not support negative begin indexing."))})),l=null==n?new Array(c).fill(-1):"number"==typeof n?[n,...new Array(c-1).fill(-1)]:n.length<c?n.concat(new Array(c-n.length).fill(-1)):n,l=l.map(((e,i)=>e>=0?e:(r.assert(-1===e,(()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${i}.`)),t.shape[i]-o[i]))),[o,l]}},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(222),o=n(225),c=n(258),l=n(289),d=n(221);const h=Object(d.a)({stack_:function(t,e=0){const n=Object(r.b)(t,"tensors","stack");if(o.assert(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),1===n.length)return Object(l.a)(n[0],e);const d=n[0].rank,h=n[0].shape,f=n[0].dtype;o.assert(e<=d,(()=>"Axis must be <= rank of the tensor")),n.forEach((t=>{o.assertShapesMatch(h,t.shape,"All tensors passed to stack must have matching shapes"),o.assert(f===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const m=n.map((t=>Object(l.a)(t,e)));return Object(c.a)(m,e)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(231),d=n(221);const h=Object(d.a)({logicalAnd_:function(a,b){const t=Object(c.a)(a,"a","logicalAnd","bool"),e=Object(c.a)(b,"b","logicalAnd","bool");Object(l.a)(t.shape,e.shape);const n={a:t,b:e};return r.a.runKernelFunc((n=>n.logicalAnd(t,e)),n,null,o.zb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(221);const h=Object(d.a)({pow_:function(base,t){let e=Object(l.a)(base,"base","pow"),n=Object(l.a)(t,"exp","pow");[e,n]=Object(c.b)(e,n);const d={a:e,b:n};return r.a.runKernelFunc(((t,r)=>{const o=t.pow(e,n);return r([e,n,o]),o}),d,null,o.Vb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return m}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(225),h=n(221),f=n(227);const m=Object(h.a)({matMul_:function(a,b,t=!1,e=!1){let n=Object(l.a)(a,"a","matMul"),h=Object(l.a)(b,"b","matMul");[n,h]=Object(c.b)(n,h),d.assert(n.rank>=2&&h.rank>=2&&n.rank===h.rank,(()=>`Error in matMul: inputs must have the same rank of at least 2, got ranks ${n.rank} and ${h.rank}.`));const m=t?n.shape[n.rank-2]:n.shape[n.rank-1],y=e?h.shape[h.rank-1]:h.shape[h.rank-2],O=t?n.shape[n.rank-1]:n.shape[n.rank-2],x=e?h.shape[h.rank-2]:h.shape[h.rank-1],v=n.shape.slice(0,-2),w=h.shape.slice(0,-2),j=d.sizeFromShape(v),E=d.sizeFromShape(w);d.assert(d.arraysEqual(v,w),(()=>`Error in matMul: outer dimensions (${v}) and (${w}) of Tensors with shapes ${n.shape} and ${h.shape} must match.`)),d.assert(m===y,(()=>`Error in matMul: inner shapes (${m}) and (${y}) of Tensors with shapes ${n.shape} and ${h.shape} and transposeA=${t} and transposeB=${e} must match.`));const $=n.shape.slice(0,-2).concat([O,x]),C=t?Object(f.a)(n,[j,m,O]):Object(f.a)(n,[j,O,m]),N=e?Object(f.a)(h,[E,x,y]):Object(f.a)(h,[E,y,x]),R={a:C,b:N},S={transposeA:t,transposeB:e},T=r.a.runKernelFunc(((n,r)=>(r([C,N]),n.batchMatMul(C,N,t,e))),R,null,o.s,S);return Object(f.a)(T,$)}})},function(t,e,n){"use strict";n.d(e,"c",(function(){return O})),n.d(e,"b",(function(){return x})),n.d(e,"a",(function(){return v})),n.d(e,"d",(function(){return w}));var r=n(231),o=n(343),c=n(229),l=n(345),d=n(293),h=n(344),f=n(227),m=n(295),y=n(236);function O(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return Object(c.a)(t,Object(m.a)(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function x(t,e){let n=e;const o=r.c(t.shape,e.shape);return o.length>0&&(n=Object(y.a)(n,o)),Object(f.a)(n,t.shape)}function v(t,e,n){if("linear"===e)return t;if("relu"===e)return Object(d.a)(t);if("elu"===e)return Object(o.a)(t);if("relu6"===e)return Object(h.a)(t);if("prelu"===e)return Object(l.a)(t,n);throw new Error(`Unknown fused activation ${e}.`)}const w=(t,e)=>!(t>0)||"linear"===e},function(t,e,n){"use strict";n.d(e,"a",(function(){return m}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(237),h=n(221),f=n(227);const m=Object(h.a)({conv2d_:function(t,filter,e,n,h="NHWC",m=[1,1],y){const O=Object(c.a)(t,"x","conv2d"),x=Object(c.a)(filter,"filter","conv2d");let v=O,w=!1;3===O.rank&&(w=!0,v=Object(f.a)(O,[1,O.shape[0],O.shape[1],O.shape[2]])),l.assert(4===v.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${v.rank}.`)),l.assert(4===x.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${x.rank}.`)),null!=y&&l.assert(l.isInt(n),(()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${y} but got pad ${n}.`));const j="NHWC"===h?v.shape[3]:v.shape[1];l.assert(j===x.shape[2],(()=>`Error in conv2d: depth of input (${j}) must match input depth for filter ${x.shape[2]}.`)),l.assert(d.h(e,m),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${m}'`));const E={x:v,filter:x},$={strides:e,pad:n,dataFormat:h,dilations:m,dimRoundingMode:y},C=r.a.runKernelFunc(((t,r)=>{const o=d.g(h),c=d.a(v.shape,x.shape,e,m,n,y,!1,o),l=t.conv2d(v,x,c);return r([v,x]),l}),E,null,o.A,$);return w?Object(f.a)(C,[C.shape[1],C.shape[2],C.shape[3]]):C}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d})),n.d(e,"b",(function(){return h})),n.d(e,"c",(function(){return f}));var r=n(232),o=n(288);function c(t,element,e){const n=function(t,e,n){return function(t,e,n){let r=0,o=t.length,c=0,l=!1;for(;r<o;){c=r+(o-r>>>1);const d=n(e,t[c]);d>0?r=c+1:(o=c,l=!d)}return l?r:-r-1}(t,e,n||l)}(t,element,e),r=n<0?-(n+1):n;t.splice(r,0,element)}function l(a,b){return a>b?1:a<b?-1:0}function d(t,e,n,r,o){return m(t,e,n,r,o,0).selectedIndices}function h(t,e,n,r,o,c){return m(t,e,n,r,o,0,!1,c,!0)}function f(t,e,n,r,o,c){return m(t,e,n,r,o,c,!0)}function m(t,e,n,l,d,h,f=!1,m=!1,v=!1){const w=[];for(let i=0;i<e.length;i++)e[i]>d&&w.push({score:e[i],boxIndex:i,suppressBeginIndex:0});w.sort(x);const j=h>0?-.5/h:0,E=[],$=[];for(;E.length<n&&w.length>0;){const e=w.pop(),{score:n,boxIndex:r,suppressBeginIndex:o}=e;if(n<d)break;let h=!1;for(let n=E.length-1;n>=o;--n){const o=y(t,r,E[n]);if(o>=l){h=!0;break}if(e.score=e.score*O(l,j,o),e.score<=d)break}e.suppressBeginIndex=E.length,h||(e.score===n?(E.push(r),$.push(e.score)):e.score>d&&c(w,e,x))}const C=E.length,N=n-C;m&&N>0&&(E.push(...new Array(N).fill(0)),$.push(...new Array(N).fill(0)));const R={selectedIndices:Object(o.a)(E,"int32")};return f&&(R.selectedScores=Object(o.a)($,"float32")),v&&(R.validOutputs=Object(r.a)(C,"int32")),R}function y(t,i,e){const n=t.subarray(4*i,4*i+4),r=t.subarray(4*e,4*e+4),o=Math.min(n[0],n[2]),c=Math.min(n[1],n[3]),l=Math.max(n[0],n[2]),d=Math.max(n[1],n[3]),h=Math.min(r[0],r[2]),f=Math.min(r[1],r[3]),m=Math.max(r[0],r[2]),y=Math.max(r[1],r[3]),O=(l-o)*(d-c),x=(m-h)*(y-f);if(O<=0||x<=0)return 0;const v=Math.max(o,h),w=Math.max(c,f),j=Math.min(l,m),E=Math.min(d,y),$=Math.max(j-v,0)*Math.max(E-w,0);return $/(O+x-$)}function O(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function x(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({clone_:function(t){const e=Object(c.a)(t,"x","clone",null),n={x:e};return r.a.runKernelFunc((()=>r.a.makeTensorFromDataId(e.dataId,e.shape,e.dtype)),n,null,o.mb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return y}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(239),h=n(221),f=n(227),m=n(241);const y=Object(h.a)({max_:function(t,e=null,n=!1){const h=Object(c.a)(t,"x","max"),y={x:h},O={reductionIndices:e,keepDims:n};return r.a.runKernelFunc(((t,r)=>{let o=l.parseAxisParam(e,h.shape);const c=d.f(o,h.rank);let y=h;null!=c&&(y=Object(m.a)(h,c),o=d.g(o.length,y.rank));const O=t.max(y,o);null!=c&&y.dispose();let x=O;if(n){const t=d.e(x.shape,l.parseAxisParam(e,h.shape));x=Object(f.a)(x,t),O.dispose()}return r([h,x]),x}),y,null,o.Cb,O)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(222),o=n(225),c=n(313);function l(t,e){Object(o.assertNonNull)(t);const n=Object(r.c)(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Object(c.a)(t,null,n,e)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(222),o=n(225),c=n(221),l=n(227);const d=Object(c.a)({expandDims_:function(t,e=0){const n=Object(r.a)(t,"x","expandDims",null);o.assert(e<=n.rank,(()=>"Axis must be <= rank of the tensor"));const c=n.shape.slice();return e<0&&(o.assert(-(n.rank+1)<=e,(()=>`Axis must be in the interval [${-(n.rank+1)}, ${n.rank}]`)),e=n.rank+e+1),c.splice(e,0,1),Object(l.a)(n,c)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221),h=n(369);const f=Object(d.a)({split_:function(t,e,n=0){const d=Object(c.a)(t,"x","split"),f={x:d},m={numOrSizeSplits:e,axis:n};return r.a.runKernelFunc(((t,r)=>{const o=Object(l.parseAxisParam)(n,d.shape)[0],c=Object(h.a)(d,e,o);return t.split(d,c,o)}),f,null,o.yc,m)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({abs_:function(t){const e=Object(c.a)(t,"x","abs"),n={x:e};return r.a.runKernelFunc(((t,n)=>(n([e]),"complex64"===e.dtype?t.complexAbs(e):t.abs(e))),n,null,o.a)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(225),c=n(267),l=n(269);function d(t,e="float32"){if("complex64"===e){const e=d(t,"float32"),n=Object(l.a)(t,"float32");return Object(c.a)(e,n)}const n=Object(o.makeOnesTypedArray)(Object(o.sizeFromShape)(t),e);return r.a.makeTensor(n,t,e)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(221),d=n(230);const h=Object(l.a)({relu_:function(t){const e=Object(c.a)(t,"x","relu"),n={x:e};return r.a.runKernelFunc(((t,n)=>(n([e]),"bool"===e.dtype?Object(d.a)(e,"int32"):t.relu(e))),n,null,o.bc)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({log_:function(t){const e=Object(c.a)(t,"x","log"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.log(e);return n([e]),r}),n,null,o.wb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({step_:function(t,e=0){const n=Object(c.a)(t,"x","step"),l={x:n},d={alpha:e};return r.a.runKernelFunc((t=>t.step(n,e)),l,null,o.Cc,d)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return m}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(237),h=n(221),f=n(227);const m=Object(h.a)({depthwiseConv2d_:function(t,filter,e,n,h="NHWC",m=[1,1],y){const O=Object(c.a)(t,"x","depthwiseConv2d"),x=Object(c.a)(filter,"filter","depthwiseConv2d");let v=O,w=!1;3===O.rank&&(w=!0,v=Object(f.a)(O,[1,O.shape[0],O.shape[1],O.shape[2]])),l.assert(4===v.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${v.rank}.`)),l.assert(4===x.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${x.rank}.`)),l.assert(v.shape[3]===x.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${v.shape[3]}) must match the inChannels dimension in filter ${x.shape[2]}.`)),null!=y&&l.assert(l.isInt(n),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${y} but got pad ${n}.`));const j={x:v,filter:x},E={strides:e,pad:n,dataFormat:h,dilations:m,dimRoundingMode:y},$=r.a.runKernelFunc(((t,r)=>{null==m&&(m=[1,1]),l.assert(d.h(e,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${m}'`));const o=d.a(v.shape,x.shape,e,m,n,y,!0),c=t.depthwiseConv2D(v,x,o);return r([v,x]),c}),j,null,o.L,E);return w?Object(f.a)($,[$.shape[1],$.shape[2],$.shape[3]]):$}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(231),h=n(221);const f=Object(h.a)({equal_:function(a,b){let t=Object(l.a)(a,"a","equal"),e=Object(l.a)(b,"b","equal");[t,e]=Object(c.b)(t,e),Object(d.a)(t.shape,e.shape);const n={a:t,b:e};return r.a.runKernelFunc((n=>n.equal(t,e)),n,null,o.U)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return m}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(231),h=n(230),f=n(221);const m=Object(f.a)({maximum_:function(a,b){let t=Object(l.a)(a,"a","maximum"),e=Object(l.a)(b,"b","maximum");[t,e]=Object(c.b)(t,e),"bool"===t.dtype&&(t=Object(h.a)(t,"int32"),e=Object(h.a)(e,"int32")),Object(d.a)(t.shape,e.shape);const n={a:t,b:e};return r.a.runKernelFunc(((n,r)=>{const o=n.maximum(t,e);return r([t,e]),o}),n,null,o.Ib)}})},function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,"loaded",{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,"id",{enumerable:!0,get:function(){return t.i}}),t.webpackPolyfill=1),t}},function(t,e){(function(e){t.exports=e}).call(this,{})},,,,,,,,,,function(t,e,n){"use strict";n.d(e,"b",(function(){return d})),n.d(e,"a",(function(){return h})),n.d(e,"c",(function(){return f})),n.d(e,"e",(function(){return m})),n.d(e,"d",(function(){return y}));var r=n(244),o=n(413);const c=Object(o.a)("kernelRegistry",(()=>new Map)),l=Object(o.a)("gradRegistry",(()=>new Map));function d(t,e){const n=O(t,e);return c.get(n)}function h(t){return l.get(t)}function f(t){const e=c.entries(),n=[];for(;;){const{done:r,value:o}=e.next();if(r)break;const[c,l]=o,[d]=c.split("_");d===t&&n.push(l)}return n}function m(t){const{kernelName:e,backendName:n}=t,r=O(e,n);c.has(r)&&console.warn(`The kernel '${e}' for backend '${n}' is already registered`),c.set(r,t)}function y(t){const{kernelName:e}=t;l.has(e)&&Object(r.b)().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${e}'`),l.set(e,t)}function O(t,e){return`${e}_${t}`}},function(t,e,n){"use strict";(function(t){var e=n(363),r=n(244);const o=Object(r.b)();o.registerFlag("DEBUG",(()=>!1),(t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),o.registerFlag("IS_BROWSER",(()=>e.isBrowser())),o.registerFlag("IS_NODE",(()=>void 0!==t&&void 0!==t.versions&&void 0!==t.versions.node)),o.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),o.registerFlag("PROD",(()=>!1)),o.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>o.getBool("DEBUG"))),o.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),o.registerFlag("IS_TEST",(()=>!1))}).call(this,n(171))},function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(222),o=n(313);function c(t,e,n){const c=Object(r.c)(t,n);return Object(o.a)(t,e,c,n)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(224),o=n(225);function c(t,e,n,c){if(null==c&&(c=Object(o.inferDtype)(t)),"complex64"===c)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Object(o.isTypedArray)(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){Object(o.assertNonNegativeIntegerDimensions)(e);const t=Object(o.sizeFromShape)(e),r=Object(o.sizeFromShape)(n);Object(o.assert)(t===r,(()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${r}`));for(let i=0;i<n.length;++i){const t=n[i],r=i!==n.length-1||t!==Object(o.sizeFromShape)(e.slice(i));Object(o.assert)(n[i]===e[i]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `))}}return Object(o.isTypedArray)(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==c?Object(o.toTypedArray)(t,c):Object(o.flatten)(t,[],!0),r.a.makeTensor(t,e,c)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({imag_:function(input){const t=Object(c.a)(input,"input","imag"),e={input:t};return r.a.runKernelFunc((e=>e.imag(t)),e,null,o.nb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({real_:function(input){const t=Object(c.a)(input,"input","real"),e={input:t};return r.a.runKernelFunc((e=>e.real(t)),e,null,o.Zb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221);const h=Object(d.a)({unstack_:function(t,e=0){const n=Object(c.a)(t,"x","unstack");l.assert(e>=-n.shape.length&&e<n.shape.length,(()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`)),e<0&&(e+=n.shape.length);const d={value:n},h={axis:e};return r.a.runKernelFunc((t=>t.unstack(n,e)),d,null,o.Mc,h)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return m}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(286),h=n(221),f=n(227);const m=Object(h.a)({reverse_:function(t,e){const n=Object(c.a)(t,"x","reverse"),h={x:n},m={dims:e};return r.a.runKernelFunc((t=>{const r=Object(l.parseAxisParam)(e,n.shape);if(0===n.rank)return Object(d.a)(n);const o=t.reverse(n,r);return Object(f.a)(o,n.shape)}),h,null,o.ic,m)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221);const h=Object(d.a)({tile_:function(t,e){const n=Object(c.a)(t,"x","tile",null);l.assert(n.rank===e.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`));const d=[n],h={x:n},f={reps:e};return r.a.runKernelFunc(((t,r)=>{const o=t.tile(n,e);return r([n]),o}),h,null,o.Ic,f,d)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(231),h=n(221);const f=Object(h.a)({notEqual_:function(a,b){let t=Object(l.a)(a,"a","notEqual"),e=Object(l.a)(b,"b","notEqual");[t,e]=Object(c.b)(t,e),Object(d.a)(t.shape,e.shape);const n={a:t,b:e};return r.a.runKernelFunc((n=>n.notEqual(t,e)),n,null,o.Rb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return m}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(231),h=n(230),f=n(221);const m=Object(f.a)({minimum_:function(a,b){let t=Object(l.a)(a,"a","minimum"),e=Object(l.a)(b,"b","minimum");[t,e]=Object(c.b)(t,e),"bool"===t.dtype&&(t=Object(h.a)(t,"int32"),e=Object(h.a)(e,"int32")),Object(d.a)(t.shape,e.shape);const n={a:t,b:e};return r.a.runKernelFunc(((n,r)=>{const o=n.minimum(t,e);return r([t,e]),o}),n,null,o.Kb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(231),h=n(221);const f=Object(h.a)({squaredDifference_:function(a,b){let t=Object(l.a)(a,"a","squaredDifference"),e=Object(l.a)(b,"b","squaredDifference");[t,e]=Object(c.b)(t,e),Object(d.a)(t.shape,e.shape);const n={a:t,b:e};return r.a.runKernelFunc(((n,r)=>{const o=n.squaredDifference(t,e);return r([t,e]),o}),n,null,o.Bc,{})}})},function(t,e,n){"use strict";n.d(e,"c",(function(){return o})),n.d(e,"b",(function(){return c})),n.d(e,"a",(function(){return l}));var r=n(225);function o(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,c=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${o}.`;if(n.rank<o)throw new Error(c+` update.rank < ${o}. `);if(t.length<r+(n.rank-o))throw new Error(c+` Output shape length < ${r+(n.rank-o)}`);if(n.rank!==o+t.length-r)throw new Error(c+" update.rank != "+(o+t.length-r));for(let t=0;t<o;++t)if(n.shape[t]!==e.shape[t])throw new Error(c+` updates.shape[${t}] (${n.shape[t]}) != indices.shape[${t}] (${e.shape[t]}).`);for(let e=0;e<n.rank-o;++e)if(n.shape[e+o]!==t[e+r])throw new Error(c+` updates.shape[${e+o}] (${n.shape[e+o]}) != shape[${e+o}] (${t[e+o]})`)}function c(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}o(n,e,t)}function l(t,e,n){const o=e.shape.length,c=o>1?e.shape[o-1]:1,l=n.length;let d=1;for(let i=c;i<l;++i)d*=n[i];const h=c<1?1:c;return{sliceRank:c,numUpdates:Object(r.sizeFromShape)(e.shape)/h,sliceSize:d,strides:[...Object(r.computeStrides)(n.slice(0,c)),1],outputSize:Object(r.sizeFromShape)(n)}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221);const h=Object(d.a)({spaceToBatchND_:function(t,e,n){const d=Object(c.a)(t,"x","spaceToBatchND");l.assert(d.rank>=1+e.length,(()=>`input rank ${d.rank} should be > than [blockShape] ${e.length}`)),l.assert(n.length===e.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`)),l.assert(d.shape.reduce(((a,b,i)=>i>0&&i<=e.length?a&&(b+n[i-1][0]+n[i-1][1])%e[i-1]==0:a),!0),(()=>`input spatial dimensions ${d.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`));const h={x:d},f={blockShape:e,paddings:n};return r.a.runKernelFunc((t=>t.spaceToBatchND(d,e,n)),h,null,o.wc,f)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(231),h=n(221);const f=Object(h.a)({less_:function(a,b){let t=Object(l.a)(a,"a","less"),e=Object(l.a)(b,"b","less");[t,e]=Object(c.b)(t,e),Object(d.a)(t.shape,e.shape);const n={a:t,b:e};return r.a.runKernelFunc((n=>n.less(t,e)),n,null,o.tb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({logicalNot_:function(t){const e=Object(c.a)(t,"x","logicalNot","bool"),n={x:e};return r.a.runKernelFunc((t=>t.logicalNot(e)),n,null,o.Ab)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221);const h=Object(d.a)({batchToSpaceND_:function(t,e,n){const d=Object(c.a)(t,"x","batchToSpaceND"),h=e.reduce(((a,b)=>a*b));l.assert(d.rank>=1+e.length,(()=>`input rank is ${d.rank} but should be > than blockShape.length ${e.length}`)),l.assert(n.length===e.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`)),l.assert(d.shape[0]%h==0,(()=>`input tensor batch is ${d.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${h}`));const f={x:d},m={blockShape:e,crops:n};return r.a.runKernelFunc((t=>t.batchToSpaceND(d,e,n)),f,null,o.t,m)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));const r={};function o(t){return r[t]}},function(t,e,n){(function(t){(function(){"use strict";var e="function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,t){return a==Array.prototype||a==Object.prototype||(a[b]=t.value),a};var n=function(a){a=["object"==typeof globalThis&&globalThis,a,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof t&&t];for(var b=0;b<a.length;++b){var e=a[b];if(e&&e.Math==Math)return e}throw Error("Cannot find global object")}(this);var r="function"==typeof Object.assign?Object.assign:function(a,b){for(var t=1;t<arguments.length;t++){var e=arguments[t];if(e)for(var g in e)Object.prototype.hasOwnProperty.call(e,g)&&(a[g]=e[g])}return a};!function(a,b){if(b)t:{var t=n;a=a.split(".");for(var r=0;r<a.length-1;r++){var g=a[r];if(!(g in t))break t;t=t[g]}(b=b(r=t[a=a[a.length-1]]))!=r&&null!=b&&e(t,a,{configurable:!0,writable:!0,value:b})}}("Object.assign",(function(a){return a||r}));var o=this||self,c={facingMode:"user",width:640,height:480};function p(a,b){this.video=a,this.h=0,this.g=Object.assign(Object.assign({},c),b)}function q(a){window.requestAnimationFrame((function(){!function(a){var b=null;a.video.paused||a.video.currentTime===a.h||(a.h=a.video.currentTime,b=a.g.onFrame()),b?b.then((function(){q(a)})):q(a)}(a)}))}p.prototype.start=function(){var a=this;navigator.mediaDevices&&navigator.mediaDevices.getUserMedia||alert("No navigator.mediaDevices.getUserMedia exists.");var b=this.g;return navigator.mediaDevices.getUserMedia({video:{facingMode:b.facingMode,width:b.width,height:b.height}}).then((function(t){!function(a,b){a.video.srcObject=b,a.video.onloadedmetadata=function(){a.video.play(),q(a)}}(a,t)})).catch((function(t){throw console.error("Failed to acquire camera feed: "+t),alert("Failed to acquire camera feed: "+t),t}))};var l,u=["Camera"],d=o;u[0]in d||void 0===d.execScript||d.execScript("var "+u[0]);for(;u.length&&(l=u.shift());)u.length||void 0===p?d=d[l]&&d[l]!==Object.prototype[l]?d[l]:d[l]={}:d[l]=p}).call(this)}).call(this,n(33))},,,function(t,e,n){"use strict";n.d(e,"a",(function(){return r})),n.d(e,"b",(function(){return o}));class r{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class o{time(t){return c("time")}read(t){return c("read")}readSync(t){return c("readSync")}numDataIds(){return c("numDataIds")}disposeData(t){return c("disposeData")}write(t,e,n){return c("write")}move(t,e,n,r){return c("move")}memory(){return c("memory")}floatPrecision(){return c("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}batchMatMul(a,b,t,e){return c("batchMatMul")}fusedBatchMatMul({a:a,b:b,transposeA:t,transposeB:e,bias:n,activation:r,preluActivationWeights:o}){return c("fusedBatchMatMul")}slice(t,e,n){return c("slice")}stridedSlice(t,e,n,r){return c("stridedSlice")}unstack(t,e){return c("unstack")}reverse(a,t){return c("reverse")}concat(t,e){return c("concat")}neg(a){return c("neg")}add(a,b){return c("add")}addN(t){return c("addN")}subtract(a,b){return c("subtract")}multiply(a,b){return c("multiply")}realDivide(a,b){return c("realDivide")}floorDiv(a,b){return c("floorDiv")}sum(t,e){return c("sum")}prod(t,e){return c("prod")}unsortedSegmentSum(t,e,n){return c("unsortedSegmentSum")}argMin(t,e){return c("argMin")}argMax(t,e){return c("argMax")}equal(a,b){return c("equal")}notEqual(a,b){return c("notEqual")}less(a,b){return c("less")}lessEqual(a,b){return c("lessEqual")}greater(a,b){return c("greater")}greaterEqual(a,b){return c("greaterEqual")}logicalNot(a){return c("logicalNot")}logicalAnd(a,b){return c("logicalAnd")}logicalOr(a,b){return c("logicalOr")}where(t){return c("where")}select(t,a,b){return c("select")}topk(t,e,n){return c("topk")}min(t,e){return c("min")}minimum(a,b){return c("minimum")}mod(a,b){return c("mod")}max(t,e){return c("max")}maximum(a,b){return c("maximum")}all(t,e){return c("all")}any(t,e){return c("any")}squaredDifference(a,b){return c("squaredDifference")}ceil(t){return c("ceil")}floor(t){return c("floor")}round(t){return c("round")}sign(t){return c("sign")}isNaN(t){return c("isNaN")}isInf(t){return c("isInf")}isFinite(t){return c("isFinite")}pow(a,b){return c("pow")}exp(t){return c("exp")}expm1(t){return c("expm1")}softmax(t,e){return c("softmax")}log(t){return c("log")}log1p(t){return c("log1p")}sqrt(t){return c("sqrt")}rsqrt(t){return c("rsqrt")}square(t){return c("square")}reciprocal(t){return c("reciprocal")}relu(t){return c("relu")}relu6(t){return c("relu6")}prelu(t,a){return c("prelu")}elu(t){return c("elu")}eluDer(t,e){return c("eluDer")}selu(t){return c("selu")}int(t){return c("int")}clip(t,e,n){return c("clip")}abs(t){return c("abs")}complexAbs(t){return c("complexAbs")}sigmoid(t){return c("sigmoid")}softplus(t){return c("softplus")}sin(t){return c("sin")}cos(t){return c("cos")}tan(t){return c("tan")}asin(t){return c("asin")}acos(t){return c("acos")}atan(t){return c("atan")}atan2(a,b){return c("atan2")}sinh(t){return c("sinh")}cosh(t){return c("cosh")}tanh(t){return c("tanh")}asinh(t){return c("asinh")}acosh(t){return c("acosh")}atanh(t){return c("atanh")}erf(t){return c("erf")}step(t,e){return c("step")}fusedConv2d({input:input,filter:filter,convInfo:t,bias:e,activation:n,preluActivationWeights:r}){return c("fusedConv2d")}conv2d(t,filter,e){return c("conv2d")}conv2dDerInput(t,filter,e){return c("conv2dDerInput")}conv2dDerFilter(t,e,n){return c("conv2dDerFilter")}fusedDepthwiseConv2D({input:input,filter:filter,convInfo:t,bias:e,activation:n,preluActivationWeights:r}){return c("fusedDepthwiseConv2D")}depthwiseConv2D(input,filter,t){return c("depthwiseConv2D")}depthwiseConv2DDerInput(t,filter,e){return c("depthwiseConv2DDerInput")}depthwiseConv2DDerFilter(t,e,n){return c("depthwiseConv2DDerFilter")}conv3d(t,filter,e){return c("conv3d")}conv3dDerInput(t,filter,e){return c("conv3dDerInput")}conv3dDerFilter(t,e,n){return c("conv3dDerFilter")}maxPool(t,e){return c("maxPool")}maxPoolBackprop(t,e,n,r){return c("maxPoolBackprop")}avgPool(t,e){return c("avgPool")}avgPoolBackprop(t,e,n){return c("avgPoolBackprop")}avgPool3d(t,e){return c("avgPool3d")}avgPool3dBackprop(t,e,n){return c("avgPool3dBackprop")}maxPool3d(t,e){return c("maxPool3d")}maxPool3dBackprop(t,e,n,r){return c("maxPool3dBackprop")}reshape(t,e){return c("reshape")}cast(t,e){return c("cast")}tile(t,e){return c("tile")}pad(t,e,n){return c("pad")}transpose(t,e){return c("transpose")}gather(t,e,n){return c("gather")}gatherND(t,e){return c("gatherND")}scatterND(t,e,n){return c("scatterND")}batchToSpaceND(t,e,n){return c("batchToSpaceND")}spaceToBatchND(t,e,n){return c("spaceToBatchND")}resizeBilinear(t,e,n,r){return c("resizeBilinear")}resizeBilinearBackprop(t,e,n){return c("resizeBilinearBackprop")}resizeNearestNeighbor(t,e,n,r){return c("resizeNearestNeighbor")}resizeNearestNeighborBackprop(t,e,n){return c("resizeNearestNeighborBackprop")}batchNorm(t,e,n,r,o,l){return c("batchNorm")}localResponseNormalization4D(t,e,n,r,o){return c("localResponseNormalization4D")}LRNGrad(t,e,n,r,o,l,d){return c("LRNGrad")}multinomial(t,e,n,r){return c("multinomial")}oneHot(t,e,n,r){return c("oneHot")}cumsum(t,e,n,r){return c("cumsum")}nonMaxSuppression(t,e,n,r,o){return c("nonMaxSuppression")}fft(t){return c("fft")}ifft(t){return c("ifft")}complex(t,e){return c("complex")}real(input){return c("real")}imag(input){return c("imag")}cropAndResize(image,t,e,n,r,o){return c("cropAndResize")}depthToSpace(t,e,n){return c("depthToSpace")}split(t,e,n){return c("split")}sparseToDense(t,e,n,r){return c("sparseToDense")}diag(t){return c("diag")}fill(t,e,n){return c("fill")}onesLike(t){return c("onesLike")}zerosLike(t){return c("zerosLike")}linspace(t,e,n){return c("linspace")}dispose(){return c("dispose")}}function c(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(221);const h=Object(d.a)({floorDiv_:function(a,b){let t=Object(l.a)(a,"a","floorDiv"),e=Object(l.a)(b,"b","floorDiv");[t,e]=Object(c.b)(t,e);const n={a:t,b:e};return r.a.runKernelFunc(((n,r)=>{const o=n.floorDiv(t,e);return r([t,e]),o}),n,null,o.cb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({sigmoid_:function(t){const e=Object(c.a)(t,"x","sigmoid"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.sigmoid(e);return n([r]),r}),n,null,o.pc)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(225),l=n(221);const d=Object(l.a)({fft_:function(input){Object(c.assert)("complex64"===input.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${input.dtype}.`));const t={input:input};return r.a.runKernelFunc((t=>{const e=input.shape[input.shape.length-1],n=input.size/e,r=input.as2D(n,e);return t.fft(r).reshape(input.shape)}),t,null,o.Y)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(225),l=n(221),d=n(227);const h=Object(l.a)({ifft_:function(input){Object(c.assert)("complex64"===input.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${input.dtype}.`));const t={input:input};return r.a.runKernelFunc((t=>{const e=input.shape[input.shape.length-1],n=input.size/e,r=Object(d.a)(input,[n,e]),o=t.ifft(r);return Object(d.a)(o,input.shape)}),t,null,o.lb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return w}));var r=n(225),o=n(267),c=n(258),l=n(314),d=n(221),h=n(315),f=n(227),m=n(259),y=n(290),O=n(269),x=n(238),v=n(334);const w=Object(d.a)({rfft_:function(input,t){Object(r.assert)("float32"===input.dtype,(()=>`The dtype for rfft() must be real value but got ${input.dtype}`));let e=input.shape[input.shape.length-1];const n=input.size/e;let d;if(null!=t&&t<e){const n=input.shape.map((t=>0)),r=input.shape.map((t=>t));r[input.shape.length-1]=t,d=Object(m.a)(input,n,r),e=t}else if(null!=t&&t>e){const n=input.shape.map((t=>t));n[input.shape.length-1]=t-e,d=Object(c.a)([input,Object(O.a)(n)],input.shape.length-1),e=t}else d=input;const w=Object(x.a)(d),j=Object(f.a)(Object(o.a)(d,w),[n,e]),E=Object(v.a)(j),$=Math.floor(e/2)+1,C=Object(h.a)(E),N=Object(l.a)(E),R=Object(y.a)(C,[$,e-$],C.shape.length-1),S=Object(y.a)(N,[$,e-$],N.shape.length-1),T=d.shape.slice();return T[d.shape.length-1]=$,Object(f.a)(Object(o.a)(R[0],S[0]),T)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(224),o=n(220),c=n(222),l=n(286),d=n(221),h=n(227);const f=Object(d.a)({broadcastTo_:function(t,e){let input=Object(c.a)(t,"broadcastTo","x");const n=input.shape;if(e.some((t=>!(t>0)||t%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<input.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${input.rank}.`);if(e.length>input.rank){const t=input.shape.slice();for(;t.length<e.length;)t.unshift(1);input=Object(h.a)(input,t)}const d=input.shape,f=Array.from(e);for(let i=e.length-1;i>=0;i--)if(d[i]===e[i])f[i]=1;else if(1!==input.shape[i])throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${e}].`);if(0===f.map(((t,i)=>t>1?i:-1)).filter((i=>i>=0)).length)return Object(l.a)(input);const m={x:input},y={shape:e,inputShape:d};return r.a.runKernelFunc((t=>t.tile(input,f)),m,null,o.u,y)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(222),o=n(225),c=n(221),l=n(227);const d=Object(c.a)({squeeze_:function(t,e){const n=Object(r.a)(t,"x","squeeze");return Object(l.a)(n,Object(o.squeezeShape)(n.shape,e).newShape)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return E}));var r=n(222),o=n(225),c=n(291),l=n(239),d=n(287),h=n(340),f=n(221),m=n(281),y=n(227),O=n(232),x=n(272),v=n(250),w=n(236);function j(t,p,e=null){if(0===t.rank)return Object(c.a)(t);if(1!==t.rank&&null===e)return j(Object(y.a)(t,[-1]),p,e);if(1===t.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===p)return Object(w.a)(Object(c.a)(t),e);if(p===1/0)return Object(d.a)(Object(c.a)(t),e);if(p===-1/0)return Object(h.a)(Object(c.a)(t),e);if("euclidean"===p||2===p)return Object(x.a)(Object(w.a)(Object(m.a)(Object(c.a)(t),Object(O.a)(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${p}`)}if(Array.isArray(e)&&2===e.length){if(1===p)return Object(d.a)(Object(w.a)(Object(c.a)(t),e[0]),e[1]-1);if(p===1/0)return Object(d.a)(Object(w.a)(Object(c.a)(t),e[1]),e[0]);if(p===-1/0)return Object(h.a)(Object(w.a)(Object(c.a)(t),e[1]),e[0]);if("fro"===p||"euclidean"===p)return Object(x.a)(Object(w.a)(Object(v.a)(t),e));throw new Error(`Error in norm: invalid ord value: ${p}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const E=Object(f.a)({norm_:function(t,e="euclidean",n=null,c=!1){const d=j(t=Object(r.a)(t,"x","norm"),e,n);let h=d.shape;if(c){const e=Object(o.parseAxisParam)(n,t.shape);h=l.e(d.shape,e)}return Object(y.a)(d,h)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return y}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(239),h=n(221),f=n(227),m=n(241);const y=Object(h.a)({min_:function(t,e=null,n=!1){const h=Object(c.a)(t,"x","min"),y={x:h},O={axis:e,keepDims:n};return r.a.runKernelFunc(((t,r)=>{const o=Object(l.parseAxisParam)(e,h.shape);let c=o;const y=d.f(c,h.rank);let O=h;null!=y&&(O=Object(m.a)(h,y),c=d.g(c.length,h.rank));const x=t.min(O,c);null!=y&&O.dispose();let v=x;if(n){const t=d.e(v.shape,o);v=Object(f.a)(x,t),x.dispose()}return r([h,v]),v}),y,null,o.Jb,O)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return w}));var r=n(253),o=n(222),c=n(225),l=n(239),d=n(230),h=n(235),f=n(229),m=n(292),y=n(221),O=n(227),x=n(232),v=n(236);const w=Object(y.a)({mean_:function(t,e=null,n=!1){const y=Object(o.a)(t,"x","mean"),w=Object(c.parseAxisParam)(e,y.shape),j=Object(l.d)(y.shape,w)[1],E=Object(c.sizeFromShape)(j),$=Object(r.a)((t=>{const r=Object(x.a)(E),o=r.dtype===t.dtype?t:Object(d.a)(t,r.dtype),c=Object(h.a)(o,r);return{value:Object(v.a)(c,e,n),gradFunc:e=>{const n=t.shape.slice();w.forEach((t=>{n[t]=1}));const r=Object(O.a)(e,n);return Object(h.a)(Object(f.a)(r,Object(m.a)(t.shape,"float32")),E)}}}));return $(y)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return v}));var r=n(222),o=n(225),c=n(245),l=n(239),d=n(263),h=n(294),f=n(287),m=n(221),y=n(227),O=n(233),x=n(236);const v=Object(m.a)({logSumExp_:function(t,e=null,n=!1){const m=Object(r.a)(t,"x","logSumExp"),v=Object(o.parseAxisParam)(e,m.shape),w=Object(f.a)(m,v,!0),a=Object(O.a)(m,w),b=Object(d.a)(a),j=Object(x.a)(b,v),E=Object(h.a)(j),$=Object(c.a)(Object(y.a)(w,E.shape),E);if(n){const t=Object(l.e)($.shape,v);return Object(y.a)($,t)}return $}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({elu_:function(t){const e=Object(c.a)(t,"x","elu"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.elu(e);return n([r]),r}),n,null,o.S)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(230),d=n(221);const h=Object(d.a)({relu6_:function(t){const e=Object(c.a)(t,"x","relu6"),n={x:e};return r.a.runKernelFunc(((t,n)=>(n([e]),"bool"===e.dtype?Object(l.a)(e,"int32"):t.relu6(e))),n,null,o.cc)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({prelu_:function(t,e){const n=Object(c.a)(t,"x","prelu"),l=Object(c.a)(e,"alpha","prelu"),d={x:n,alpha:l};return r.a.runKernelFunc(((t,e)=>{const r=t.prelu(n,l);return e([n,l]),r}),d,null,o.Wb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(224),o=n(220),c=n(222),l=n(239),d=n(221),h=n(241);const f=Object(d.a)({cumsum_:function(t,e=0,n=!1,d=!1){const f=Object(c.a)(t,"x","cumsum"),m={x:f},y={axis:e,exclusive:n,reverse:d};return r.a.runKernelFunc(((t,r)=>{const o=Object(l.f)([e],f.rank);let c=f;null!=o&&(c=Object(h.a)(f,o));const m=Object(l.g)(1,f.rank)[0];let y=t.cumsum(c,m,n,d);if(r([f]),null!=o){const t=Object(l.h)(o);y=Object(h.a)(y,t)}return y}),m,null,o.J,y)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221);const h=Object(d.a)({unsortedSegmentSum_:function(t,e,n){const d=Object(c.a)(t,"x","unsortedSegmentSum"),h=Object(c.a)(e,"segmentIds","unsortedSegmentSum","int32");Object(l.assert)(Object(l.isInt)(n),(()=>"numSegments must be of dtype int"));const f={x:d,segmentIds:h},m={numSegments:n};return r.a.runKernelFunc(((t,e)=>{const r=t.unsortedSegmentSum(d,h,n);return e([h]),r}),f,null,o.Nc,m)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({cos_:function(t){const e=Object(c.a)(t,"x","cos"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.cos(e);return n([e]),r}),n,null,o.G)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({pad_:function(t,e,n=0){const l=Object(c.a)(t,"x","pad");if(0===l.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const d={paddings:e,constantValue:n},h={x:l};return r.a.runKernelFunc(((t,r)=>(r([l]),t.pad(l,e,n))),h,null,o.Ub,d)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return m}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221),h=n(227),f=n(377);const m=Object(d.a)({gather_:function(t,e,n=0){const d=Object(c.a)(t,"x","gather"),m=Object(c.a)(e,"indices","gather","int32"),y={x:d,indices:m},O={axis:n};return r.a.runKernelFunc(((t,e)=>{const r=Object(l.parseAxisParam)(n,d.shape)[0],o=Object(f.collectGatherOpShapeInfo)(d,m,r),c=t.gather(d,Object(h.a)(m,[m.size]),r);return e([d,m]),Object(h.a)(c,o.outputShape)}),y,null,o.ib,O)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(221);const h=Object(d.a)({mod_:function(a,b){let t=Object(l.a)(a,"a","mod"),e=Object(l.a)(b,"b","mod");[t,e]=Object(c.b)(t,e);const n={a:t,b:e};return r.a.runKernelFunc(((n,r)=>{const o=n.mod(t,e);return r([t,e]),o}),n,null,o.Lb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return y}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(230),h=n(237),f=n(221),m=n(227);const y=Object(f.a)({avgPool_:function(t,e,n,f,y){const O=Object(c.a)(t,"x","avgPool","float32");l.assert(h.h(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let x=O,v=!1;3===O.rank&&(v=!0,x=Object(m.a)(O,[1,O.shape[0],O.shape[1],O.shape[2]])),l.assert(4===x.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${x.rank}.`)),null!=y&&l.assert(l.isInt(f),(()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${y} but got pad ${f}.`));const w={x:x},j={filterSize:e,strides:n,pad:f,dimRoundingMode:y};let E=r.a.runKernelFunc(((t,r)=>{const o=h.e(x.shape,e,n,1,f,y);return r([x]),1===o.filterWidth&&1===o.filterHeight&&l.arraysEqual(o.inShape,o.outShape)?x.clone():t.avgPool(x,o)}),w,null,o.o,j);return E=Object(d.a)(E,O.dtype),v?Object(m.a)(E,[E.shape[1],E.shape[2],E.shape[3]]):E}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(231),d=n(221);const h=Object(d.a)({logicalOr_:function(a,b){const t=Object(c.a)(a,"a","logicalOr","bool"),e=Object(c.a)(b,"b","logicalOr","bool");Object(l.a)(t.shape,e.shape);const n={a:t,b:e};return r.a.runKernelFunc((n=>n.logicalOr(t,e)),n,null,o.Bb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return m}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(237),h=n(221),f=n(227);const m=Object(h.a)({maxPool_:function(t,e,n,h,m){const y=Object(c.a)(t,"x","maxPool");let O=y,x=!1;3===y.rank&&(x=!0,O=Object(f.a)(y,[1,y.shape[0],y.shape[1],y.shape[2]])),l.assert(4===O.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${O.rank}.`)),l.assert(d.h(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),null!=m&&l.assert(l.isInt(h),(()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${m} but got pad ${h}.`));const v={x:O},w={filterSize:e,strides:n,pad:h,dimRoundingMode:m},j=r.a.runKernelFunc(((t,r)=>{const o=d.e(O.shape,e,n,1,h,m);let c;return c=1===o.filterWidth&&1===o.filterHeight&&l.arraysEqual(o.inShape,o.outShape)?O.clone():t.maxPool(O,o),r([O,c]),c}),v,null,o.Db,w);return x?Object(f.a)(j,[j.shape[1],j.shape[2],j.shape[3]]):j}})},,,,,,,,function(t,e,n){var r;t.exports=(r=function(){function t(a){return n.appendChild(a.dom),a}function u(a){for(var t=0;t<n.children.length;t++)n.children[t].style.display=t===a?"block":"none";e=a}var e=0,n=document.createElement("div");n.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",n.addEventListener("click",(function(a){a.preventDefault(),u(++e%n.children.length)}),!1);var o=(performance||Date).now(),g=o,a=0,c=t(new r.Panel("FPS","#0ff","#002")),l=t(new r.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var d=t(new r.Panel("MB","#f08","#201"));return u(0),{REVISION:16,dom:n,addPanel:t,showPanel:u,begin:function(){o=(performance||Date).now()},end:function(){a++;var t=(performance||Date).now();if(l.update(t-o,200),t>g+1e3&&(c.update(1e3*a/(t-g),100),g=t,a=0,d)){var e=performance.memory;d.update(e.usedJSHeapSize/1048576,e.jsHeapSizeLimit/1048576)}return t},update:function(){o=this.end()},domElement:n,setMode:u}},r.Panel=function(t,e,n){var r=1/0,o=0,g=Math.round,a=g(window.devicePixelRatio||1),c=80*a,l=48*a,d=3*a,h=2*a,f=3*a,m=15*a,y=74*a,p=30*a,q=document.createElement("canvas");q.width=c,q.height=l,q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");return b.font="bold "+9*a+"px Helvetica,Arial,sans-serif",b.textBaseline="top",b.fillStyle=n,b.fillRect(0,0,c,l),b.fillStyle=e,b.fillText(t,d,h),b.fillRect(f,m,y,p),b.fillStyle=n,b.globalAlpha=.9,b.fillRect(f,m,y,p),{dom:q,update:function(l,O){r=Math.min(r,l),o=Math.max(o,l),b.fillStyle=n,b.globalAlpha=1,b.fillRect(0,0,c,m),b.fillStyle=e,b.fillText(g(l)+" "+t+" ("+g(r)+"-"+g(o)+")",d,h),b.drawImage(q,f+a,m,y-a,p,f,m,y-a,p),b.fillRect(f+y-a,m,a,p),b.fillStyle=n,b.globalAlpha=.9,b.fillRect(f+y-a,m,a,g((1-l/O)*p))}}},r)},function(t,e,n){"use strict";function r(){if("undefined"!=typeof navigator&&null!=navigator){const a=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))}return!1}function o(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}n.r(e),n.d(e,"isMobile",(function(){return r})),n.d(e,"isBrowser",(function(){return o}))},,,function(t,e,n){"use strict";function r(t,e=!1){console.log(t.toString(e))}n.d(e,"a",(function(){return r}))},function(t,e,n){"use strict";n.d(e,"a",(function(){return o})),n.d(e,"b",(function(){return c}));var r=n(225);function o(t,e){const n=t[0].length;t.forEach(((t,i)=>{r.assert(t.length===n,(()=>`Error in concat${n}D: rank of tensors[${i}] must be the same as the rank of the rest (${n})`))})),r.assert(e>=0&&e<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const o=t[0];t.forEach(((t,i)=>{for(let c=0;c<n;c++)r.assert(c===e||t[c]===o[c],(()=>`Error in concat${n}D: Shape of tensors[${i}] (${t}) does not match the shape of the rest (${o}) along the non-concatenated axis ${i}.`))}))}function c(t,e){const n=t[0].slice();for(let i=1;i<t.length;i++)n[e]+=t[i][e];return n}},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(225),l=n(288),d=n(269);function h(t,e,n=1,h="float32"){if(0===n)throw new Error("Cannot have a step of zero");const f={start:t,stop:e,step:n,dtype:h};return r.a.runKernelFunc((()=>{if(t===e||t<e&&n<0||e<t&&n>1)return Object(d.a)([0],h);const r=Math.abs(Math.ceil((e-t)/n)),o=Object(c.makeZerosTypedArray)(r,h);e<t&&1===n&&(n=-1),o[0]=t;for(let i=1;i<o.length;i++)o[i]=o[i-1]+n;return Object(l.a)(o,h)}),{},null,o.Yb,f)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(225);function o(t,e,n=0){let o=[];if("number"==typeof e)Object(r.assert)(t.shape[n]%e==0,(()=>"Number of splits must evenly divide the axis.")),o=new Array(e).fill(t.shape[n]/e);else{const c=e.reduce(((t,e)=>(-1===e&&(t+=1),t)),0);Object(r.assert)(c<=1,(()=>"There should be only one negative value in split array."));const l=e.indexOf(-1);if(-1!==l){const r=e.reduce(((a,b)=>b>0?a+b:a));e[l]=t.shape[n]-r}Object(r.assert)(t.shape[n]===e.reduce(((a,b)=>a+b)),(()=>"The sum of sizes must match the size of the axis dimension.")),o=e}return o}},function(t,e,n){"use strict";n.d(e,"a",(function(){return v}));var r=n(267),o=n(258),c=n(314),l=n(229),d=n(221),h=n(315),f=n(227),m=n(317),y=n(232),O=n(259),x=n(335);const v=Object(d.a)({irfft_:function(input){const t=input.shape[input.shape.length-1],e=input.size/t;let n;if(t<=2){const r=Object(f.a)(input,[e,t]);n=Object(x.a)(r)}else{const d=[e,2*(t-1)],v=Object(f.a)(Object(h.a)(input),[e,t]),w=Object(f.a)(Object(c.a)(input),[e,t]),j=Object(m.a)(Object(O.a)(v,[0,1],[e,t-2]),1),E=Object(l.a)(Object(m.a)(Object(O.a)(w,[0,1],[e,t-2]),1),Object(y.a)(-1)),$=Object(o.a)([v,j],1),i=Object(o.a)([w,E],1),C=Object(f.a)(Object(r.a)($,i),[d[0],d[1]]);n=Object(x.a)(C)}if(n=Object(h.a)(n),3===input.rank&&0!==input.shape[0]){const t=n,e=input.shape[0];n=Object(f.a)(n,[e,n.shape[0]/e,n.shape[1]]),t.dispose()}return n}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(224),o=n(220);function c(t,e,n){const c={shape:t,value:e,dtype:n};return r.a.runKernelFunc((r=>r.fill(t,e,n)),{},null,o.Z,c)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({log1p_:function(t){const e=Object(c.a)(t,"x","log1p"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.log1p(e);return n([e]),r}),n,null,o.xb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(224),o=n(220),c=n(225),l=n(237),d=n(221),h=n(227);const f=Object(d.a)({conv2DBackpropInput_:function(t,e,filter,n,d,f="NHWC",m){c.assert(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let y=t,O=e,x=!1;3===e.rank&&(x=!0,O=Object(h.a)(e,[1,e.shape[0],e.shape[1],e.shape[2]]),y=[1,t[0],t[1],t[2]]),c.assert(4===y.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${y.length}.`)),c.assert(4===O.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${O.rank}`)),c.assert(4===filter.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${filter.rank}`));const v="NHWC"===f?y[3]:y[1],w="NHWC"===f?O.shape[3]:O.shape[1];c.assert(v===filter.shape[2],(()=>`Error in conv2dDerInput: depth of input (${v}) must match input depth for filter ${filter.shape[2]}.`)),c.assert(w===filter.shape[3],(()=>`Error in conv2dDerInput: depth of output (${w}) must match output depth for filter ${filter.shape[3]}.`)),null!=m&&c.assert(c.isInt(d),(()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${m} but got pad ${d}.`));const j={dy:O,filter:filter},E={strides:n,pad:d,dataFormat:f,dimRoundingMode:m,inputShape:y},$=r.a.runKernelFunc(((t,e)=>{const r=l.g(f),o=l.a(y,filter.shape,n,1,d,m,!1,r),c=t.conv2dDerInput(O,filter,o);return e([O,filter]),c}),j,null,o.C,E);return x?Object(h.a)($,[$.shape[1],$.shape[2],$.shape[3]]):$}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(224),o=n(220),c=n(225),l=n(237),d=n(221),h=n(227);const f=Object(d.a)({conv2DBackpropFilter_:function(t,e,n,d,f,m="NHWC",y){let O=t;3===t.rank&&(O=Object(h.a)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let x=e;3===x.rank&&(x=Object(h.a)(e,[1,e.shape[0],e.shape[1],e.shape[2]])),c.assert(4===O.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${O.shape}.`)),c.assert(4===x.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${x.shape}.`)),c.assert(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const v="NHWC"===m?O.shape[3]:O.shape[1],w="NHWC"===m?x.shape[3]:x.shape[1];c.assert(v===n[2],(()=>`Error in conv2dDerFilter: depth of input ${v}) must match input depth in filter (${n[2]}.`)),c.assert(w===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${w}) must match output depth for filter (${n[3]}).`)),null!=y&&c.assert(c.isInt(f),(()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${y} but got pad ${f}.`));const j={x:O,dy:x},E={strides:d,pad:f,dataFormat:m,dimRoundingMode:y};return r.a.runKernelFunc((t=>{const e=l.g(m),r=l.a(O.shape,n,d,1,f,y,!1,e);return t.conv2dDerFilter(O,x,r)}),j,null,o.B,E)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(222),o=n(225),c=n(313);function l(t,e,n){if(Object(o.assertNonNull)(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const l=Object(r.c)(t,n);if(3!==l.length&&1!==l.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===l.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Object(c.a)(t,e,l,n)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o})),n.d(e,"b",(function(){return c}));var r=n(225);const o=30;function c(t){return t<=o?t:Object(r.nearestDivisor)(t,Math.floor(Math.sqrt(t)))}},function(t,e,n){"use strict";n.r(e),n.d(e,"segOpComputeOptimalWindowSize",(function(){return c})),n.d(e,"computeOutShape",(function(){return l})),n.d(e,"collectGatherOpShapeInfo",(function(){return d}));var r=n(225),o=n(376);function c(t,e){let n,c=!1;for(t<=o.a?(n=t,c=!0):n=Object(r.nearestDivisor)(t,Math.floor(Math.sqrt(t)));!c;)n>e||n===t?c=!0:n=Object(r.nearestDivisor)(t,n+1);return n}function l(t,e,n){const r=[],o=t.length;for(let c=0;c<o;c++)c!==e?r.push(t[c]):r.push(n);return r}function d(t,e,n){const r=t.shape[n],o=[];let c=1,l=1;for(let i=0;i<n;i++)o.push(t.shape[i]),c*=t.shape[i];for(let i=0;i<e.rank;i++)o.push(e.shape[i]);for(let i=n+1;i<t.rank;i++)o.push(t.shape[i]),l*=t.shape[i];return{batchSize:c,sliceSize:l,dimSize:r,outputShape:o}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return o}));var r=n(268);function o(t,e){const n=[];for(let i=0;i<e.length;i++)e[i]&&n.push(i);const o=Object(r.a)(t,"int32"),c=Object(r.a)([n.length,t.length],"int32");for(let i=0;i<n.length;i++){const e=o.indexToLoc(n[i]),r=i*t.length;c.values.set(e,r)}return c.toTensor()}},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({sin_:function(t){const e=Object(c.a)(t,"x","sin"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.sin(e);return n([e]),r}),n,null,o.rc)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({sinh_:function(t){const e=Object(c.a)(t,"x","sinh"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.sinh(e);return n([e]),r}),n,null,o.sc)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({rsqrt_:function(t){const e=Object(c.a)(t,"x","rsqrt"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.rsqrt(e);return n([e]),r}),n,null,o.lc)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({floor_:function(t){const e=Object(c.a)(t,"x","floor"),n={x:e};return r.a.runKernelFunc((t=>t.floor(e)),n,null,o.bb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({cosh_:function(t){const e=Object(c.a)(t,"x","cosh"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.cosh(e);return n([e]),r}),n,null,o.H)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return y}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(239),h=n(221),f=n(227),m=n(241);const y=Object(h.a)({all_:function(t,e=null,n=!1){let h=Object(c.a)(t,"x","all","bool");const y={x:h},O={axis:e,keepDims:n};return r.a.runKernelFunc((t=>{const r=Object(l.parseAxisParam)(e,h.shape);let o=r;const c=Object(d.f)(o,h.rank);null!=c&&(h=Object(m.a)(h,c),o=Object(d.g)(o.length,h.rank));const y=t.all(h,o);if(n){const t=Object(d.e)(y.shape,r);return Object(f.a)(y,t)}return y}),y,null,o.f,O)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return y}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(239),h=n(221),f=n(227),m=n(241);const y=Object(h.a)({any_:function(t,e=null,n=!1){let h=Object(c.a)(t,"x","any","bool");const y={x:h},O={axis:e,keepDims:n};return r.a.runKernelFunc((t=>{const r=Object(l.parseAxisParam)(e,h.shape);let o=r;const c=Object(d.f)(o,h.rank);null!=c&&(h=Object(m.a)(h,c),o=Object(d.g)(o.length,h.rank));const y=t.any(h,o);if(n){const t=Object(d.e)(y.shape,r);return Object(f.a)(y,t)}return y}),y,null,o.g,O)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return m}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(239),h=n(221),f=n(241);const m=Object(h.a)({argMax_:function(t,e=0){let n=Object(c.a)(t,"x","argMax");const h={x:n},m={axis:e};return r.a.runKernelFunc(((t,r)=>{r([n]);let o=l.parseAxisParam(e,n.shape);const c=d.f(o,n.rank);return null!=c&&(n=Object(f.a)(n,c),o=d.g(o.length,n.rank)),t.argMax(n,o[0])}),h,null,o.h,m)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return m}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(239),h=n(221),f=n(241);const m=Object(h.a)({argMin_:function(t,e=0){let n=Object(c.a)(t,"x","argMin");const h={x:n},m={axis:e};return r.a.runKernelFunc(((t,r)=>{r([n]),null==e&&(e=0);let o=l.parseAxisParam(e,n.shape);const c=d.f(o,n.rank);return null!=c&&(n=Object(f.a)(n,c),o=d.g(o.length,n.rank)),t.argMin(n,o[0])}),h,null,o.i,m)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(234),l=n(222),d=n(221);const h=Object(d.a)({atan2_:function(a,b){let t=Object(l.a)(a,"a","atan2"),e=Object(l.a)(b,"b","atan2");[t,e]=Object(c.b)(t,e);const n={a:t,b:e};return r.a.runKernelFunc(((n,r)=>{const o=n.atan2(t,e);return r([t,e]),o}),n,null,o.m)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(222),o=n(225),c=n(284),l=n(237),d=n(221),h=n(227);const f=Object(d.a)({conv1d_:function(t,filter,e,n,d="NWC",f=1,m){const y=Object(r.a)(t,"x","conv1d"),O=Object(r.a)(filter,"filter","conv1d");let x=y,v=!1;2===y.rank&&(v=!0,x=Object(h.a)(y,[1,y.shape[0],y.shape[1]])),o.assert(3===x.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${x.rank}.`)),o.assert(3===O.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${O.rank}.`)),null!=m&&o.assert(o.isInt(n),(()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${m} but got pad ${n}.`)),o.assert(x.shape[2]===O.shape[1],(()=>`Error in conv1d: depth of input (${x.shape[2]}) must match input depth for filter ${O.shape[1]}.`)),o.assert(l.h(e,f),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${f}'`)),o.assert("NWC"===d,(()=>`Error in conv1d: got dataFormat of ${d} but only NWC is currently supported.`));const w=Object(h.a)(O,[1,O.shape[0],O.shape[1],O.shape[2]]),j=Object(h.a)(x,[x.shape[0],1,x.shape[1],x.shape[2]]),E=[1,e],$=[1,f],C=Object(c.a)(j,w,E,n,"NHWC",$,m);return v?Object(h.a)(C,[C.shape[2],C.shape[3]]):Object(h.a)(C,[C.shape[0],C.shape[2],C.shape[3]])}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(222),o=n(373),c=n(221);const l=Object(c.a)({conv2dTranspose_:function(t,filter,e,n,c,l){const d=Object(r.a)(t,"x","conv2dTranspose"),h=Object(r.a)(filter,"filter","conv2dTranspose");return Object(o.a)(e,d,h,n,c,"NHWC",l)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221);const h=Object(d.a)({depthToSpace_:function(t,e,n="NHWC"){const d=Object(c.a)(t,"x","depthToSpace"),h="NHWC"===n?d.shape[1]:d.shape[2],f="NHWC"===n?d.shape[2]:d.shape[3],m="NHWC"===n?d.shape[3]:d.shape[1];l.assert(h*e>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${h} and ${e}  for depthToSpace with input shape\n    ${d.shape}`)),l.assert(f*e>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${f} and ${e} for depthToSpace with input shape\n        ${d.shape}`)),l.assert(m%(e*e)==0,(()=>`Dimension size must be evenly divisible by ${e*e} but is ${m} for depthToSpace with input shape ${d.shape}`));const y={x:d},O={blockSize:e,dataFormat:n};return r.a.runKernelFunc((t=>t.depthToSpace(d,e,n)),y,null,o.K,O)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221),h=n(227);const f=Object(d.a)({dilation2d_:function(t,filter,e,n,d=[1,1],f="NHWC"){const m=Object(c.a)(t,"x","dilation2d"),y=Object(c.a)(filter,"filter","dilation2d");l.assert(3===m.rank||4===m.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${m.rank}.`)),l.assert(3===y.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${y.rank}.`)),l.assert("NHWC"===f,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${f}`));let O=m,x=!1;3===m.rank&&(O=Object(h.a)(m,[1,m.shape[0],m.shape[1],m.shape[2]]),x=!0);const v={x:O,filter:y},w={strides:e,pad:n,dilations:d},j=r.a.runKernel(o.O,v,w);return x?Object(h.a)(j,[j.shape[1],j.shape[2],j.shape[3]]):j}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return m}));var r=n(234),o=n(222),c=n(235),l=n(297),d=n(221),h=n(260),f=n(238);const m=Object(d.a)({divNoNan_:function(a,b){let t=Object(o.a)(a,"a","div"),e=Object(o.a)(b,"b","div");[t,e]=Object(r.b)(t,e);const n=Object(c.a)(t,e),d=Object(f.a)(n),m=Object(l.a)(e,d);return Object(h.a)(m,d,n)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(222),o=n(225),c=n(282),l=n(221),d=n(227);const h=Object(l.a)({dot_:function(t,e){const n=Object(r.a)(t,"t1","dot"),l=Object(r.a)(e,"t2","dot");o.assert(!(1!==n.rank&&2!==n.rank||1!==l.rank&&2!==l.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${l.rank}.`));const h=1===n.rank?n.size:n.shape[1],f=1===l.rank?l.size:l.shape[0];if(o.assert(h===f,(()=>`Error in dot: inner dimensions of inputs must match, but got ${h} and ${f}.`)),1===n.rank&&1===l.rank){const t=Object(d.a)(n,[1,-1]),e=Object(d.a)(l,[-1,1]),r=Object(c.a)(t,e);return Object(d.a)(r,[])}if(1===n.rank&&2===l.rank){const t=Object(d.a)(n,[1,-1]),e=Object(d.a)(l,[l.shape[0],l.shape[1]]),r=Object(c.a)(t,e);return Object(d.a)(r,[r.size])}if(2===n.rank&&1===l.rank){const t=Object(d.a)(l,[-1,1]),e=Object(c.a)(n,t);return Object(d.a)(e,[e.size])}{const t=Object(d.a)(l,[l.shape[0],l.shape[1]]);return Object(c.a)(n,t)}}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(222),o=n(298),c=n(229),l=n(221),d=n(232);const h=Object(l.a)({leakyRelu_:function(t,e=.2){const n=Object(r.a)(t,"x","leakyRelu");return Object(o.a)(Object(c.a)(Object(d.a)(e),n),n)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221),h=n(227);const f=Object(d.a)({localResponseNormalization_:function(t,e=5,n=1,d=1,f=.5){const m=Object(c.a)(t,"x","localResponseNormalization");l.assert(4===m.rank||3===m.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${m.rank}.`)),l.assert(l.isInt(e),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`));let y=m,O=!1;3===m.rank&&(O=!0,y=Object(h.a)(m,[1,m.shape[0],m.shape[1],m.shape[2]]));const x={x:y},v={depthRadius:e,bias:n,alpha:d,beta:f},w=r.a.runKernelFunc(((t,r)=>{const o=t.localResponseNormalization4D(y,e,n,d,f);return r([y,o]),o}),x,null,o.rb,v);return O?Object(h.a)(w,[w.shape[1],w.shape[2],w.shape[3]]):w}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({softplus_:function(t){const e=Object(c.a)(t,"x","softplus"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.softplus(e);return n([e]),r}),n,null,o.vc)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(222),o=n(231),c=n(280),l=n(325),d=n(353),h=n(221);const f=Object(h.a)({logicalXor_:function(a,b){const t=Object(r.a)(a,"a","logicalXor","bool"),e=Object(r.a)(b,"b","logicalXor","bool");return Object(o.a)(t.shape,e.shape),Object(c.a)(Object(d.a)(a,b),Object(l.a)(Object(c.a)(a,b)))}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(221),d=n(227);const h=Object(l.a)({oneHot_:function(t,e,n=1,l=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const h=Object(c.a)(t,"indices","oneHot","int32"),f=[...h.shape,e],m={indices:h},y={depth:e,onValue:n,offValue:l};return r.a.runKernelFunc(((t,r)=>(r([h]),Object(d.a)(t.oneHot(Object(d.a)(h,[h.size]),e,n,l),f))),m,null,o.Sb,y)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return O}));var r=n(222),o=n(225),c=n(352),l=n(326),d=n(237),h=n(354),f=n(221),m=n(227),y=n(323);const O=Object(f.a)({pool_:function(input,t,e,n,f,O){null==f&&(f=[1,1]),null==O&&(O=1),0===n&&(n="valid");const x=Object(r.a)(input,"x","maxPool");let v=x,w=!1;3===x.rank&&(w=!0,v=Object(m.a)(x,[1,x.shape[0],x.shape[1],x.shape[2]])),o.assert(d.h(O,f),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${O} and dilations '${f}'`));const j=d.e(v.shape,t,O,f,n),E=[j.dilationHeight,j.dilationWidth];let $;$="same"===n?function(t,e){const n=t.map(((s,i)=>s+(s-1)*(e[i]-1))).map((s=>s-1)),r=n.map((s=>Math.floor(s/2))),o=n.map(((s,i)=>s-r[i]));return n.map(((t,i)=>[r[i],o[i]]))}([j.filterHeight,j.filterWidth],E):[[0,0],[0,0]];const C=1===E[0]&&1===E[1],[N,R]=function(t,e,n){const r=n.map((b=>b[0])),o=n.map((b=>b[1])),c=t.concat(r,o),l=e.map(((b,i)=>(b-c[i]%b)%b)),d=o.map(((s,i)=>s+l[i])),h=e.map(((t,i)=>[r[i],d[i]])),f=e.map(((t,i)=>[0,l[i]]));return[h,f]}([j.inHeight,j.inWidth],E,$),S=C?n:"valid",T=C?v:Object(y.a)(v,E,N),I=("avg"===e?()=>Object(c.a)(T,t,O,S):()=>Object(h.a)(T,t,O,S))(),A=C?I:Object(l.a)(I,E,R);return w?Object(m.a)(A,[A.shape[1],A.shape[2],A.shape[3]]):A}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return O}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(239),h=n(230),f=n(221),m=n(227),y=n(241);const O=Object(f.a)({prod_:function(t,e=null,n=!1){let f=Object(c.a)(t,"x","prod");const O={x:f},x={axis:e,keepDims:n};return r.a.runKernelFunc((t=>{"bool"===f.dtype&&(f=Object(h.a)(f,"int32"));const r=Object(l.parseAxisParam)(e,f.shape),o=Object(d.f)(r,f.rank);let c=r,O=f;null!=o&&(O=Object(y.a)(f,o),c=Object(d.g)(c.length,f.rank));let x=t.prod(O,c);if(n){const t=Object(d.e)(x.shape,r);x=Object(m.a)(x,t)}return x}),O,null,o.Xb,x)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({selu_:function(t){const e=Object(c.a)(t,"x","selu"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.selu(e);return n([e]),r}),n,null,o.oc)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(222),o=n(225),c=n(284),l=n(296),d=n(221),h=n(227);const f=Object(d.a)({separableConv2d_:function(t,e,n,d,f,m=[1,1],y="NHWC"){const O=Object(r.a)(t,"x","separableConv2d"),x=Object(r.a)(e,"depthwiseFilter","separableConv2d"),v=Object(r.a)(n,"pointwiseFilter","separableConv2d");let w=O,j=!1;if(3===O.rank&&(j=!0,w=Object(h.a)(O,[1,O.shape[0],O.shape[1],O.shape[2]])),"NCHW"===y)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");o.assert(4===w.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${w.rank}.`)),o.assert(4===x.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${x.rank}.`)),o.assert(4===v.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${x.rank}.`)),o.assert(1===v.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${v.shape[0]}.`)),o.assert(1===v.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${v.shape[1]}.`));const E=x.shape[2],$=x.shape[3];o.assert(v.shape[2]===E*$,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${E*$}, but got ${v.shape[2]}.`));const C=Object(l.a)(w,x,d,f,y,m),N=Object(c.a)(C,v,1,"valid",y);return j?Object(h.a)(N,[N.shape[1],N.shape[2],N.shape[3]]):N}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({topk_:function(t,e=1,n=!0){const l=Object(c.a)(t,"x","topk");if(0===l.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const d=l.shape[l.shape.length-1];if(e>d)throw new Error(`'k' passed to topk() must be <= the last dimension (${d}) but got ${e}`);const h={x:l},f={k:e,sorted:n},[m,y]=r.a.runKernelFunc((b=>b.topk(l,e,n)),h,null,o.Jc,f);return{values:m,indices:y}}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221);const h=Object(d.a)({unique_:function(t,e=0){const n=Object(c.a)(t,"x","unique",null);Object(l.assert)(n.rank>0,(()=>"The input tensor must be at least 1D"));const d={x:n},h={axis:e},[f,m]=r.a.runKernel(o.Lc,d,h);return{values:f,indices:m}}})},,function(t,e,n){"use strict";n.d(e,"b",(function(){return o})),n.d(e,"a",(function(){return c}));var r=n(224);n(222),n(225);function o(){return 32===r.a.backend.floatPrecision()?.001:.1}function c(a,t,e){if(null==e&&(e=o()),!l(a,t,e))throw new Error(`Numbers differ: actual === ${a}, expected === ${t}`)}function l(a,t,e){return!isFinite(a)&&!isFinite(t)||!(isNaN(a)||isNaN(t)||Math.abs(a-t)>e)}},function(t,e,n){"use strict";var r={};n.r(r),n.d(r,"simpleAbsImpl",(function(){return X})),n.d(r,"addImpl",(function(){return st})),n.d(r,"ceilImpl",(function(){return ut})),n.d(r,"expImpl",(function(){return lt})),n.d(r,"expm1Impl",(function(){return pt})),n.d(r,"floorImpl",(function(){return ht})),n.d(r,"logImpl",(function(){return ft})),n.d(r,"maxImpl",(function(){return mt})),n.d(r,"multiplyImpl",(function(){return bt})),n.d(r,"rsqrtImpl",(function(){return yt})),n.d(r,"sliceImpl",(function(){return Ot})),n.d(r,"subImpl",(function(){return xt})),n.d(r,"transposeImpl",(function(){return wt})),n.d(r,"uniqueImpl",(function(){return jt}));var o=n(226);const c={},l={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function d(t){if(!(t in c)){const e=function(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const canvas=function(t){if("undefined"!=typeof OffscreenCanvas&&2===t)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);if(canvas.addEventListener("webglcontextlost",(e=>{e.preventDefault(),delete c[t]}),!1),1===t)return canvas.getContext("webgl",l)||canvas.getContext("experimental-webgl",l);return canvas.getContext("webgl2",l)}(t);if(null===e)return console.log("Could not get context for WebGL version",t),null;c[t]=e}const e=c[t];return e.isContextLost()?(delete c[t],d(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),c[t])}var h,f,m;function y(t,e){return[e,t]}function O(t){const e=o.Eb.sizeFromShape(t),n=Math.ceil(e/4);return o.Eb.sizeToSquarishShape(n)}function x(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function v(t,e){const n=t;let r,c,l,d,h,f,m,y,O,x;return 2===Object(o.bb)().getNumber("WEBGL_VERSION")?(r=n.R32F,c=n.R16F,l=n.RGBA16F,d=n.RGBA32F,h=n.RED,m=4,y=1,O=n.HALF_FLOAT,x=n.FLOAT):(r=t.RGBA,c=t.RGBA,l=t.RGBA,d=n.RGBA,h=t.RGBA,m=4,y=4,O=null!=e?e.HALF_FLOAT_OES:null,x=t.FLOAT),f=t.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:c,internalFormatPackedHalfFloat:l,internalFormatPackedFloat:d,textureFormatFloat:h,downloadTextureFormat:f,downloadUnpackNumChannels:m,defaultNumChannels:y,textureTypeHalfFloat:O,textureTypeFloat:x}}function w(t,e){const n=e();return Object(o.bb)().getBool("DEBUG")&&function(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+function(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}(t,e))}(t),n}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(h||(h={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(f||(f={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(m||(m={}));function j(t){return!!(Object(o.bb)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function E(t,e){return k(t,(()=>t.getExtension(e)),'Extension "'+e+'" not supported on this browser.')}function $(t,e){const n=k(t,(()=>t.createShader(t.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(w(t,(()=>t.shaderSource(n,e))),w(t,(()=>t.compileShader(n))),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw function(t,e){const n=C.exec(e);if(null==n)return console.log(`Couldn't parse line number in error: ${e}`),void console.log(t);const r=+n[1],c=t.split("\n"),l=c.length.toString().length+2,d=c.map(((line,t)=>o.Eb.rightPad((t+1).toString(),l)+line));let h=0;for(let i=0;i<d.length;i++)h=Math.max(d[i].length,h);const f=d.slice(0,r-1),m=d.slice(r-1,r),y=d.slice(r);console.log(f.join("\n")),console.log(e.split("\n")[0]),console.log(`%c ${o.Eb.rightPad(m[0],h)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(y.join("\n"))}(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const C=/ERROR: [0-9]+:([0-9]+):/g;function N(t,e){if(w(t,(()=>t.validateProgram(e))),!1===t.getProgramParameter(e,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function R(t,e,n,r,o,c,l){const d=t.getAttribLocation(e,n);return-1!==d&&(w(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,r))),w(t,(()=>t.vertexAttribPointer(d,o,t.FLOAT,!1,c,l))),w(t,(()=>t.enableVertexAttribArray(d))),!0)}function S(t,e,n,r){w(t,(()=>function(t,e,n){D(t,n),w(t,(()=>t.activeTexture(t.TEXTURE0+n))),w(t,(()=>t.bindTexture(t.TEXTURE_2D,e)))}(t,e,r))),w(t,(()=>t.uniform1i(n,r)))}function T(t,e,n){w(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,n))),w(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0)))}function I(t,e){w(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,e))),w(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0)))}function A(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}(t,e))}function k(t,e,n){const r=w(t,(()=>e()));if(null==r)throw new Error(n);return r}function D(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function _(t,e=2){return o.Eb.sizeFromShape(t.slice(0,t.length-e))}function F(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function P(t){let e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[_(t),...F(t)]),e}function M(t){return t%2==0}function B(t,e){if(t=t.slice(-2),e=e.slice(-2),o.Eb.arraysEqual(t,e))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){const n=t.slice(-1)[0],r=e.slice(-1)[0];if(n===r)return!0;if(M(n)&&M(r)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&M(t[0])&&M(e[0])}let L,V;function z(t,e){return null!=t.getExtension(e)}function U(t){try{if(null!=d(t))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function W(t){if(0===t)return!1;const e=d(t);if(1!==t){if(z(e,"EXT_color_buffer_float"))return G(e);const t="EXT_color_buffer_half_float";if(z(e,t)){const n=e.getExtension(t);return function(t,e){const n=v(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r);const o=1,c=1;t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,o,c,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const l=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,l),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const d=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(l),d}(e,n)}return!1}if(!z(e,"OES_texture_float"))return!1;if(!z(e,"WEBGL_color_buffer_float"))return!1;return G(e)}function G(t){const e=v(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n);t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const o=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(r),o}function H(t,e){Array.isArray(t)||(t=[t]),t.forEach((t=>{null!=t&&o.Eb.assert("complex64"!==t.dtype,(()=>`${e} does not support complex64 tensors in the WebGL backend.`))}))}const K=Object(o.bb)();function X(t){const e=new Float32Array(t.length);for(let i=0;i<t.length;++i)e[i]=Math.abs(t[i]);return e}K.registerFlag("HAS_WEBGL",(()=>K.getNumber("WEBGL_VERSION")>0)),K.registerFlag("WEBGL_VERSION",(()=>U(2)?2:U(1)?1:0)),K.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),K.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===K.get("WEBGL_VERSION"))),K.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),K.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),K.registerFlag("WEBGL_PACK",(()=>K.getBool("HAS_WEBGL"))),K.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>K.getBool("WEBGL_PACK"))),K.registerFlag("WEBGL_PACK_CLIP",(()=>K.getBool("WEBGL_PACK"))),K.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>!1)),K.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>K.getBool("WEBGL_PACK"))),K.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>K.getBool("WEBGL_PACK"))),K.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>K.getBool("WEBGL_PACK"))),K.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>K.getBool("WEBGL_PACK"))),K.registerFlag("WEBGL_PACK_REDUCE",(()=>K.getBool("WEBGL_PACK"))),K.registerFlag("WEBGL_LAZILY_UNPACK",(()=>K.getBool("WEBGL_PACK"))),K.registerFlag("WEBGL_CONV_IM2COL",(()=>K.getBool("WEBGL_PACK"))),K.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(t){if(null==L){const e=d(t);L=e.getParameter(e.MAX_TEXTURE_SIZE)}return L}(K.getNumber("WEBGL_VERSION")))),K.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(t){if(null==V){const e=d(t);V=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,V)}(K.getNumber("WEBGL_VERSION")))),K.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const t=K.getNumber("WEBGL_VERSION");return 0===t?0:function(t){if(0===t)return 0;let e;const n=d(t);return e=z(n,"EXT_disjoint_timer_query_webgl2")&&2===t?2:z(n,"EXT_disjoint_timer_query")?1:0,e}(t)})),K.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>K.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!o.Y.isMobile())),K.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(t){if(0===t)return!1;const e=d(t);if(1===t){if(!z(e,"OES_texture_float"))return!1}else if(!z(e,"EXT_color_buffer_float"))return!1;return G(e)}(K.getNumber("WEBGL_VERSION")))),K.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!K.getBool("WEBGL_FORCE_F16_TEXTURES")&&K.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),K.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>W(K.getNumber("WEBGL_VERSION")))),K.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(t=K.getNumber("WEBGL_VERSION"))&&null!=d(t).fenceSync;var t})),K.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>K.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),K.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)}));o.a;function Y(t){return(e,n,r,c,l)=>{const d=o.R.assertAndGetBroadcastShape(e,n),h=d.length,f=o.Eb.computeStrides(d),m=o.Eb.sizeFromShape(d),y=o.Eb.getTypedArrayFromDType(l,m),O=e.length,x=n.length,v=o.Eb.computeStrides(e),w=o.Eb.computeStrides(n),j=o.R.getBroadcastDims(e,d),E=o.R.getBroadcastDims(n,d);if(j.length+E.length===0)for(let i=0;i<y.length;++i)y[i]=t(r[i%r.length],c[i%c.length]);else for(let i=0;i<y.length;++i){const e=o.Eb.indexToLoc(i,h,f),n=e.slice(-O);j.forEach((t=>n[t]=0));const l=o.Eb.locToIndex(n,O,v),d=e.slice(-x);E.forEach((t=>d[t]=0));const m=o.Eb.locToIndex(d,x,w);y[i]=t(r[l],c[m])}return[y,d]}}function Q(t,e){Array.isArray(t)||(t=[t]),t.forEach((t=>{null!=t&&o.Eb.assert("complex64"!==t.dtype,(()=>`${e} does not support complex64 tensors in the CPU backend.`))}))}function J(t){const{inputs:e,backend:n}=t,{real:r,imag:o}=e,c=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,d=n.makeTensorInfo(r.shape,"complex64");return n.data.get(d.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",c),imag:n.makeTensorInfo(o.shape,"float32",l)},d}o.h;function Z(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}o.r;function tt(t){const{inputs:e,backend:n}=t,{input:input}=e,r=n.data.get(input.dataId).complexTensorInfos.real,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}o.C;function et(t){const{inputs:e,backend:n,attrs:r}=t,{x:c}=e,{dtype:l}=r;if("complex64"===l){if("complex64"===c.dtype)return Z({inputs:{x:c},backend:n});const t=o.Fb(c.shape),e=et({inputs:{x:c},backend:n,attrs:{dtype:"float32"}}),r=J({inputs:{real:e,imag:t},backend:n});return t.dispose(),n.disposeIntermediateTensorInfo(e),r}if("complex64"===c.dtype){const t=tt({inputs:{input:c},backend:n}),e=et({inputs:{x:t},backend:n,attrs:{dtype:l}});return n.disposeIntermediateTensorInfo(t),e}if(!o.Eb.hasEncodingLoss(c.dtype,l)){const t=Z({inputs:{x:c},backend:n});return{dataId:t.dataId,shape:t.shape,dtype:l}}if("int32"===l){const t=n.data.get(c.dataId).values,e=Int32Array.from(t);return n.makeTensorInfo(c.shape,"int32",e)}if("bool"===l){const t=n.data.get(c.dataId).values,e=o.Eb.toTypedArray([0],c.dtype),[r,l]=Y(((a,b)=>a!==b?1:0))(c.shape,[],t,e,"bool");return n.makeTensorInfo(l,"bool",r)}throw new Error(`Error in Cast: failed to cast ${c.dtype} to ${l}`)}o.f;function nt(t,e,n,r){return null==n?({inputs:n,backend:o})=>{const{a:a,b:b}=n,c=o;Q([a,b],t);const l=c.data.get(a.dataId).values,d=c.data.get(b.dataId).values,h=r||a.dtype,[f,m]=e(a.shape,b.shape,l,d,h);return c.makeTensorInfo(m,h,f)}:({inputs:t,backend:o})=>{const{a:a,b:b}=t,c=o;if("complex64"===a.dtype||"complex64"===b.dtype){const t=et({inputs:{x:a},backend:c,attrs:{dtype:"complex64"}}),e=c.data.get(t.dataId),r=e.complexTensorInfos.real,o=e.complexTensorInfos.imag,l=c.data.get(r.dataId).values,d=c.data.get(o.dataId).values,h=et({inputs:{x:b},backend:c,attrs:{dtype:"complex64"}}),f=c.data.get(h.dataId),m=f.complexTensorInfos.real,y=f.complexTensorInfos.imag,O=c.data.get(m.dataId).values,x=c.data.get(y.dataId).values,[v,w,j]=n(a.shape,b.shape,l,d,O,x),E=c.makeTensorInfo(j,"float32",v),$=c.makeTensorInfo(j,"float32",w),C=J({inputs:{real:E,imag:$},backend:c});return c.disposeIntermediateTensorInfo(t),c.disposeIntermediateTensorInfo(h),c.disposeIntermediateTensorInfo(E),c.disposeIntermediateTensorInfo($),C}{const t=c.data.get(a.dataId).values,n=c.data.get(b.dataId).values,o=r||a.dtype,[l,d]=e(a.shape,b.shape,t,n,o);return c.makeTensorInfo(d,o,l)}}}function at(t){return(e,n,r,c,l,d)=>{const h=o.R.assertAndGetBroadcastShape(e,n),f=o.Eb.sizeFromShape(h),m=h.length,y=o.Eb.computeStrides(h),O=o.Eb.getTypedArrayFromDType("float32",f),x=o.Eb.getTypedArrayFromDType("float32",f),v=o.R.getBroadcastDims(e,h),w=o.R.getBroadcastDims(n,h),j=o.R.mergeRealAndImagArrays(r,c),E=o.R.mergeRealAndImagArrays(l,d),$=e.length,C=o.Eb.computeStrides(e),N=n.length,R=o.Eb.computeStrides(n);if(v.length+w.length===0)for(let i=0;i<O.length;i++){const e=i%j.length,n=i%E.length,r=t(j[2*e],j[2*e+1],E[2*n],E[2*n+1]);O[i]=r.real,x[i]=r.imag}else for(let i=0;i<O.length;i++){const e=o.Eb.indexToLoc(i,m,y),n=e.slice(-$);v.forEach((t=>n[t]=0));const r=o.Eb.locToIndex(n,$,C),c=e.slice(-N);w.forEach((t=>c[t]=0));const l=o.Eb.locToIndex(c,N,R),d=t(j[2*r],j[2*r+1],E[2*l],E[2*l+1]);O[i]=d.real,x[i]=d.imag}return[O,x,h]}}const st=Y(((a,b)=>a+b)),ot=at(((t,e,n,r)=>({real:t+n,imag:e+r})));nt(o.b,st,ot),o.b;function it(t){return(e,n,r)=>{const c=o.Eb.getTypedArrayFromDType(n,e.length);for(let i=0;i<e.length;++i)c[i]=t(e[i],r);return c}}function ct(t,e,n){return({inputs:r,attrs:o,backend:c})=>{const{x:l}=r;if(Q(l,t),"string"===l.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const d=c,h=d.data.get(l.dataId).values,f=n||l.dtype,m=e(h,f,o);return d.makeTensorInfo(l.shape,f,m)}}const ut=it((t=>Math.ceil(t))),lt=(ct(o.g,ut),o.g,it((t=>Math.exp(t)))),pt=(ct(o.l,lt),o.l,it((t=>Math.expm1(t)))),ht=(ct(o.m,pt),o.m,it((t=>Math.floor(t)))),ft=(ct(o.o,ht),o.o,it((t=>Math.log(t))));ct(o.t,ft),o.t;function mt(t,e,n,r){const c=o.Eb.getTypedArrayFromDType(r,o.Eb.sizeFromShape(n));for(let i=0;i<c.length;++i){const n=i*e;let r=t[n];for(let o=0;o<e;++o){const e=t[n+o];e>r&&(r=e)}c[i]=r}return c}const bt=Y(((t,e)=>t*e)),gt=at(((t,e,n,r)=>({real:t*n-e*r,imag:t*r+e*n}))),yt=(nt(o.y,bt,gt),o.y,it((t=>1/Math.sqrt(t))));ct(o.F,yt),o.F;function Ot(t,e,n,r,c){const l=o.sb.isSliceContinous(r,e,n),d=o.Eb.sizeFromShape(n),h=o.Eb.computeStrides(r);if(l){const n=o.sb.computeFlatOffset(e,h);return t.subarray(n,n+d)}const f=o.Eb.getTypedArrayFromDType(c,d);for(let i=0;i<d;++i){const c=n.length,l=o.Eb.computeStrides(n),d=o.Eb.indexToLoc(i,c,l).map(((t,n)=>t+e[n])),m=o.Eb.locToIndex(d,r.length,h);f[i]=t[m]}return f}o.H;const xt=Y(((t,e)=>t-e)),vt=at(((t,e,n,r)=>({real:t-n,imag:e-r})));nt(o.K,xt,vt),o.K;function wt(t,e,n,r,c){const l=e.length,d=o.Eb.sizeFromShape(e),h=o.Eb.computeStrides(e),f=o.Eb.computeStrides(c),m=o.Eb.getTypedArrayFromDType(n,o.Eb.sizeFromShape(c));for(let i=0;i<d;++i){const e=o.Eb.indexToLoc(i,l,h),n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[r[i]];m[o.Eb.locToIndex(n,l,f)]=t[i]}return m}function jt(t,e,n,r){const c=o.Eb.parseAxisParam(e,n)[0],l=[1,n[0],1];for(let i=0;i<c;i++)l[0]*=n[i];l[1]=n[c];for(let i=c+1;i<n.length;i++)l[2]*=n[i];const d={},h=new Int32Array(n[c]),f=new o.N(l,r,t),m=[],y=1===l[0]&&1===l[2];for(let i=0;i<n[c];i++){let element;if(y)element=t[i].toString();else{const t=[];for(let e=0;e<l[0];e++)for(let n=0;n<l[2];n++)t.push(f.get(e,i,n));element=t.join(",")}if(void 0!==d[element])h[i]=d[element];else{const t=Object.keys(d).length;d[element]=t,h[i]=t,m.push(i)}}const O=l.slice();O[1]=Object.keys(d).length;const x=new o.N(O,r);m.forEach(((t,i)=>{for(let e=0;e<l[0];e++)for(let n=0;n<l[2];n++)x.set(f.get(e,t,n),e,i,n)}));const v=n.slice();return v[c]=O[1],{outputValues:x.values,outputShape:v,indices:h}}const{simpleAbsImpl:Et,addImpl:$t,ceilImpl:Ct,expImpl:Nt,expm1Impl:Rt,floorImpl:St,logImpl:Tt,maxImpl:It,multiplyImpl:At,rsqrtImpl:kt,sliceImpl:Dt,subImpl:_t,transposeImpl:Ft,uniqueImpl:Pt}=r;class Mt{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map(((t,i)=>`T${i}`));const n=[];this.variableNames.forEach((t=>{n.push(`float v${t} = get${t}AtOutCoords();`)}));const r=this.variableNames.map((t=>`v${t}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class Bt{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map(((t,i)=>`T${i}`));const n=[];this.variableNames.forEach((t=>{n.push(`vec4 v${t} = get${t}AtOutCoords();`)}));const r=this.variableNames.map((t=>`v${t}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}class Lt{constructor(t,e,n){this.variableNames=["A"];const{windowSize:r,batchSize:o,outSize:c}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[o,c];const l="max"===e?">":"<",d=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${d};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${l} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}function Vt(t,e){return["x","y","z","w","u","v"].slice(0,e).map((e=>`${t}.${e}`))}function zt(t,e){return 1===e?[t]:Vt(t,e)}function Ut(){let t,e,n,r,c,output,l,d,h,f;return 2===Object(o.bb)().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",r="in",c="texture",output="outputColor",l="out vec4 outputColor;",d="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",h="",f="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",r="varying",c="texture2D",output="gl_FragColor",l="",d="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",h="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",f="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:c,output:output,defineOutput:l,defineSpecialNaN:d,defineSpecialInf:h,defineRound:f}}function Wt(t,e,n="index"){const r=o.Eb.computeStrides(e);return r.map(((e,i)=>`${`int ${t[i]} = ${n} / ${e}`}; ${i===r.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * ${e}`:`index -= ${t[i]} * ${e}`};`)).join("")}function Gt(t){const e=o.Eb.computeStrides(t).map((t=>t.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;\n  }\n`}const Ht="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:qt}=o.R;function Kt(t,e,n,r){const c=[];t.forEach((t=>{const e=o.Eb.sizeFromShape(t.shapeInfo.logicalShape);t.shapeInfo.isUniform?c.push(`uniform float ${t.name}${e>1?`[${e}]`:""};`):(c.push(`uniform sampler2D ${t.name};`),c.push(`uniform int offset${t.name};`))}));const l=c.join("\n"),d=t.map((t=>function(t,e,n=!1){let r="";r+=n?Yt(t):Xt(t);const c=t.shapeInfo.logicalShape,l=e.logicalShape;c.length<=l.length&&(r+=n?function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),c="get"+r+"AtOutCoords",l=t.shapeInfo.logicalShape.length,d=e.logicalShape.length,h=qt(t.shapeInfo.logicalShape,e.logicalShape),f=ae(d),m=d-l;let y;const O=["x","y","z","w","u","v"];y=0===l?"":d<2&&h.length>=1?"coords = 0;":h.map((t=>`coords.${O[t+m]} = 0;`)).join("\n");let x="";x=d<2&&l>0?"coords":t.shapeInfo.logicalShape.map(((s,i)=>`coords.${O[i+m]}`)).join(", ");let output="return outputValue;";const v=1===o.Eb.sizeFromShape(t.shapeInfo.logicalShape),w=1===o.Eb.sizeFromShape(e.logicalShape);if(1!==l||v||w){if(v&&!w)output=1===d?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(h.length){const t=l-2,e=l-1;h.indexOf(t)>-1&&h.indexOf(e)>-1?output="return vec4(outputValue.x);":h.indexOf(t)>-1?output="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":h.indexOf(e)>-1&&(output="return vec4(outputValue.xx, outputValue.zz);")}}else output="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${c}() {\n      ${f} coords = getOutputCoords();\n      ${y}\n      vec4 outputValue = get${r}(${x});\n      ${output}\n    }\n  `}(t,e):function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),c="get"+r+"AtOutCoords",l=e.texShape,d=t.shapeInfo.texShape,h=t.shapeInfo.logicalShape.length,f=e.logicalShape.length;if(!t.shapeInfo.isUniform&&h===f&&null==t.shapeInfo.flatOffset&&o.Eb.arraysEqual(d,l))return`\n      float ${c}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const m=ae(f),y=qt(t.shapeInfo.logicalShape,e.logicalShape),O=f-h;let x;const v=["x","y","z","w","u","v"];x=0===h?"":f<2&&y.length>=1?"coords = 0;":y.map((t=>`coords.${v[t+O]} = 0;`)).join("\n");let w="";w=f<2&&h>0?"coords":t.shapeInfo.logicalShape.map(((s,i)=>`coords.${v[i+O]}`)).join(", ");return`\n    float ${c}() {\n      ${m} coords = getOutputCoords();\n      ${x}\n      return get${r}(${w});\n    }\n  `}(t,e));return r}(t,e,r))).join("\n"),h=e.texShape,f=Ut(),m=function(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(f);let y,O,x=function(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Qt}\n    ${Jt}\n    ${Zt}\n  `}(f);e.isPacked?(y=function(t,e){switch(t.length){case 0:return ee();case 1:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(1===n[0])return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `;if(1===n[1])return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `;return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,e);case 2:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(o.Eb.arraysEqual(t,e))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const r=Math.ceil(t[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[2]/2),o=r*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,e);default:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),o=r*Math.ceil(t[t.length-2]/2);let c=o,l="",d="b, r, c";for(let b=2;b<t.length-1;b++)c*=t[t.length-b-1],l=`\n      int b${b} = index / ${c};\n      index -= b${b} * ${c};\n    `+l,d=`b${b}, `+d;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${l}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${t.length}(${d});\n    }\n  `}(t,e)}}(e.logicalShape,h),O=function(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(f)):(y=function(t,e){switch(t.length){case 0:return ee();case 1:return function(t,e){if(1===e[0])return`\n      int getOutputCoords() {\n        return int(resultUV.x * ${e[1]}.0);\n      }\n    `;if(1===e[1])return`\n      int getOutputCoords() {\n        return int(resultUV.y * ${e[0]}.0);\n      }\n    `;return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      return resTexRC.x * ${e[1]} + resTexRC.y;\n    }\n  `}(0,e);case 2:return function(t,e){if(o.Eb.arraysEqual(t,e))return`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));\n      }\n    `;if(1===t[1])return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===t[0])return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=Wt(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(t,e);case 4:return function(t,e){const n=Wt(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,e);case 5:return function(t,e){const n=Wt(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},\n                             ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,e);case 6:return function(t,e){const n=Wt(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}(e.logicalShape,h),O=function(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(f)),r&&(x+=te);return[x,m,O,l,y,d,n].join("\n")}function Xt(t){const e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`float ${n}() {return ${e};}`;const[r,o]=t.shapeInfo.texShape;if(1===r&&1===o)return`\n      float ${n}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const[c,l]=t.shapeInfo.texShape,d=ne(e);return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${c}, ${l}, ${d});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${re(t)}\n      }\n    `;const r=t.shapeInfo.texShape,o=r[0],c=r[1];if(1===c&&1===o)return`\n      float ${n}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const l=ne(e);if(1===c)return`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${l}) + 0.5) / ${o}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(1===o)return`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${l}) + 0.5) / ${c}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${c}, index + ${l});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),c=t.shapeInfo.texShape;if(null!=c&&o.Eb.arraysEqual(e,c)){const t=c[0];return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${c[1]}.0, ${t}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `}const{newShape:l,keptDims:d}=o.Eb.squeezeShape(e),h=l;if(h.length<e.length){const e=["row","col"];return`\n      ${Xt(se(t,h))}\n      float ${r}(int row, int col) {\n        return ${r}(${oe(e,d)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${re(t)}\n      }\n    `;const f=c[0],m=c[1],y=ne(n);if(1===m)return`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${y}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${f}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;if(1===f)return`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${y}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${m}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${y};\n    vec2 uv = uvFromFlat(${f}, ${m}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(t);case 3:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),c=e[1]*e[2],l=e[2],{newShape:d,keptDims:h}=o.Eb.squeezeShape(e),f=d;if(f.length<e.length){const e=["row","col","depth"];return`\n        ${Xt(se(t,f))}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${oe(e,h)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${c}, ${l}, 1)));\n        ${re(t)}\n      }\n    `;const m=t.shapeInfo.texShape,y=m[0],O=m[1],x=t.shapeInfo.flatOffset;if(O===c&&null==x)return`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${l}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${O}.0, ${y}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `;if(O===l&&null==x)return`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${O}.0, ${y}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;const v=ne(n);return`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${c} + col * ${l} + depth + ${v};\n        vec2 uv = uvFromFlat(${y}, ${O}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(t);case 4:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),c=e[3],l=e[2]*c,d=e[1]*l,{newShape:h,keptDims:f}=o.Eb.squeezeShape(e);if(h.length<e.length){const e=["row","col","depth","depth2"];return`\n      ${Xt(se(t,h))}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${oe(e,f)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${d}, ${l}, ${c}, 1)));\n        ${re(t)}\n      }\n    `;const m=t.shapeInfo.flatOffset,y=t.shapeInfo.texShape,O=y[0],x=y[1];if(x===d&&null==m)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${l}, ${c}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${x}.0, ${O}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(x===c&&null==m)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${x}.0, ${O}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const v=ne(n);return`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${l} +\n          depth * ${c} + depth2;\n      vec2 uv = uvFromFlat(${O}, ${x}, index + ${v});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 5:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),c=e[4],l=e[3]*c,d=e[2]*l,h=e[1]*d,{newShape:f,keptDims:m}=o.Eb.squeezeShape(e);if(f.length<e.length){const e=["row","col","depth","depth2","depth3"];return`\n      ${Xt(se(t,f))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${oe(e,m)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${h}, ${d}, ${l}, ${c})) +\n          depth3;\n        ${re(t)}\n      }\n    `;const y=t.shapeInfo.flatOffset,O=t.shapeInfo.texShape,x=O[0],v=O[1];if(v===h&&null==y)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${d}, ${l}, ${c}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${v}.0, ${x}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(v===c&&null==y)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]},\n               ${e[2]*e[3]}, ${e[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${v}.0, ${x}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const w=ne(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${h} + col * ${d} + depth * ${l} +\n          depth2 * ${c} + depth3 + ${w};\n      vec2 uv = uvFromFlat(${x}, ${v}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 6:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:c,keptDims:l}=o.Eb.squeezeShape(e);if(c.length<e.length){const e=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Xt(se(t,c))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${oe(e,l)});\n      }\n    `}const d=e[5],h=e[4]*d,f=e[3]*h,m=e[2]*f,y=e[1]*m;if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${y}, ${m}, ${f}, ${h})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${d}, 1)));\n        ${re(t)}\n      }\n    `;const O=t.shapeInfo.flatOffset,x=t.shapeInfo.texShape,v=x[0],w=x[1];if(w===y&&null==O)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${m}, ${f}, ${h}, ${d})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${w}.0, ${v}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(w===d&&null==O)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]*e[4]},\n               ${e[2]*e[3]*e[4]},\n               ${e[3]*e[4]},\n               ${e[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${w}.0, ${v}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const j=ne(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${y} + col * ${m} + depth * ${f} +\n          depth2 * ${h} + depth3 * ${d} + depth4 + ${j};\n      vec2 uv = uvFromFlat(${v}, ${w}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function Yt(t){switch(t.shapeInfo.logicalShape.length){case 0:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=Ut();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${e}, halfCR);\n    }\n  `}(t);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t.shapeInfo.texShape,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],c=Ut();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${c.texture2D}(${e}, uv);\n    }\n  `}(t);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),c=t.shapeInfo.texShape,l=c[0],d=c[1],h=Ut();if(null!=c&&o.Eb.arraysEqual(e,c))return`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${l}.0);\n\n        return ${h.texture2D}(${n}, uv);\n      }\n    `;const f=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)],m=Math.ceil(e[1]/2);return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${m}, ${f[0]}, ${f[1]}, row, col);\n      return ${h.texture2D}(${n}, uv);\n    }\n  `}(t);case 3:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape,c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===e[0]){const n=[1,2],o=["b","row","col"];return`\n        ${Yt(se(t,e.slice(1)))}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${oe(o,n)});\n        }\n      `}const l=c[0],d=c[1],h=Math.ceil(e[2]/2),f=h*Math.ceil(e[1]/2),m=Ut();return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${d}, ${f}, ${h}, b, row, col);\n      return ${m.texture2D}(${n}, uv);\n    }\n  `}(t);default:return function(t){const e=t.shapeInfo.logicalShape,n=e.length,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),c=t.shapeInfo.texShape,l=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)],d=l[0],h=l[1],f=Math.ceil(e[n-1]/2);let m=f*Math.ceil(e[n-2]/2),y="int b, int row, int col",O=`b * ${m} + (row / 2) * ${f} + (col / 2)`;for(let b=2;b<n-1;b++)y=`int b${b}, `+y,m*=e[n-b-1],O=`b${b} * ${m} + `+O;const x=Ut();return`\n    vec4 ${o}(${y}) {\n      int index = ${O};\n      int texR = index / ${h};\n      int texC = index - texR * ${h};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}, ${d});\n      return ${x.texture2D}(${r}, uv);\n    }\n  `}(t)}}const Qt="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Jt="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Zt="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",te="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function ee(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function ne(t){return`offset${t}`}function re(t){const e=t.name,n=o.Eb.sizeFromShape(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${e}[i];\n      }\n    }\n  `}function ae(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function se(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function oe(t,e){return e.map((e=>t[e])).join(", ")}class ie{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,o.Eb.assert(t.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const c=t[t.length-1],l=Math.ceil(c/e);this.outputShape=t.slice(0,-1),l>1&&this.outputShape.push(l),r||this.variableNames.push("bestIndicesA");const d=this.outputShape,h=d.length,f=ae(h),m=zt("coords",h);let y,O;if(1===l){O=h+1;const t=ae(O);y=`\n        ${t} sourceLocR = ${t}(${m.join()}, 0);\n        ++${m[h-1]};\n        ${t} sourceLocG = ${t}(${m.join()}, 0);\n        ++${m[h-2]};\n        ${t} sourceLocA = ${t}(${m.join()}, 0);\n        --${m[h-1]};\n        ${t} sourceLocB = ${t}(${m.join()}, 0);\n        --${m[h-2]};`}else O=h,y=`\n        ${f} sourceLocR = coords;\n        ++${m[h-1]};\n        ${f} sourceLocG = coords;\n        ++${m[h-2]};\n        ${f} sourceLocA = coords;\n        --${m[h-1]};\n        ${f} sourceLocB = coords;\n        --${m[h-2]};`;const x=["x","y","z","w","u","v"].slice(0,O),v="."+x[O-1],w=x.map((t=>"int "+t)),j=zt("sourceLocR",O-1).concat("inIdx.r"),E=zt("sourceLocG",O-1).concat("inIdx.g"),$=zt("sourceLocB",O-1).concat("inIdx.b"),C=zt("sourceLocA",O-1).concat("inIdx.a"),N="max"===n?"greaterThan":"lessThan",R=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${j.join()}),\n                             getBestIndicesAChannel(${E.join()}),\n                             getBestIndicesAChannel(${$.join()}),\n                             getBestIndicesAChannel(${C.join()})));`,S=`vec4(\n            getAChannel(${j.join()}),\n            hasNextCol ? getAChannel(${E.join()}) : 0.,\n            hasNextRow ? getAChannel(${$.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${C.join()}) : 0.)`,T=r?"":`\n      float getBestIndicesAChannel(${w.join()}) {\n        return getChannel(getBestIndicesA(${x.join()}),\n                                          vec2(${x.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${w.join()}) {\n        return getChannel(getA(${x.join()}),\n                               vec2(${x.slice(-2).join()}));\n      }\n      ${T}\n      void main() {\n        ${f} coords = getOutputCoords();\n        bool hasNextCol = ${m[h-1]} < ${d[h-1]-1};\n        bool hasNextRow = ${m[h-2]} < ${d[h-2]-1};\n        ${y}\n        ivec4 srcIdx = ivec4(sourceLocR${v}, sourceLocG${v},\n          sourceLocB${v}, sourceLocA${v}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${S};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${R}\n          vec4 candidate = ${S};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${N}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}class ce{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,c=t.dilationHeight,l=t.dilationWidth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,f=d-1-t.padInfo.top,m=h-1-t.padInfo.left,y=1/(e*n);this.userCode=`\n      const ivec2 pads = ivec2(${f}, ${m});\n      const float avgMultiplier = float(${y});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d};\n            wR += ${c}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${h};\n            wC+= ${l}) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ue{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,o=t.strideDepth,c=t.strideHeight,l=t.strideWidth,d=t.dilationDepth,h=t.dilationHeight,f=t.dilationWidth,m=t.effectiveFilterDepth,y=t.effectiveFilterHeight,O=t.effectiveFilterWidth,x=m-1-t.padInfo.front,v=y-1-t.padInfo.top,w=O-1-t.padInfo.left,j=1/(e*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${x}, ${v}, ${w});\n      const float avgMultiplier = float(${j});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${m};\n            wD += ${d}) {\n          float dyD = float(dyDCorner + wD) / ${o}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${y};\n              wR += ${h}) {\n            float dyR = float(dyRCorner + wR) / ${c}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${O};\n                wC += ${f}) {\n              float dyC = float(dyCCorner + wC) / ${l}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const le="return areal * breal - aimag * bimag;",de="return areal * bimag + aimag * breal;";class pe{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=o.R.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const he="return a + b;",fe="return a - b;",me="return a * b;",be="return (a < 0.) ? b * a : a;";class ge{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=o.R.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const ye="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";class Oe{constructor(t,e,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o.R.assertAndGetBroadcastShape(e,n);const c=this.outputShape.length;let l="";if(r)if(0===c||1===o.Eb.sizeFromShape(this.outputShape))l="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(l=`\n          ${ae(c)} coords = getOutputCoords();\n        `,1===c)l+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const t=zt("coords",c);l+=`\n            bool nextRowOutOfBounds =\n              (${t[c-2]} + 1) >= ${this.outputShape[c-2]};\n            bool nextColOutOfBounds =\n              (${t[c-1]} + 1) >= ${this.outputShape[c-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${l}\n\n        setOutput(result);\n      }\n    `}}class xe{constructor(t){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(t,e){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}class ve{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(t,e){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}class we{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}class je{constructor(t){this.outputShape=[],this.outputShape=o.R.computeOutShape(t,1),this.variableNames=t.map(((t,i)=>`T${i}`));const e=new Array(t.length-1);e[0]=t[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+t[i][1];const n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++){const t=e[i-1];n.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${t}));`)}const r=e.length,c=e[e.length-1];n.push(`else setOutput(getT${r}(yR, yC-${c}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class Ee{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=o.R.computeOutShape(t,e);const n=this.outputShape,r=n.length,c=ae(r),l=zt("coords",r),d=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map(((t,i)=>`T${i}`));const h=new Array(t.length-1);h[0]=t[0][e];for(let i=1;i<h.length;i++)h[i]=h[i-1]+t[i][e];const f=d[e],m=d.slice(-2),y=d.join();let O=`if (${f} < ${h[0]}) {\n        return getChannel(\n            getT0(${y}), vec2(${m.join()}));\n        }`;for(let i=1;i<h.length;i++){const t=h[i-1];O+=`\n        if (${f} < ${h[i]}  && ${f} >= ${h[i-1]}) {\n          return getChannel(\n            getT${i}(${$e(d,f,t)}),\n            vec2(${$e(m,f,t)}));\n        }`}const x=h.length,v=h[h.length-1];O+=`\n        return getChannel(\n          getT${x}(${$e(d,f,v)}),\n          vec2(${$e(m,f,v)}));`,this.userCode=`\n      float getValue(${d.map((t=>"int "+t))}) {\n        ${O}\n      }\n\n      void main() {\n        ${c} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${l}), 0., 0., 0.);\n\n        ${l[r-1]} = ${l[r-1]} + 1;\n        if (${l[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${l});\n        }\n\n        ${l[r-2]} = ${l[r-2]} + 1;\n        if (${l[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${l});\n        }\n\n        ${l[r-1]} = ${l[r-1]} - 1;\n        if (${l[r-2]} < ${n[r-2]} &&\n            ${l[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${l});\n        }\n        setOutput(result);\n      }\n    `}}function $e(t,e,n){const r=t.indexOf(e);return t.map(((t,e)=>e===r?`${t} - ${n}`:t)).join()}class Ce{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,o=t.padInfo.left,c="channelsLast"===t.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${r};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${o};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${c}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ne{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,c="channelsLast"===t.dataFormat,l=e-1-t.padInfo.top,d=n-1-t.padInfo.left,h=c?1:2,f=c?2:3,m=c?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${m}];\n\n        ivec2 dyCorner = ivec2(coords[${h}], coords[${f}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${c}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Re{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,o=t.padInfo.front,c=t.padInfo.top,l=t.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${e} - ${o};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${c};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${l};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Se{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,o=t.strideDepth,c=t.strideHeight,l=t.strideWidth,d=e-1-t.padInfo.front,h=n-1-t.padInfo.top,f=r-1-t.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${d}, ${h}, ${f});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${o}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${c}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${l}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Te{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,o=t.padInfo.left,c=t.outChannels/t.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${c} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${r};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${o};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ie{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,c=e-1-t.padInfo.top,l=n-1-t.padInfo.left,d=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${c}, ${l});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${d}; dm++) {\n              int d2 = d1 * ${d} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ae{constructor(t,e=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,c=t.padInfo.left,l=t.strideHeight,d=t.strideWidth,h=t.dilationHeight,f=t.dilationWidth,m=t.filterHeight,y=t.filterWidth,O=4*Math.floor(t.inChannels/4),x=t.inChannels%4,v="channelsLast"===t.dataFormat,w=v?1:2,j=v?2:3,E=v?3:1;let $="",C="";n&&($=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,C="result = activation(result);");const N=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${$}\n\n      const ivec2 strides = ivec2(${l}, ${d});\n      const ivec2 pads = ivec2(${o}, ${c});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${E}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${w}], coords[${j}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${m}; wR++) {\n          int xR = xRCorner + wR * ${h};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${y}; wC++) {\n            int xC = xCCorner + wC * ${f};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${O}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${v}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===x}) {\n\n              if (${v}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${O}) *\n                    getW(wR, wC, ${O}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${O}, xR, xC) *\n                    getW(wR, wC, ${O}, d2);\n              }\n\n            } else if (${2===x}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${O}, d2),\n                getW(wR, wC, ${O} + 1, d2)\n              );\n\n              if (${v}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${O}),\n                  getX(batch, xR, xC, ${O} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${O}, xR, xC),\n                  getX(batch, ${O} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===x}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${O}, d2),\n                getW(wR, wC, ${O} + 1, d2),\n                getW(wR, wC, ${O} + 2, d2)\n              );\n\n              if (${v}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${O}),\n                  getX(batch, xR, xC, ${O} + 1),\n                  getX(batch, xR, xC, ${O} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${O}, xR, xC),\n                  getX(batch, ${O} + 1, xR, xC),\n                  getX(batch, ${O} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${N}\n        ${C}\n        setOutput(result);\n      }\n    `}}class ke{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,o=t.strideDepth,c=t.strideHeight,l=t.strideWidth,d=t.dilationDepth,h=t.dilationHeight,f=t.dilationWidth,m=t.filterDepth,y=t.filterHeight,O=t.filterWidth,x=4*Math.floor(t.inChannels/4),v=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${c}, ${l});\n      const ivec3 pads = ivec3(${e}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${m}; wF++) {\n          int xF = xFCorner + wF * ${d};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${y}; wR++) {\n            int xR = xRCorner + wR * ${h};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${O}; wC++) {\n              int xC = xCCorner + wC * ${f};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${x}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===v}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${x}) *\n                  getW(wF, wR, wC, ${x}, d2);\n              } else if (${2===v}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${x}),\n                  getX(batch, xF, xR, xC, ${x} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${x}, d2),\n                  getW(wF, wR, wC, ${x} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===v}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${x}),\n                  getX(batch, xF, xR, xC, ${x} + 1),\n                  getX(batch, xF, xR, xC, ${x} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${x}, d2),\n                  getW(wF, wR, wC, ${x} + 1, d2),\n                  getW(wF, wR, wC, ${x} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class De{constructor(t,e=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.inHeight,c=t.inWidth,l=t.padInfo.top,d=t.padInfo.left,h=t.strideHeight,f=t.strideWidth,m=t.dilationHeight,y=t.dilationWidth,O=t.filterHeight,x=t.filterWidth,v=t.outChannels/t.inChannels;let w="",j="";n&&(w=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,j="result = activation(result);");const E=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${w}\n\n      const ivec2 strides = ivec2(${h}, ${f});\n      const ivec2 pads = ivec2(${l}, ${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${v};\n        int q = d2 - d1 * ${v};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${O}; wR++) {\n          int xR = xRCorner + wR * ${m};\n\n          if (xR < 0 || xR >= ${o}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC++) {\n            int xC = xCCorner + wC * ${y};\n\n            if (xC < 0 || xC >= ${c}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${E}\n        ${j}\n        setOutput(result);\n      }\n    `}}class _e{constructor(t,e=!1,n=null,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.outShape;const c=t.inHeight,l=t.inWidth,d=t.padInfo.top,h=t.padInfo.left,f=t.strideHeight,m=t.strideWidth,y=t.dilationHeight,O=t.dilationWidth,x=t.filterHeight,v=t.filterWidth,w=v;let j="int xR; int xC; int xCOffset;";for(let t=0;t<x;t++)for(let e=0;e<v;e++)j+=`\n          vec4 xTexelR${t}C${2*e} = vec4(0.);\n          vec4 wR${t}C${e} = vec4(0.);\n          vec4 xR${t}C${e} = vec4(0.);`;for(let t=0;t<x;t++)for(let e=0;e<w;e++){const n=2*e;if(j+=`\n          xR = xRCorner + ${t*y};\n          xC = xCCorner + ${n*O};\n        `,1===m){if(n<v&&(j+=h%2==1?`\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${c} && xCOffset >= 0 && xCOffset < ${l}) {\n                  xTexelR${t}C${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${l}) {\n                    xTexelR${t}C${n}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${t}C${n} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${c} && xCOffset >= 0 && xCOffset < ${l}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${l}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${t}C${n} = vec4(previous.zw, xTexelR${t}C${n}.xy);\n                } else {\n                  xR${t}C${n} = vec4(0, 0, xTexelR${t}C${n}.xy);\n                }\n              `:`\n                if(xR >= 0 && xR < ${c} && xC >= 0 && xC < ${l}) {\n                  xTexelR${t}C${n} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${t}C${n} = vec4(0.);\n                }\n\n                xR${t}C${n} = xTexelR${t}C${n};\n              `,n+1<v)){const e=h%2==0?o.Eb.nearestLargerEven(O):O;O%2==0&&h%2==1||O%2!=0&&h%2!=1?(j+=`\n                  xCOffset = xC + ${h%2} + ${e};\n\n                  if(xR >= 0 && xR < ${c} &&\n                    xCOffset >= 0 && xCOffset < ${l}) {\n                    xTexelR${t}C${n+2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `,O>1&&(j+=`\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${c} &&\n                      xCOffset >= 0 && xCOffset < ${l}) {\n                      xTexelR${t}C${n} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${t}C${n} = vec4(0.);\n                    }\n                  `),j+=`\n                  xR${t}C${n+1} = vec4(\n                    xTexelR${t}C${n}.zw, xTexelR${t}C${n+2}.xy);\n                `):j+=`\n                  xCOffset = xC + ${e};\n\n                  if(xR >= 0 && xR < ${c} &&\n                    xCOffset >= 0 && xCOffset < ${l}) {\n                    xTexelR${t}C${n+2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${t}C${n+1} = xTexelR${t}C${n+2};\n                `}}else n<v&&(j+=`\n              if(xR >= 0 && xR < ${c}) {\n            `,h%2==1?(j+=`\n                xCOffset = xC + 1 - ${m};\n                if(xCOffset >= 0 && xCOffset < ${l}) {\n                  xTexelR${t}C${n} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${t}C${n} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${l}) {\n                  xTexelR${t}C${n+2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${t}C${n+2} = vec4(0.);\n                }\n\n                xR${t}C${n} = vec4(\n                  xTexelR${t}C${n}.zw, xTexelR${t}C${n+2}.zw);\n              `,n+1<v&&(j+=`\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${m};\n                  if(xCOffset >= 0 && xCOffset < ${l}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${t}C${n+1} = vec4(xTexelR${t}C${n+2}.xy, final.xy);\n                `)):(j+=`\n                if(xC >= 0 && xC < ${l}) {\n                  xTexelR${t}C${n} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${t}C${n} = vec4(0.);\n                }\n\n                xCOffset = xC + ${m};\n                if(xCOffset >= 0 && xCOffset < ${l}) {\n                  xTexelR${t}C${n+2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${t}C${n+2} = vec4(0.);\n                }\n\n                xR${t}C${n} = vec4(\n                  xTexelR${t}C${n}.xy, xTexelR${t}C${n+2}.xy);\n              `,n+1<v&&(j+=`\n                  xR${t}C${n+1} = vec4(\n                    xTexelR${t}C${n}.zw, xTexelR${t}C${n+2}.zw);\n                `)),j+="}");n<v&&(j+=`\n            vec4 wTexelR${t}C${n} = getW(${t}, ${n}, d1, q);\n            wR${t}C${n} = vec4(wTexelR${t}C${n}.xz, wTexelR${t}C${n}.xz);\n          `,n+1<v&&(j+=`\n              vec4 wTexelR${t}C${n+1} = getW(${t}, ${n+1}, d1, q);\n              wR${t}C${n+1} =\n                vec4(wTexelR${t}C${n+1}.xz, wTexelR${t}C${n+1}.xz);`))}for(let t=0;t<x;t++)for(let e=0;e<v;e++)j+=`dotProd += xR${t}C${e} * wR${t}C${e};`;let E="",$="";n&&(E=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,$="result = activation(result);");const C=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${E}\n\n      const ivec2 strides = ivec2(${f}, ${m});\n      const ivec2 pads = ivec2(${d}, ${h});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${j}\n\n        vec4 result = dotProd;\n        ${C}\n        ${$}\n        setOutput(result);\n      }\n    `}}class Fe{constructor(t,e,n,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[c,l,d,h]=t,[f]=e,[m,y]=n;this.outputShape=[f,m,y,h];const O="bilinear"===r?1:0,[x,v]=[l-1+".0",d-1+".0"],[w,j,E]=m>1?[""+(l-1)/(m-1),"(y2-y1) * height_ratio",`y1*${x} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${x}`],[$,C,N]=y>1?[""+(d-1)/(y-1),"(x2-x1) * width_ratio",`x1*${v} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${v}`];this.userCode=`\n      const float height_ratio = float(${w});\n      const float width_ratio = float(${$});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${c}) {\n          return;\n        }\n\n        float height_scale = ${j};\n        float width_scale = ${C};\n\n        float in_y = ${E};\n        if( in_y < 0.0 || in_y > ${x} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${N};\n        if( in_x < 0.0 || in_x > ${v} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${O} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}class Pe{constructor(t,e,n){this.variableNames=["x"],this.outputShape=t;const r=t.length,o=e?"0.0":`getX(${Me(r,"coords")})`,c=t[t.length-1];let l="",d="";e?(l=n?"end != "+(c-1):"end != 0",d=n?"end + 1":"end - 1"):(l=n?`end + pow2 < ${c}`:"end >= pow2",d=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${ae(r)} coords = getOutputCoords();\n        int end = ${Be(r,"coords")};\n        float val = ${o};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${d};\n          ${Be(r,"coords")} = idx;\n          val += getX(${Me(r,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.index&&(this.index=e.getUniformLocation(n,"index")),e.gl.uniform1f(this.index,t)}}}function Me(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.x, ${e}.y`;if(3===t)return`${e}.x, ${e}.y, ${e}.z`;if(4===t)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}function Be(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.y`;if(3===t)return`${e}.z`;if(4===t)return`${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}class Le{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=h.DENSE;const e=O(t),n=Ut();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${Wt(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class Ve{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=h.DENSE;const e=O(t),n=Ut();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${Wt(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class ze{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}class Ue{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}class We{constructor(t){this.variableNames=["A"],this.outTexUsage=f.DOWNLOAD;const e=Ut();this.outputShape=t,this.userCode=`\n      ${Ht}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class Ge{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=f.DOWNLOAD;const e=Ut();this.outputShape=t,this.userCode=`\n      ${Ht}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class He{constructor(t,e,n=!1){this.variableNames=["A"];const r=Ut(),[o,c]=e;this.outputShape=t;let output="result";n&&(output="floor(result * 255. + 0.5)"),this.userCode=`\n      ${Gt(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${c};\n        int c = imod(flatIndex, ${c});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${c}.0, ${o}.0);\n        vec4 values = ${r.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${r.output} = vec4(${output}, 0., 0., 0.);\n      }\n    `}}class qe{constructor(t,e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const r=Ut(),[o,c]=e;this.outputShape=t;let l="",output="result";n&&(output="floor(result * 255. + 0.5)");for(let e=0;e<=1;e++)for(let col=0;col<=1;col++){const n=2*e+col;l+=`\n          localCoords = coords;\n          if(localCoords[2] + ${col} < ${t[2]}) {\n            localCoords[2] += ${col};\n            if(localCoords[1] + ${e} < ${t[1]}) {\n              localCoords[1] += ${e};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${c};\n              c = imod(flatIndex, ${c});\n              uv = (vec2(c, r) + halfCR) / vec2(${c}.0, ${o}.0);\n              values = ${r.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${n}] = values[0];\n              } else if(offset == 1) {\n                result[${n}] = values[1];\n              } else if(offset == 2) {\n                result[${n}] = values[2];\n              } else {\n                result[${n}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${Gt(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${l}\n\n        ${r.output} = ${output};\n      }\n    `}}const Ke="return real * expR - imag * expI;",Xe="return real * expI + imag * expR;";class Ye{constructor(t,e,n){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const o=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,c=n?`${r}.0`:"1.0";this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${t}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${c};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}class Qe{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}class Je{constructor(t,e,n){this.variableNames=["A","indices"];const r=t.slice();r[n]=e,this.outputShape=r,this.rank=r.length;const o=ae(this.rank),c=function(t,e){const n=t.length;if(n>4)throw Error(`Gather for rank ${n} is not yet supported`);if(1===n)return"int(getIndices(resRC))";const r=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[];for(let i=0;i<t.length;i++)i===e?o.push(`int(getIndices(${r[i]}))`):o.push(`${r[i]}`);return o.join()}(t,n);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        setOutput(getA(${c}));\n      }\n    `}}class Ze{constructor(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;const r=ae(e.length),o=ae(n.length),c=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${c};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}function tn(t){const e=Ut();return function(t,e){const n=k(t,(()=>t.createShader(t.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(w(t,(()=>t.shaderSource(n,e))),w(t,(()=>t.compileShader(n))),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(t,`${e.version}\n    precision highp float;\n    ${e.attribute} vec3 clipSpacePos;\n    ${e.attribute} vec2 uv;\n    ${e.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function en(t){return function(t,data){const e=k(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");return w(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,e))),w(t,(()=>t.bufferData(t.ARRAY_BUFFER,data,t.STATIC_DRAW))),e}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function nn(t){return function(t,data){const e=k(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");return w(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e))),w(t,(()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,data,t.STATIC_DRAW))),e}(t,new Uint16Array([0,1,2,2,1,3]))}function rn(t,e,n,r,c,l){!function(t,e){const n=Object(o.bb)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0)throw new Error(`Requested texture size [${t}x${e}] is invalid.`);if(t>n||e>n)throw new Error(`Requested texture size [${t}x${e}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(e,n);const d=function(t){return k(t,(()=>t.createTexture()),"Unable to create WebGLTexture.")}(t),h=t.TEXTURE_2D;return w(t,(()=>t.bindTexture(h,d))),w(t,(()=>t.texParameteri(h,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE))),w(t,(()=>t.texParameteri(h,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE))),w(t,(()=>t.texParameteri(h,t.TEXTURE_MIN_FILTER,t.NEAREST))),w(t,(()=>t.texParameteri(h,t.TEXTURE_MAG_FILTER,t.NEAREST))),w(t,(()=>t.texImage2D(h,0,r,e,n,0,c,l,null))),w(t,(()=>t.bindTexture(t.TEXTURE_2D,null))),d}function an(t){return t.internalFormatFloat}function sn(t){return t.internalFormatHalfFloat}function on(t){return t.downloadTextureFormat}function cn(t){return t.internalFormatPackedFloat}function un(t){return t.internalFormatPackedHalfFloat}function ln(t,e,n,r,o,c,l,d){const h=t,f=new Float32Array(function(t,e){const[n,r]=x(t,e);return n*r*4}(c,l));return h.bindBuffer(h.PIXEL_PACK_BUFFER,e),h.getBufferSubData(h.PIXEL_PACK_BUFFER,0,f),h.bindBuffer(h.PIXEL_PACK_BUFFER,null),f}class dn{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=Object(o.bb)().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,function(t,e){c[t]=e}(e,t)):this.gl=d(e);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(1===Object(o.bb)().getNumber("WEBGL_VERSION")){const t="OES_texture_float",e="OES_texture_half_float";if(this.textureFloatExtension=E(this.gl,t),z(this.gl,e))this.textureHalfFloatExtension=E(this.gl,e);else if(Object(o.bb)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),z(this.gl,r))this.colorBufferHalfFloatExtension=E(this.gl,r);else if(Object(o.bb)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",z(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!z(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=en(this.gl),this.indexBuffer=nn(this.gl),this.framebuffer=function(t){return k(t,(()=>t.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=v(this.gl,this.textureHalfFloatExtension)}get debug(){return Object(o.bb)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;w(t,(()=>t.finish())),w(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,null))),w(t,(()=>t.deleteFramebuffer(this.framebuffer))),w(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,null))),w(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null))),w(t,(()=>t.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[o,c]=y(e,n);return rn(t,o,c,an(r),r.textureFormatFloat,t.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[o,c]=y(e,n);return rn(t,o,c,sn(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[o,c]=y(e,n);return rn(t,o,c,on(r),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function(t,e,n){w(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),n.data instanceof Uint8Array?w(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data))):w(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n))),w(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,data){this.throwIfDisposed(),function(t,e,n,r,data,o){let c,l,d;w(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),data instanceof Uint8Array?(c=new Uint8Array(n*r*4),l=t.UNSIGNED_BYTE,d=t.RGBA):(c=new Float32Array(n*r*4),l=t.FLOAT,d=o.internalFormatPackedFloat),c.set(data),w(t,(()=>t.texImage2D(t.TEXTURE_2D,0,d,n,r,0,t.RGBA,l,c))),w(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}(this.gl,t,e,n,data,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[o,c]=x(e,n);return rn(t,o,c,un(r),t.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[o,c]=x(e,n);return rn(t,o,c,cn(r),t.RGBA,t.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(I(this.gl,this.framebuffer),this.outputTexture=null),w(this.gl,(()=>this.gl.deleteTexture(t)))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>function(t,e,n,r){const[o,c]=y(e,n),l=new Uint8Array(e*n*4);return w(t,(()=>t.readPixels(0,0,o,c,r.downloadTextureFormat,t.UNSIGNED_BYTE,l))),new Float32Array(l.buffer)}(this.gl,e,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(t,e,n,r,o,c){return ln(this.gl,t,0,0,0,o,c,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return function(t,e,n){const r=t,o=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,o),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),o}(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const r=function(t,e,n,r){const o=t.createBuffer();w(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,o)));const c=16*e*n;return w(t,(()=>t.bufferData(t.PIXEL_PACK_BUFFER,c,t.STREAM_READ))),w(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0))),w(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null))),o}(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(Object(o.bb)().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,o=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=r.clientWaitSync(o,0,0);return t===r.ALREADY_SIGNALED||t===r.CONDITION_SATISFIED},e=o}else Object(o.bb)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,Object(o.bb)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>function(t,e,n){const r=new Float32Array(e*n*4);return w(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r))),r}(this.gl,e,n)))}createProgram(t){this.throwIfDisposed();const e=this.gl,n=$(e,t),r=tn(e),o=function(t){return k(t,(()=>t.createProgram()),"Unable to create WebGLProgram.")}(e);return w(e,(()=>e.attachShader(o,r))),w(e,(()=>e.attachShader(o,n))),function(t,e){if(w(t,(()=>t.linkProgram(e))),!1===t.getProgramParameter(e,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}(e,o),this.debug&&N(e,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=function(t,e,n){return w(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,n))),R(t,e,"clipSpacePos",n,3,20,0)&&R(t,e,"uv",n,2,20,12)}(e,this.program,this.vertexBuffer)),o}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&w(this.gl,(()=>this.gl.deleteProgram(t)))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&N(this.gl,this.program),w(this.gl,(()=>this.gl.useProgram(t)))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?function(t,e,n){return k(t,(()=>t.getUniformLocation(e,n)),'uniform "'+n+'" not present in program.')}(this.gl,t,e):function(t,e,n){return t.getUniformLocation(e,n)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),w(this.gl,(()=>this.gl.getAttribLocation(t,e)))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),S(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[r,o]=x(e,n);this.setOutputMatrixTextureDriver(t,r,o)}setOutputMatrixWriteRegion(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&N(this.gl,this.program),A(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),w(t,(()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),w(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=E(this.gl,2===Object(o.bb)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Object(o.bb)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===Object(o.bb)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await o.Eb.repeatedTry((()=>this.disposed||this.isQueryAvailable(t,Object(o.bb)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(t,Object(o.bb)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise((e=>{this.addItemToPoll((()=>t.isFencePassed()),(()=>e()))}))}pollItems(){const t=function(t){let i=0;for(;i<t.length;++i){if(!t[i]())break}return i-1}(this.itemsToPoll.map((t=>t.isDoneFn)));for(let i=0;i<=t;++i){const{resolveFn:t}=this.itemsToPoll[i];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||o.Eb.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),T(this.gl,t,this.framebuffer),this.debug&&A(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(T(this.gl,this.outputTexture,this.framebuffer),this.debug&&A(this.gl)):I(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const r=this.gl;T(r,t,this.framebuffer),this.debug&&A(r),this.outputTexture=t,w(r,(()=>r.viewport(0,0,e,n))),w(r,(()=>r.scissor(0,0,e,n)))}setOutputMatrixWriteRegionDriver(t,e,n,r){this.throwIfDisposed(),w(this.gl,(()=>this.gl.scissor(t,e,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function pn(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach(((s,i)=>{const t=s.logicalShape,input=e[i],n=input.shape;if(!o.Eb.arraysEqual(t,n))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${t} and ${n} must match`);if(s.isUniform&&input.isUniform)return;const r=s.texShape,c=input.isUniform?null:input.texData.texShape;if(!o.Eb.arraysEqual(r,c))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${r} and ${c} must match`)}))}class hn{constructor(t,e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;const{filterWidth:r,inChannels:o,strideWidth:c,strideHeight:l,padInfo:d,outWidth:h,dilationWidth:f,dilationHeight:m,dataFormat:y}=n,{left:O,top:x}=d,v=o*r,w=Ut(),j="channelsLast"===y,E=j?0:1,$=j?1:2;let C="";for(let n=0;n<=1;n++)for(let col=0;col<=1;col++)C+=`\n          blockIndex = rc.y + ${col};\n          pos = rc.x + ${n};\n\n          if(blockIndex < ${t[1]} && pos < ${t[0]}) {\n            offsetY = int(blockIndex / (${h})) * ${l} - ${x};\n            d0 = offsetY + ${m} * (pos / ${v});\n\n            if(d0 < ${e[E]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${h}.) * ${c}. - ${O}.);\n              d1 = offsetX + ${f} * (int(mod(float(pos), ${v}.) / ${o}.));\n\n              if(d1 < ${e[$]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${o}.));\n\n                if (${j}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*n+col}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*n+col}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${C}\n\n        ${w.output} = result;\n      }\n    `}}class fn{constructor(t,e,n,r,o){this.variableNames=["x"],this.outputShape=[];const c=e,l=t[3]-1;let d;this.outputShape=t;const h=`float(${n}) + float(${r}) * sum`;d=.5===o?`inversesqrt(${h})`:1===o?`1.0/(${h})`:`exp(log(${h}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${c}; j <= ${c}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${l}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${d};\n        setOutput(val);\n      }\n    `}}class mn{constructor(t,e,n,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${o})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}class bn{constructor(t,e,n,r,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const c=e,l=t[3]-1;let d;this.outputShape=t;const h=`float(${n}) + float(${r}) * sum`;d=.5===o?`inversesqrt(${h})`:1===o?`1.0/(${h})`:`exp(log(${h}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${c};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${c}; j <= ${c}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${l}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${d};\n        setOutput(result);\n      }\n    `}}class gn{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,n=t.strideWidth,r=t.dilationHeight,o=t.effectiveFilterHeight,c=t.effectiveFilterWidth,l=o-1-t.padInfo.top,d=c-1-t.padInfo.left,h=o*c-1;this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${e}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${c}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${h} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${c} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class yn{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,o=t.dilationDepth,c=t.dilationHeight,l=t.dilationWidth,d=t.effectiveFilterDepth,h=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=d-1-t.padInfo.front,y=h-1-t.padInfo.top,O=f-1-t.padInfo.left,x=d*h*f-1;this.userCode=`\n      const ivec3 pads = ivec3(${m}, ${y}, ${O});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n           wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${e}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${c}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${f};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${x} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${h} * ${f} +\n                  wR * ${f} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class On{constructor(t,e,n=!1,r=!1,o=!1,c=null,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const d=n?t[1]:t[2],h=Math.ceil(d/2),f=n?"i * 2, rc.y":"rc.y, i * 2",m=r?"rc.z, i * 2":"i * 2, rc.z",y=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],O=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let x="",v="";c&&(x=l?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${c}\n        }`:`vec4 activation(vec4 x) {\n          ${c}\n        }`,v="result = activation(result);");const w=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${x}\n\n      const float sharedDimension = ${h}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${h}; i++) {\n          vec4 a = getMatrixA(rc.x, ${f});\n          vec4 b = getMatrixB(rc.x, ${m});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${y[0]} * ${O[0]});\n          result += (${y[1]} * ${O[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${w}\n\n        ${v}\n\n        setOutput(result);\n      }\n    `}}class xn{constructor(t,e,n){this.variableNames=["probs"],this.outputShape=[t,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.seedLoc&&(this.seedLoc=e.getUniformLocation(n,"seed")),e.gl.uniform1f(this.seedLoc,t)}}}class vn{constructor(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}class wn{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t;const e=t.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=zt("rc",e),r=ae(e),o=function(t,e,n){if(1===t)return`rc > ${e[0]}`;let r="";for(let i=t-2;i<t;i++)r+=`${n[i]} >= ${e[i]}`,i<t-1&&(r+="||");return r}(e,t,n),c=function(t,e,n,r){if(1===t)return"";const o=r.slice(-2);return`\n    int r = ${o[0]};\n    int c = ${o[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${e};\n    bool rEdge = rp1 >= ${n};\n  `}(e,t[t.length-1],t[t.length-2],n),output=function(t,e){const n=t.length,r=function(t,e){const n=[];for(let r=0;r<=1;r++)for(let col=0;col<=1;col++){let o=`${0===r?"r":"rp1"}, ${0===col?"c":"cp1"}`;for(let n=2;n<t;n++)o=`${e[e.length-1-n]},`+o;n.push(o)}return n}(n,e);if(1===n)return`getA(rc),\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\n            0, 0`;return`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}(t,n);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${o}) {\n            setOutput(vec4(0));\n          } else {\n            ${c}\n\n            setOutput(vec4(${output}));\n          }\n        }\n      `}}}class jn{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map(((p,i)=>p[0]+t[i]+p[1]));const r=t.length,o=ae(r),c=e.map((p=>p[0])).join(","),l=e.map(((p,i)=>p[0]+t[i])).join(","),d=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${o} start = ${o}(${c});\n      ${o} end = ${o}(${l});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(${n}));\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${d}));\n        }\n      }\n    `:`\n        int start = ${c};\n        int end = ${l};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(${n}));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class En{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map(((p,i)=>p[0]+t[i]+p[1]));const r=t.length,o=ae(r),c=e.map((p=>p[0])).join(","),l=e.map(((p,i)=>p[0]+t[i])).join(","),d=zt("rc",r),source=zt("source",r),h=`${d[r-1]} < ${this.outputShape[r-1]}`,f=1===r?"source":`vec2(${source.slice(-2).join()})`,m=[`${o} rc = outputLoc;`,`${d[r-1]} += 1;\n       if(${h}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${d[r-2]} += 1;\n       if(${d[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${d[r-1]} += 1;\n         if(${h}) {`],y=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let O="";for(let i=0,t=1===r?2:4;i<t;i++)O+=`\n        ${m[i]}\n        if (${y}) {\n          result[${i}] = float(${n});\n        } else {\n          ${o} source = rc - start;\n          result[${i}] = getChannel(getX(${source.join()}), ${f});\n        }\n      `;O+=1===r?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${c});\n      const ${o} end = ${o}(${l});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${O}\n        setOutput(result);\n      }\n    `}}class $n{constructor(t,e,n,r=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const c=t.filterWidth,l=t.strideHeight,d=t.strideWidth,h=t.dilationHeight,f=t.dilationWidth,m=t.effectiveFilterHeight,y=t.effectiveFilterWidth,O=t.padInfo.top,x=t.padInfo.left;this.outputShape=t.outShape;const v="avg"===e,w=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,j=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let E="0.0";if(v||(E="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${l}, ${d});\n        const ivec2 pads = ivec2(${O}, ${x});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${m};\n              wR += ${h}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${y};\n                wC += ${f}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${e} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?o?w:j:`wR * ${y} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let $=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&($="avgValue / count");const C=4*Math.floor(c/4),N=c%4,R=`\n      if (${v}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${l}, ${d});\n      const ivec2 pads = ivec2(${O}, ${x});\n      const float initializationValue = ${E};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${E});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${m};\n            wR += ${h}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${C}; wC += 4) {\n            int xC = xCCorner + wC * ${f};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${f}, d),\n              getValue(batch, xR, xC + 2 * ${f}, d),\n              getValue(batch, xR, xC + 3 * ${f}, d)\n            );\n\n            ${R}\n          }\n\n          int xC = xCCorner + ${C};\n          if (${1===N}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${R}\n          } else if (${2===N}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${f}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${R}\n          } else if (${3===N}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${f}, d),\n              getValue(batch, xR, xC + 2 * ${f}, d),\n              initializationValue\n            );\n\n            ${R}\n          }\n        }\n        setOutput(${$});\n      }\n    `}}class Cn{constructor(t,e,n,r=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const c=t.filterWidth,l=t.strideDepth,d=t.strideHeight,h=t.strideWidth,f=t.dilationDepth,m=t.dilationHeight,y=t.dilationWidth,O=t.effectiveFilterDepth,x=t.effectiveFilterHeight,v=t.effectiveFilterWidth,w=t.padInfo.front,j=t.padInfo.top,E=t.padInfo.left;this.outputShape=t.outShape;const $="avg"===e;let C="0.0";if($||(C="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${l}, ${d}, ${h});\n        const ivec3 pads = ivec3(${w}, ${j}, ${E});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${O};\n              wD += ${f}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${x};\n                wR += ${m}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${v};\n                  wC += ${y}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${e} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?o?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${x} * ${v} +\n                      wR * ${v} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let N=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(N="avgValue / count");const R=4*Math.floor(c/4),S=c%4,T=`\n      if (${$}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${l}, ${d}, ${h});\n      const ivec3 pads = ivec3(${w}, ${j}, ${E});\n      const float initializationValue = ${C};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${C});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${O};\n            wD += ${f}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${x};\n            wR += ${m}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${R}; wC += 4) {\n              int xC = xCCorner + wC * ${y};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${y}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${y}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${y}, ch)\n              );\n\n              ${T}\n            }\n\n            int xC = xCCorner + ${R};\n            if (${1===S}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${T}\n            } else if (${2===S}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${y}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${T}\n            } else if (${3===S}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${y}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${y}, ch),\n                initializationValue\n              );\n\n              ${T}\n            }\n          }\n          setOutput(${N});\n        }\n      }\n    `}}class Nn{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:o,outSize:c}=t;this.outputShape=[r,c];let l="0.0",d="";"prod"===e?l="1.0":"min"===e?(l="1.0 / 1e-20",d="min"):"max"===e&&(l="-1.0 / 1e-20",d="max");let h=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?h="sumValue":"prod"===e?h="prodValue":"all"===e?h="allValue":"any"===e&&(h="anyValue");const f=4*Math.floor(n/4),m=n%4;let y=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${d}(values, minMaxValue);\n      }\n    `,O="vec4";"all"===e?(l="1.0",y="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",O="bvec4"):"any"===e&&(l="0.0",y="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",O="bvec4");let x="";o%n>0&&(x=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${l};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${x}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${l});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${f}; i += 4) {\n          int inIdx = inOffset + i;\n          ${O} values = ${O}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${y}\n        }\n\n        int inIdx = inOffset + ${f};\n        if (${1===m}) {\n          ${O} values = ${O}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${y}\n        } else if (${2===m}) {\n          ${O} values = ${O}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${y}\n        } else if (${3===m}) {\n          ${O} values = ${O}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${y}\n        }\n        setOutput(${h});\n      }\n    `}}class Rn{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;let n="";for(let i=0;i<4;i++){let t="thisRC = rc;";i%2==1&&(t+="thisRC.z += 1;"),i>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${i>0?"}":""}\n      `}var r;this.userCode=`\n      ${r=e,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${Wt(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${Gt(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${t[1]};\n        int cols = ${t[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class Sn{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;const[,r,o]=e.shape,[,c,l]=t.shape,d=[n&&c>1?r-1:r,n&&l>1?o-1:o],h=[n&&c>1?c-1:c,n&&l>1?l-1:l],f=d[0]/h[0],m=d[1]/h[1],y=1/f,O=1/m,x=2*Math.ceil(y)+2,v=2*Math.ceil(O)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${f});\n        const float widthScale = float(${m});\n\n        const float invHeightScale = float(${y});\n        const float invWidthScale = float(${O});\n\n        const int winHeight = int(${x});\n        const int winWidth = int(${v});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${c}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${l}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class Tn{constructor(t,e,n,r){this.variableNames=["A"],this.outputShape=[];const[o,c,l,d]=t;this.outputShape=[o,e,n,d];const h=[r&&e>1?c-1:c,r&&n>1?l-1:l],f=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${h[0]/f[0]},\n          ${h[1]/f[1]});\n      const vec2 inputShapeRC = vec2(${c}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class In{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,c,l,d]=t;this.outputShape=[o,e,n,d];const h=[r&&e>1?c-1:c,r&&n>1?l-1:l],f=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${h[0]/f[0]},\n          ${h[1]/f[1]},\n          ${h[1]/f[1]});\n      const vec3 inputShapeRC = vec3(${c}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${d-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}class An{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;const[,r,o]=e.shape,[,c,l]=t.shape,d=[n&&c>1?r-1:r,n&&l>1?o-1:o],h=[n&&c>1?c-1:c,n&&l>1?l-1:l],f=d[0]/h[0],m=d[1]/h[1],y=1/f,O=1/m,x=2*Math.ceil(y)+2,v=2*Math.ceil(O)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${f});\n        const float widthScale = float(${m});\n\n        const float invHeightScale = float(${y});\n        const float invWidthScale = float(${O});\n\n        const int winHeight = int(${x});\n        const int winWidth = int(${v});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${c}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${l}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${d[0]}) *\n                (float(dyR) / float(${h[0]}));\n\n            float sourceFracCol =\n                float(${d[1]}) *\n                  (float(dyC) / float(${h[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class kn{constructor(t,e,n,r){this.variableNames=["A"],this.outputShape=[];const[o,c,l,d]=t;this.outputShape=[o,e,n,d];const h=[r&&e>1?c-1:c,r&&n>1?l-1:l],f=[r&&e>1?e-1:e,r&&n>1?n-1:n],m=r?"0.5":"0.0";this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${h[0]/f[0]},\n          ${h[1]/f[1]});\n      const vec2 inputShapeRC = vec2(${c}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class Dn{constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const r=t.map(((n,i)=>(i=>-1!==e.indexOf(i)&&1!==t[i]?`${t[i]} - coords[${i}] - 1`:`coords[${i}]`)(i))).join(","),o=ae(n);this.userCode=`\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class _n{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;const r=zt("rc",n),o=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,c=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,l=ae(n);function d(n){const r=t.map(((r,i)=>function(i,n){return-1!==e.indexOf(i)&&1!==t[i]?`${t[i]} - ${n[i]} - 1`:`${n[i]}`}(i,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${l} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(t){return d(t)}(r.slice())};\n          if(${o}){\n            result.g = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",d(t)}(r.slice())};\n          }\n          if(${c}) {\n            result.b = ${function(t){return t[n-2]="("+t[n-2]+" + 1)",d(t)}(r.slice())};\n            if(${o}) {\n              result.a = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",d(t)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}class Fn{constructor(t,e,n,r,o,c,l=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=c;const d=ae(o.length),h=ae(c.length);let f="";1===n?f="i":2===n&&(f="i, j");const m=`getIndices(${f})`;let y="";1===r?y="i":2===r&&(y="i, coords[1]");const O=`getUpdates(${y})`,x=e>1?"strides[j]":"strides";this.userCode=`\n        ${d} strides = ${d}(${o});\n\n        void main() {\n          ${h} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(${m});\n              flattenedIndex += index * ${x};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${O};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}class Pn{constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,r=t.batchSize,o=t.inSize,c=t.numSegments,l=c*Math.ceil(o/n);this.outputShape=[r,l];const d=4*Math.floor(n/4),h=n%4,f="\n        sumValue += dot(values, segFilter);\n    ";let m="";o%n>0&&(m=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `);let y="";o%n>0&&(y=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${m}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${y}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${c})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${c})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${d}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${f}\n        }\n\n        int inIdx = inOffset + ${d};\n        if (${1===h}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${f}\n        } else if (${2===h}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${f}\n        } else if (${3===h}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${f}\n        }\n        setOutput(sumValue);\n      }\n    `}}class Mn{constructor(t,e,n){let r,o;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)o="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],l=[];for(let i=0;i<e.length;i++)l.push(`${n[i]}`),i<t&&c.push(`${n[i]}`);r=c.join(),o=l.join()}const c=ae(n);this.userCode=`\n      void main() {\n        ${c} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}class Bn{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=ae(this.rank),n=`uniform int start[${this.rank}];`,r=function(t){if(1===t)return"sourceLoc";if(t<=6)return Ln.slice(0,t).map((t=>"sourceLoc."+t)).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let body;body=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map(((t,i)=>`sourceLoc.${Ln[i]} = start[${i}] + coords.${Ln[i]};`)).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${body}\n        setOutput(getSource(${r}));\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}const Ln=["x","y","z","w","u","v"];class Vn{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length;const e=ae(this.rank),n=zt("coords",this.rank),r=zt("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,c=`getChannel(getSource(${r.join()}), ${o})`,l=`\n      result.x = ${c};\n      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${c};\n        --${r[this.rank-1]};\n      }\n    `,d=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${c};\n        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${c};\n        }\n      }\n    `,h=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map(((t,i)=>`start[${i}]`)).join()});`:t.map(((t,i)=>`${r[i]} = ${n[i]} + start[${i}];`)).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${h}\n        vec4 result = vec4(0.);\n        ${l}\n        ${d}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}class zn{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,o=ae(n.length),c=ae(n.length);let l="";if(1===r)l="coords * strides + begin";else{let t=0;l=n.map(((e,i)=>(t++,1===n.length?`coords * strides[${i}] + begin[${i}]`:`coords[${t-1}] * strides[${i}] + begin[${i}]`))).join(",")}this.userCode=`\n      ${o} begin = ${o}(${t});\n      ${o} strides = ${o}(${e});\n\n      void main() {\n        ${c} coords = getOutputCoords();\n        setOutput(getX(${l}));\n      }\n    `}}class Un{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){const r=Gn(e,n),o=Hn(t,r,n);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const c=Wn(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=c,this.log();const t=this.freeTextures[o].shift();return this.usedTextures[o].push(t),t}let l;return r===m.PACKED_2X2_FLOAT32?l=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===m.PACKED_2X2_FLOAT16?l=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===m.UNPACKED_FLOAT32?l=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===m.UNPACKED_FLOAT16?l=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===m.PACKED_4X1_UNSIGNED_BYTE&&(l=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[o].push(l),this.numUsedTextures++,this._numBytesAllocated+=c,this.log(),l}releaseTexture(t,e,n,r){if(null==this.freeTextures)return;const c=Gn(n,r),l=Hn(e,c,r);l in this.freeTextures||(this.freeTextures[l]=[]);const d=Wn(e,c,this.gpgpu.gl,this.gpgpu.textureConfig,r),h=Object(o.bb)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==h&&this._numBytesAllocated>h?(this.gpgpu.deleteMatrixTexture(t),this._numBytesAllocated-=d):(this.freeTextures[l].push(t),this.numFreeTextures++,this._numBytesFree+=d),this.numUsedTextures--;const f=this.usedTextures[l],m=f.indexOf(t);if(m<0)throw new Error("Cannot release a texture that was never provided by this texture manager");f.splice(m,1),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t)}));for(const t in this.usedTextures)this.usedTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Wn(t,e,n,r,o){const c=function(t,e){switch(t){case m.PACKED_2X2_FLOAT32:return cn(e);case m.PACKED_2X2_FLOAT16:return un(e);case m.UNPACKED_FLOAT32:return an(e);case m.UNPACKED_FLOAT16:return sn(e);case m.PACKED_4X1_UNSIGNED_BYTE:return on(e);default:throw new Error(`Unknown physical texture type ${t}`)}}(e,r);let l;if(o){const[e,n]=x(t[0],t[1]);l=e*n}else{const[e,n]=y(t[0],t[1]);l=e*n}const d=function(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;throw new Error(`Unknown internal format ${e}`)}(n,c);return l*d}function Gn(t,e){if(t===f.UPLOAD)return m.PACKED_2X2_FLOAT32;if(t===f.RENDER||null==t)return function(t){return Object(o.bb)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?m.PACKED_2X2_FLOAT32:m.UNPACKED_FLOAT32:t?m.PACKED_2X2_FLOAT16:m.UNPACKED_FLOAT16}(e);if(t===f.DOWNLOAD||t===f.PIXELS)return m.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function Hn(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}class qn{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[i]*e[i];this.outputShape=n,this.rank=n.length;const r=ae(this.rank),o=function(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let i=0;i<t.length;i++)r.push(`imod(${n[i]}, ${t[i]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}class Kn{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Xn="return abs(x);",Yn="if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",Qn="if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Jn="return (x >= 0.0) ? x : (exp(x) - 1.0);",Zn=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${o.R.SELU_SCALEALPHA};\n  float scale = ${o.R.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`;const er="return -x;",nr="return ceil(x);",rr="return floor(x);",ar="return exp(x);",sr="return exp(x) - 1.0;",or=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${o.R.ERF_P};\n  float a1 = ${o.R.ERF_A1};\n  float a2 = ${o.R.ERF_A2};\n  float a3 = ${o.R.ERF_A3};\n  float a4 = ${o.R.ERF_A4};\n  float a5 = ${o.R.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`,ir="return x;",cr="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",ur="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",lr="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n";class dr{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class pr{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t;const e=t.length,n=zt("rc",e),r=ae(e),o=function(t,e){if(1===t)return"rc";let n="";for(let i=0;i<t;i++)n+=e[i],i<t-1&&(n+=",");return n}(e,n),c=n.slice(-2),l=e<=1?"rc":`vec2(${c.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${l}));\n      }\n    `}}const{segment_util:fr}=o.R,mr=o.hb.split,gr=o.hb.tile,yr=o.hb.topkImpl,Or=o.hb.whereImpl,xr={};function vr(t,e=!1){if("linear"===t)return"return x;";if("relu"===t)return e?cr:Yn;if("elu"===t)return e?lr:Jn;if("relu6"===t)return e?ur:Qn;if("prelu"===t)return e?ye:be;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class wr extends o.s{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!Object(o.bb)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==t){const t=d(Object(o.bb)().getNumber("WEBGL_VERSION"));this.binaryCache=((e=Object(o.bb)().getNumber("WEBGL_VERSION"))in xr||(xr[e]={}),xr[e]),this.gpgpu=new dn(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=t,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;var e;this.textureManager=new Un(this.gpgpu),this.numMBBeforeWarning=null==Object(o.bb)().global.screen?1024:Object(o.bb)().global.screen.height*Object(o.bb)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new o.j(this,Object(o.ab)())}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(t,e,n){if((Object(o.bb)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Object(o.bb)().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={};return this.texData.set(r,{shape:e,dtype:n,values:t,usage:f.UPLOAD,refCount:1}),r}incRef(t){this.texData.get(t).refCount++}decRef(t){if(this.texData.has(t)){this.texData.get(t).refCount--}}move(t,e,n,r){if(Object(o.bb)().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:r,values:e,usage:f.UPLOAD,refCount:1})}disposeIntermediateTensorInfo(t){const e=t.dataId;if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--,t.refCount<1&&this.disposeData(e)}}readSync(t){const e=this.texData.get(t),{values:n,dtype:r,complexTensors:c,slice:l,shape:d,isPacked:h}=e;if(null!=l){let e;e=h?new dr(d,ir):new Kn(d,ir);const n=this.runWebGLProgram(e,[{dataId:t,shape:d,dtype:r}],r),data=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),data}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===r)return n;const f=null!=this.activeTimers;let m,y;if(f&&(m=o.Eb.now()),"complex64"===r){const t=c.real.dataSync(),e=c.imag.dataSync();y=o.R.mergeRealAndImagArrays(t,e)}else y=this.getValuesFromTexture(t);return f&&(this.downloadWaitMs+=o.Eb.now()-m),this.convertAndCacheOnCPU(t,y)}async read(t){if(this.pendingRead.has(t)){const e=this.pendingRead.get(t);return new Promise((t=>e.push(t)))}const e=this.texData.get(t),{values:n,shape:r,slice:c,dtype:l,complexTensors:d,isPacked:h}=e;if(null!=c){let e;e=h?new dr(r,ir):new Kn(r,ir);const n=this.runWebGLProgram(e,[{dataId:t,shape:r,dtype:l}],l),data=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),data}if(null!=n)return this.convertAndCacheOnCPU(t);if(!Object(o.bb)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Object(o.bb)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let f,m,y=null;if("complex64"!==l&&Object(o.bb)().get("WEBGL_BUFFER_SUPPORTED")){f=this.decode(t);const e=this.texData.get(f.dataId);y=this.gpgpu.createBufferFromTexture(e.texture,...O(r))}if(this.pendingRead.set(t,[]),"complex64"!==l&&await this.gpgpu.createAndWaitForFence(),"complex64"===l){const t=await Promise.all([d.real.data(),d.imag.data()]),e=t[0],n=t[1];m=o.R.mergeRealAndImagArrays(e,n)}else if(null==y)m=this.getValuesFromTexture(t);else{const t=o.Eb.sizeFromShape(r);m=this.gpgpu.downloadFloat32MatrixFromBuffer(y,t)}null!=f&&this.disposeIntermediateTensorInfo(f);const x=this.convertAndCacheOnCPU(t,m),v=this.pendingRead.get(t);return this.pendingRead.delete(t),v.forEach((t=>t(x))),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t),this.pendingDeletes--),x}checkNumericalProblems(t){if(null!=t)for(let i=0;i<t.length;i++){const e=t[i];if(!j(e)){if(Object(o.bb)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${e} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${e} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:r}=this.texData.get(t),c=o.Eb.sizeFromShape(e);if(Object(o.bb)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),r=this.texData.get(n.dataId),o=this.gpgpu.downloadMatrixFromPackedTexture(r.texture,...O(e)).subarray(0,c);return this.disposeIntermediateTensorInfo(n),o}const l=Object(o.bb)().getBool("WEBGL_PACK")&&!0===r,d=l?P(e):e,h=l?new Ge(d):new We(d),output=this.runWebGLProgram(h,[{shape:d,dtype:n,dataId:t}],"float32"),f=this.texData.get(output.dataId),m=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(f.texture,f.texShape[0],f.texShape[1]).subarray(0,c);return this.disposeIntermediateTensorInfo(output),m}async time(t){const e=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,t();const c=o.Eb.flatten(this.activeTimers.map((t=>t.query))).filter((t=>null!=t)),l=o.Eb.flatten(this.activeTimers.map((t=>t.name))).filter((t=>null!=t));this.activeTimers=e,r&&(this.programTimersStack=null);const d={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(Object(o.bb)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(c);d.kernelMs=o.Eb.sum(t),d.getExtraProfileInfo=()=>t.map(((t,i)=>({name:l[i],ms:t}))).map((t=>`${t.name}: ${t.ms}`)).join(", ")}else d.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,d}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Object(o.bb)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:o.Eb.now(),endMs:null}}endTimer(t){return Object(o.bb)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=o.Eb.now(),t)}async getQueryTime(t){if(Object(o.bb)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t){if(this.pendingDisposal.has(t))return;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),void this.pendingDeletes++;if(!this.texData.has(t))return;this.releaseGPUData(t);const{complexTensors:e}=this.texData.get(t);null!=e&&(e.real.dispose(),e.imag.dispose()),this.texData.delete(t)}releaseGPUData(t){const{texture:e,dtype:n,texShape:r,usage:o,isPacked:c,slice:l}=this.texData.get(t),d=l&&l.origDataId||t,h=this.dataRefCount.get(d);h>1?this.dataRefCount.set(d,h-1):(this.dataRefCount.delete(d),null!=e&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(e,r,o,c)));const f=this.texData.get(t);f.texture=null,f.texShape=null,f.isPacked=!1,f.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture}getDataInfo(t){return this.texData.get(t)}getCPUBackend(){return Object(o.bb)().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=Object(o.ab)().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(t,e=128){const n=this.getCPUBackend();return this.warnedAboutCPUBackend||null!=n||(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),null!=n&&t.every((input=>null==this.texData.get(input.dataId).texture&&o.Eb.sizeFromShape(input.shape)<e))}getGPGPUContext(){return this.gpgpu}complex(t,e){const n=this.makeOutput(t.shape,"complex64");return this.texData.get(n.dataId).complexTensors={real:Object(o.ab)().keep(t.clone()),imag:Object(o.ab)().keep(e.clone())},n}real(input){return this.texData.get(input.dataId).complexTensors.real.clone()}imag(input){return this.texData.get(input.dataId).complexTensors.imag.clone()}slice(t,e,n){if(this.shouldExecuteOnCPU([t])){const r=Dt(this.texData.get(t.dataId).values,e,n,t.shape,t.dtype);return this.makeOutput(n,t.dtype,r)}if(0===o.Eb.sizeFromShape(n))return Object(o.xb)([],n,t.dtype);const{isPacked:r}=this.texData.get(t.dataId),c=o.sb.isSliceContinous(t.shape,e,n);if(r||!c){const r=Object(o.bb)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Vn(n):new Bn(n),c=r.getCustomSetupFunc(e);return this.compileAndRun(r,[t],null,c)}return this.uploadToGPU(t.dataId),this.shallowSlice(t,e,n)}shallowSlice(t,e,n){const r=this.texData.get(t.dataId),c=this.makeOutput(n,t.dtype),l=this.texData.get(c.dataId);Object.assign(l,r),l.shape=n,l.dtype=t.dtype;let d=o.sb.computeFlatOffset(e,t.strides);r.slice&&(d+=r.slice.flatOffset),l.slice={flatOffset:d,origDataId:r.slice&&r.slice.origDataId||t.dataId};const h=this.dataRefCount.get(l.slice.origDataId)||1;return this.dataRefCount.set(l.slice.origDataId,h+1),c}stridedSlice(t,e,n,r){const c=this.tryRunOnCpuOrThrow([t],(()=>this.cpuBackend.stridedSlice(t,e,n,r)));if(c)return c;const l=o.sb.computeOutShape(e,n,r);if(l.some((t=>0===t)))return Object(o.xb)([],l);const d=new zn(e,r,l);return this.compileAndRun(d,[t])}reverse(t,e){const n=Object(o.bb)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _n(t.shape,e):new Dn(t.shape,e);return this.compileAndRun(n,[t])}concat(t,e){if("complex64"===t[0].dtype){const n=t.map((t=>Object(o.lb)(t))),r=t.map((t=>Object(o.db)(t)));return Object(o.V)(this.concat(n,e),this.concat(r,e))}if(1===t.length)return t[0];if(t.length>Object(o.bb)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const n=Math.floor(t.length/2),r=this.concat(t.slice(0,n),e),o=this.concat(t.slice(n),e);return this.concat([r,o],e)}if(Object(o.bb)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].rank>1){const n=new Ee(t.map((t=>t.shape)),e);return this.compileAndRun(n,t)}const n=o.R.computeOutShape(t.map((t=>t.shape)),e),r=t.map((t=>t.as2D(-1,o.Eb.sizeFromShape(t.shape.slice(e))))),c=new je(r.map((t=>t.shape)));return this.compileAndRun(c,r).reshape(n)}neg(t){const e=this.tryRunOnCpuOrThrow([t],(()=>this.cpuBackend.neg(t)));if(e)return e;if(Object(o.bb)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,er,t.dtype);const n=new Kn(t.shape,er);return this.compileAndRun(n,[t])}batchMatMul(a,b,t,e){const n=t?a.shape[2]:a.shape[1],r=e?b.shape[1]:b.shape[2],c=t?a.shape[1]:a.shape[2],[l,,]=a.shape;if((1===n||1===r)&&c>1e3){t&&(a=Object(o.Bb)(a,[0,2,1])),e&&(b=Object(o.Bb)(b,[0,2,1]));const n=1===r?a:a.as3D(l,c,1),d=1===r?2:1,h=1===r?b.as3D(l,1,c):b;return this.multiply(n,h).sum(d,!0)}const d=Object(o.Db)(a.dtype,b.dtype),h=new On(a.shape,[l,n,r],t,e);return this.compileAndRun(h,[a,b],d)}fusedBatchMatMul({a:a,b:b,transposeA:t,transposeB:e,bias:n,activation:r,preluActivationWeights:c}){const l=t?a.shape[2]:a.shape[1],d=e?b.shape[1]:b.shape[2],[h,,]=a.shape,f=Object(o.Db)(a.dtype,b.dtype),m=null!=n,y=null!=c,O=r?vr(r,!0):null,x=new On(a.shape,[h,l,d],t,e,m,O,y),v=[a,b];return n&&v.push(n),c&&v.push(c),this.compileAndRun(x,v,f)}multiply(a,b){if("complex64"===a.dtype){const t=this.texData.get(a.dataId),e=this.texData.get(b.dataId),n=new pe(le,a.shape,b.shape),r=new pe(de,a.shape,b.shape),o=[this.makeComplexComponentTensorInfo(a,t.complexTensors.real),this.makeComplexComponentTensorInfo(a,t.complexTensors.imag),this.makeComplexComponentTensorInfo(b,e.complexTensors.real),this.makeComplexComponentTensorInfo(b,e.complexTensors.imag)],c=this.compileAndRun(n,o),l=this.compileAndRun(r,o),d=this.complex(c,l);return c.dispose(),l.dispose(),d}const t=Object(o.Db)(a.dtype,b.dtype);if(this.shouldExecuteOnCPU([a,b])){const e=this.texData.get(a.dataId),n=this.texData.get(b.dataId),[r,o]=At(a.shape,b.shape,e.values,n.values,t);return this.makeOutput(o,t,r)}if(Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,me,a.dtype);const e=new ge(me,a.shape,b.shape);return this.compileAndRun(e,[a,b],a.dtype)}localResponseNormalization4D(t,e,n,r,c){const l=Object(o.bb)().getBool("WEBGL_PACK_NORMALIZATION")?new bn(t.shape,e,n,r,c):new fn(t.shape,e,n,r,c);return this.compileAndRun(l,[t])}LRNGrad(t,e,n,r,o,c,l){const d=new mn(e.shape,r,o,c,l);return this.compileAndRun(d,[e,n,t])}tile(t,e){if("string"===t.dtype){const n=this.readSync(t.dataId).map((t=>o.Eb.decodeString(t))),r=Object(o.T)(t.shape,t.dtype,n);return gr(r,e)}const n=new qn(t.shape,e);return this.compileAndRun(n,[t])}pad(t,e,n){const r=Object(o.bb)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new En(t.shape,e,n):new jn(t.shape,e,n);return this.compileAndRun(r,[t])}gather(t,e,n){const r=this.tryRunOnCpuOrThrow([t,e],(()=>this.cpuBackend.gather(t,e,n)));if(r)return r;const o=new Je(t.shape,e.size,n);return this.compileAndRun(o,[t,e])}batchToSpaceND(t,e,n){o.Eb.assert(t.rank<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const r=e.reduce(((a,b)=>a*b)),c=o.R.getReshaped(t.shape,e,r),l=o.R.getPermuted(c.length,e.length),d=o.R.getReshapedPermuted(t.shape,e,r),h=o.R.getSliceBeginCoords(n,e.length),f=o.R.getSliceSize(d,n,e.length);return Object(o.Bb)(t.reshape(c),l).reshape(d).slice(h,f)}spaceToBatchND(t,e,n){o.Eb.assert(t.rank<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const r=e.reduce(((a,b)=>a*b)),c=[[0,0]];c.push(...n);for(let i=1+e.length;i<t.shape.length;++i)c.push([0,0]);const l=t.pad(c),d=o.R.getReshaped(l.shape,e,r,!1),h=o.R.getPermuted(d.length,e.length,!1),f=o.R.getReshapedPermuted(l.shape,e,r,!1),m=Object(o.Bb)(l.reshape(d),h);return Object(o.ob)(m,f)}reduce(t,e,n){const r=t.shape[0],c=t.shape[1],l=o.R.computeOptimalWindowSize(c),d=Math.ceil(c/l),h=new Nn({windowSize:l,inSize:c,batchSize:r,outSize:d},e),output=this.compileAndRun(h,[t],n);return 1===output.shape[1]?output:this.reduce(output,e,n)}argReduce(t,e,n=null){let r=t.shape[0],c=t.shape[1];null!=n&&(r=n.shape[0],c=n.shape[1]);const l=o.R.computeOptimalWindowSize(c),d={windowSize:l,inSize:c,batchSize:r,outSize:Math.ceil(c/l)},h=new Lt(d,e,null==n),f=[t];null!=n&&f.push(n);const output=this.compileAndRun(h,f,"int32");return 1===output.shape[1]?output:this.argReduce(t,e,output)}argReducePacked(t,e,n=null){const r=null!=n?n.shape:t.shape,c=r[r.length-1],l=o.R.computeOptimalWindowSize(c),d=new ie(r,l,e,null==n),h=null==n?[t]:[t,n],output=this.compileAndRun(d,h,"int32");return output.rank===t.rank?this.argReducePacked(t,e,output):output}sum(t,e){o.R.assertAxesAreInnerMostDims("sum",e,t.rank);const[n,r]=o.R.computeOutAndReduceShapes(t.shape,e),c=o.Eb.sizeFromShape(r),l=t.as2D(-1,c),d=o.wb(t.dtype);return this.reduce(l,"sum",d).reshape(n)}prod(t,e){const n=this.tryRunOnCpuOrThrow([t],(()=>this.cpuBackend.prod(t,e)));if(n)return n;const[r,c]=o.R.computeOutAndReduceShapes(t.shape,e),l=o.Eb.sizeFromShape(c),d=t.as2D(-1,l),h=o.wb(t.dtype);return this.reduce(d,"prod",h).reshape(r)}unsortedSegmentSum(t,e,n){let r=0;const c=o.R.getAxesPermutation([r],t.rank);let l=t;null!=c&&(l=Object(o.Bb)(t,c),r=o.R.getInnerMostAxes(1,t.rank)[0]);const d=fr.computeOutShape(l.shape,r,n),h=o.Eb.sizeFromShape([l.shape[r]]),f=l.as2D(-1,h),m=o.wb(t.dtype);let y=this.segOpCompute(f,"unsortedSegmentSum",e,m,n).reshape(d);return null!=c&&(y=Object(o.Bb)(y,o.R.getUndoAxesPermutation(c))),y}segOpCompute(t,e,n,r,c){const l=t.shape[0],d=t.shape[1],h=fr.segOpComputeOptimalWindowSize(d,c),f=new Pn({windowSize:h,inSize:d,batchSize:l,numSegments:c},e),output=this.compileAndRun(f,[t,n],r);return output.shape[1]===c?output:(n=Object(o.kb)(0,c).tile([d/h]),this.segOpCompute(output,e,n,r,c))}argMinMaxReduce(t,e,n){const r=[e];if(o.R.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),r,t.rank),!Object(o.bb)().getBool("WEBGL_PACK_REDUCE")||t.rank<=2){const[e,c]=o.R.computeOutAndReduceShapes(t.shape,r),l=o.Eb.sizeFromShape(c),d=t.as2D(-1,l);return this.argReduce(d,n).reshape(e)}return this.argReducePacked(t,n)}argMin(t,e){return this.argMinMaxReduce(t,e,"min")}argMax(t,e){return this.argMinMaxReduce(t,e,"max")}cumsum(t,e,n,r){if(e!==t.rank-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${t.rank-1} but got axis=${e}`);const o=t.shape[e];let c=t;for(let i=0;i<=Math.ceil(Math.log2(o))-1;i++){const e=new Pe(t.shape,!1,r),n=e.getCustomSetupFunc(i),o=c;c=this.compileAndRun(e,[c],c.dtype,n),o.dispose()}if(n){const e=new Pe(t.shape,n,r),o=c;c=this.compileAndRun(e,[c]),o.dispose()}return c}equal(a,b){if(Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,"\n  return vec4(equal(a, b));\n","bool");const t=new ge("return float(a == b);",a.shape,b.shape);return this.compileAndRun(t,[a,b],"bool")}notEqual(a,b){if(Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,"\n  return vec4(notEqual(a, b));\n","bool");const t=new ge("return float(a != b);",a.shape,b.shape);return this.compileAndRun(t,[a,b],"bool")}less(a,b){const t=this.tryRunOnCpuOrThrow([a,b],(()=>this.cpuBackend.less(a,b)));if(t)return t;if(Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,"\n  return vec4(lessThan(a, b));\n","bool");const e=new ge("return float(a < b);",a.shape,b.shape);return this.compileAndRun(e,[a,b],"bool")}lessEqual(a,b){if(Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,"\n  return vec4(lessThanEqual(a, b));\n","bool");const t=new ge("return float(a <= b);",a.shape,b.shape);return this.compileAndRun(t,[a,b],"bool")}greater(a,b){const t=this.tryRunOnCpuOrThrow([a,b],(()=>this.cpuBackend.greater(a,b)));if(t)return t;if(Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,"\n  return vec4(greaterThan(a, b));\n","bool");const e=new ge("return float(a > b);",a.shape,b.shape);return this.compileAndRun(e,[a,b],"bool")}greaterEqual(a,b){if(Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,"\n  return vec4(greaterThanEqual(a, b));\n","bool");const t=new ge("return float(a >= b);",a.shape,b.shape);return this.compileAndRun(t,[a,b],"bool")}logicalNot(t){const e=new Kn(t.shape,"return float(!(x >= 1.0));");return this.compileAndRun(e,[t])}logicalAnd(a,b){if(Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");const t=new ge("return float(a >= 1.0 && b >= 1.0);",a.shape,b.shape);return this.compileAndRun(t,[a,b],"bool")}logicalOr(a,b){if(Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");const t=new ge("return float(a >= 1.0 || b >= 1.0);",a.shape,b.shape);return this.compileAndRun(t,[a,b],"bool")}select(t,a,b){const e=new Mn(t.rank,a.shape,a.rank);return this.compileAndRun(e,[t,a,b],Object(o.Db)(a.dtype,b.dtype))}where(t){o.R.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return Or(t.shape,e)}topk(t,e,n){const r=t.dataSync();return yr(r,t.shape,t.dtype,e,n)}min(t,e){o.R.assertAxesAreInnerMostDims("min",e,t.rank);const[n,r]=o.R.computeOutAndReduceShapes(t.shape,e),c=o.Eb.sizeFromShape(r),l=t.as2D(-1,c);return this.reduce(l,"min",l.dtype).reshape(n)}minimum(a,b){const t=this.tryRunOnCpuOrThrow([a,b],(()=>this.cpuBackend.minimum(a,b)));if(t)return t;const e=Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Oe("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",a.shape,b.shape):new ge("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",a.shape,b.shape);return this.compileAndRun(e,[a,b])}mod(a,b){const t=Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Oe("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",a.shape,b.shape):new ge("if (b == 0.0) return NAN;\n  return mod(a, b);",a.shape,b.shape);return this.compileAndRun(t,[a,b])}maximum(a,b){const t=this.tryRunOnCpuOrThrow([a,b],(()=>this.cpuBackend.maximum(a,b)));if(t)return t;const e=Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Oe("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",a.shape,b.shape):new ge("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",a.shape,b.shape);return this.compileAndRun(e,[a,b])}all(t,e){o.R.assertAxesAreInnerMostDims("all",e,t.rank);const[n,r]=o.R.computeOutAndReduceShapes(t.shape,e),c=o.Eb.sizeFromShape(r),l=t.as2D(-1,c);return this.reduce(l,"all",l.dtype).reshape(n)}any(t,e){o.R.assertAxesAreInnerMostDims("any",e,t.rank);const[n,r]=o.R.computeOutAndReduceShapes(t.shape,e),c=o.Eb.sizeFromShape(r),l=t.as2D(-1,c);return this.reduce(l,"any",l.dtype).reshape(n)}floorDiv(a,b){const t="int32";if(Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",t);const e=new ge("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",a.shape,b.shape);return this.compileAndRun(e,[a,b],t)}add(a,b){if("complex64"===a.dtype&&"complex64"===b.dtype)return this.complexSeparableBinaryOp(a,b,he);const t=Object(o.Db)(a.dtype,b.dtype);if(this.shouldExecuteOnCPU([a,b])){const e=this.texData.get(a.dataId),n=this.texData.get(b.dataId),[r,o]=$t(a.shape,b.shape,e.values,n.values,t);return this.makeOutput(o,t,r)}if(Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,he,t);const e=new ge(he,a.shape,b.shape);return this.compileAndRun(e,[a,b],t)}packedUnaryOp(t,e,n){const r=new dr(t.shape,e);return this.compileAndRun(r,[t],n)}packedBinaryOp(a,b,t,e,n=!1){const r=new Oe(t,a.shape,b.shape,n);return this.compileAndRun(r,[a,b],e)}complexSeparableBinaryOp(a,b,t){const e=this.texData.get(a.dataId),n=this.texData.get(b.dataId),[r,c]=[[e.complexTensors.real,n.complexTensors.real],[e.complexTensors.imag,n.complexTensors.imag]].map((e=>{const[n,r]=e,c=this.makeComplexComponentTensorInfo(a,n),l=this.makeComplexComponentTensorInfo(b,r),d=new ge(t,a.shape,b.shape);return this.compileAndRun(d,[c,l],Object(o.Db)(n.dtype,r.dtype))})),l=this.complex(r,c);return r.dispose(),c.dispose(),l}makeComplexComponentTensorInfo(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}addN(t){if(1===t.length)return t[0];if(t.length>Object(o.bb)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(t.length/2),n=this.addN(t.slice(0,e)),r=this.addN(t.slice(e));return this.addN([n,r])}const e=t.map((t=>t.dtype)).reduce(((t,e)=>Object(o.Db)(t,e))),n=t.map((t=>t.shape)),r=Object(o.bb)().getBool("WEBGL_PACK")?new Bt(t[0].shape,n):new Mt(t[0].shape,n);return this.compileAndRun(r,t,e)}subtract(a,b){if("complex64"===a.dtype&&"complex64"===b.dtype)return this.complexSeparableBinaryOp(a,b,fe);const t=Object(o.Db)(a.dtype,b.dtype);if(this.shouldExecuteOnCPU([a,b])){const e=this.texData.get(a.dataId),n=this.texData.get(b.dataId),[r,o]=_t(a.shape,b.shape,e.values,n.values,t);return this.makeOutput(o,t,r)}if(Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,fe,a.dtype);const e=new ge(fe,a.shape,b.shape);return this.compileAndRun(e,[a,b],t)}pow(a,b){const t=Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Oe("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",a.shape,b.shape):new ge("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",a.shape,b.shape),e=Object(o.Db)(a.dtype,b.dtype);return this.compileAndRun(t,[a,b],e)}ceil(t){if(this.shouldExecuteOnCPU([t])){const e=Ct(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,e)}if(Object(o.bb)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,nr,t.dtype);const e=new Kn(t.shape,nr);return this.compileAndRun(e,[t])}floor(t){if(this.shouldExecuteOnCPU([t])){const e=St(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,e)}if(Object(o.bb)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,rr,t.dtype);const e=new Kn(t.shape,rr);return this.compileAndRun(e,[t])}sign(t){const e=new Kn(t.shape,"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(e,[t])}isNaN(t){const e=new Kn(t.shape,"return float(isnan(x));");return this.compileAndRun(e,[t],"bool")}isInf(t){const e=new Kn(t.shape,"return float(isinf(x));");return this.compileAndRun(e,[t],"bool")}isFinite(t){const e=new Kn(t.shape,"return float(!isnan(x) && !isinf(x));");return this.compileAndRun(e,[t],"bool")}round(t){const e=new Kn(t.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(e,[t])}exp(t){if(this.shouldExecuteOnCPU([t])){const e=Nt(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,e)}if(Object(o.bb)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,ar,t.dtype);const e=new Kn(t.shape,ar);return this.compileAndRun(e,[t])}expm1(t){if(this.shouldExecuteOnCPU([t])){const e=Rt(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,e)}if(Object(o.bb)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,sr,t.dtype);const e=new Kn(t.shape,sr);return this.compileAndRun(e,[t])}softmax(t,e){const n=o.Eb.parseAxisParam([e],t.shape),r=Object(o.ib)(t,n),c=o.R.expandShapeToKeepDim(r.shape,n),a=this.subtract(t,r.reshape(c)),b=this.exp(a),l=this.sum(b,n).reshape(c);return Object(o.Z)(b,l)}log(t){if(this.shouldExecuteOnCPU([t])){const e=Tt(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,e)}if(Object(o.bb)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",t.dtype);const e=new Kn(t.shape,"if (x < 0.0) return NAN;\n  return log(x);");return this.compileAndRun(e,[t])}log1p(t){const e=new Kn(t.shape,"return log(1.0 + x);");return this.compileAndRun(e,[t])}sqrt(t){const e=new Kn(t.shape,"return sqrt(x);");return this.compileAndRun(e,[t])}rsqrt(t){if(this.shouldExecuteOnCPU([t])){const e=kt(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,e)}const e=new Kn(t.shape,"return inversesqrt(x);");return this.compileAndRun(e,[t])}reciprocal(t){const e=new Kn(t.shape,"return 1.0 / x;");return this.compileAndRun(e,[t])}relu(t){let e;return e=Object(o.bb)().getBool("WEBGL_PACK")?new dr(t.shape,cr):new Kn(t.shape,Yn),this.compileAndRun(e,[t])}relu6(t){let e;return e=Object(o.bb)().getBool("WEBGL_PACK")?new dr(t.shape,ur):new Kn(t.shape,Qn),this.compileAndRun(e,[t])}prelu(t,e){const n=Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Oe(ye,t.shape,e.shape):new ge(be,t.shape,e.shape);return this.compileAndRun(n,[t,e])}elu(t){if(Object(o.bb)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,lr,t.dtype);const e=new Kn(t.shape,Jn);return this.compileAndRun(e,[t])}eluDer(t,e){const n=Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Oe("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",t.shape,e.shape):new ge("return (b >= 1.0) ? a : a * (b + 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e])}selu(t){const e=new Kn(t.shape,Zn);return this.compileAndRun(e,[t])}int(t){const e=new Kn(t.shape,"return float(int(x));");return this.compileAndRun(e,[t],"int32")}clip(t,e,n){let r;r=Object(o.bb)().getBool("WEBGL_PACK_CLIP")?new ve(t.shape):new xe(t.shape);const c=r.getCustomSetupFunc(e,n);return this.compileAndRun(r,[t],null,c)}abs(t){if(this.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const e=Et(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,e)}if(Object(o.bb)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Xn,t.dtype);const e=new Kn(t.shape,Xn);return this.compileAndRun(e,[t])}complexAbs(t){const e=this.texData.get(t.dataId),n=new we(t.shape),r=[this.makeComplexComponentTensorInfo(t,e.complexTensors.real),this.makeComplexComponentTensorInfo(t,e.complexTensors.imag)];return this.compileAndRun(n,r)}sigmoid(t){const e=new Kn(t.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(e,[t])}softplus(t){const e=new Kn(t.shape,"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");return this.compileAndRun(e,[t])}asin(t){const e=new Kn(t.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n");return this.compileAndRun(e,[t])}acos(t){const e=new Kn(t.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n");return this.compileAndRun(e,[t])}atan(t){const e=new Kn(t.shape,"if (isnan(x)) return x;\n  return atan(x);\n");return this.compileAndRun(e,[t])}sinh(t){const e=new Kn(t.shape,"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])}cosh(t){const e=new Kn(t.shape,"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])}tanh(t){const e=new Kn(t.shape,"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(e,[t])}asinh(t){const e=new Kn(t.shape,"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));");return this.compileAndRun(e,[t])}acosh(t){const e=new Kn(t.shape,"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));");return this.compileAndRun(e,[t])}atanh(t){const e=new Kn(t.shape,"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;");return this.compileAndRun(e,[t])}erf(t){const e=new Kn(t.shape,or);return this.compileAndRun(e,[t])}step(t,e){const n=new Kn(t.shape,function(t=0){return`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t});\n  `}(e));return this.compileAndRun(n,[t])}conv2dByMatMul(t,filter,e,n,r,c){const l=t.shape,d=this.texData.get(t.dataId),h=e.inChannels,f=l[0]*l[1]*l[2],m=e.outChannels,y="channelsLast"===e.dataFormat,O=(1===f||1===m)&&h>1e3,x=l[2]%2!=0&&!!d.isPacked;if(O||!Object(o.bb)().getBool("WEBGL_LAZILY_UNPACK")||!Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!x){const d=y?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],h=Object(o.ob)(t,[1,d,e.inChannels]),f=Object(o.ob)(filter,[1,e.inChannels,e.outChannels]),m=this.fusedBatchMatMul({a:h,b:f,transposeA:false,transposeB:false,bias:n,activation:r,preluActivationWeights:c});return Object(o.ob)(m,e.outShape)}const v=y?l[0]*l[1]*(l[2]+1):l[0]*l[2]*(l[3]+1),w={dataId:t.dataId,shape:[1,v,e.inChannels],dtype:t.dtype},j=d.shape;d.shape=d.shape.slice(),d.shape[d.shape.length-2]++,o.Eb.assert(B(d.shape,w.shape),(()=>`packed reshape ${d.shape} to ${w.shape} isn't free`));const E=Object(o.ob)(filter,[1,e.inChannels,e.outChannels]),$=this.fusedBatchMatMul({a:w,b:E,transposeA:false,transposeB:false,bias:n,activation:r,preluActivationWeights:c}),C=this.texData.get($.dataId);return o.Eb.assert(C.isPacked,(()=>"batchMatMul result is expected to be packed")),d.shape=j,C.shape=e.outShape,Object(o.ab)().makeTensorFromDataId($.dataId,e.outShape,$.dtype)}conv2dWithIm2Row(t,filter,e,n,r,o){const{filterWidth:c,filterHeight:l,inChannels:d,outWidth:h,outHeight:f,dataFormat:m}=e,y="channelsLast"===m,O=c*l*d,x=f*h,v=[O,x],w=t.squeeze([0]),j=filter.reshape([1,O,-1]),E=new hn(v,w.shape,e),$=this.compileAndRun(E,[w]).reshape([1,v[0],v[1]]),C=null!=n,N=null!=o,R=r?vr(r,!0):null,S=new On($.shape,[1,x,e.outChannels],!0,!1,C,R,N),T=[$,j];n&&T.push(n),N&&T.push(o);const I=this.compileAndRun(S,T);return y?I.reshape([1,f,h,e.outChannels]):I.reshape([1,e.outChannels,f,h])}fusedConv2d({input:input,filter:filter,convInfo:t,bias:e,activation:n,preluActivationWeights:r}){if(1===t.filterHeight&&1===t.filterWidth&&1===t.dilationHeight&&1===t.dilationWidth&&1===t.strideHeight&&1===t.strideWidth&&("SAME"===t.padInfo.type||"VALID"===t.padInfo.type))return this.conv2dByMatMul(input,filter,t,e,n,r);if(Object(o.bb)().getBool("WEBGL_CONV_IM2COL")&&1===input.shape[0])return this.conv2dWithIm2Row(input,filter,t,e,n,r);const c=null!=e,l=null!=r,d=n?vr(n,!1):null,h=new Ae(t,c,d,l),f=[input,filter];return e&&f.push(e),r&&f.push(r),this.compileAndRun(h,f)}conv2d(t,filter,e){if(1===e.filterHeight&&1===e.filterWidth&&1===e.dilationHeight&&1===e.dilationWidth&&1===e.strideHeight&&1===e.strideWidth&&("SAME"===e.padInfo.type||"VALID"===e.padInfo.type))return this.conv2dByMatMul(t,filter,e);if(Object(o.bb)().getBool("WEBGL_CONV_IM2COL")&&1===t.shape[0])return this.conv2dWithIm2Row(t,filter,e);const n=new Ae(e);return this.compileAndRun(n,[t,filter])}conv2dDerInput(t,filter,e){const n=new Ne(e);return this.compileAndRun(n,[t,filter])}conv2dDerFilter(t,e,n){const r=new Ce(n);return this.compileAndRun(r,[t,e])}fusedDepthwiseConv2D({input:input,filter:filter,convInfo:t,bias:e,activation:n,preluActivationWeights:r}){const c=Object(o.bb)().getBool("WEBGL_PACK_DEPTHWISECONV")&&t.strideWidth<=2&&t.outChannels/t.inChannels==1,l=n?vr(n,c):null,d=[input,filter],h=null!=e,f=null!=r;let m;return h&&d.push(e),f&&d.push(r),c?(m=new _e(t,h,l,f),this.compileAndRun(m,d)):(m=new De(t,h,l,f),this.compileAndRun(m,d))}depthwiseConv2D(t,filter,e){let n;return Object(o.bb)().getBool("WEBGL_PACK_DEPTHWISECONV")&&e.strideWidth<=2&&e.outChannels/e.inChannels==1?(n=new _e(e),this.compileAndRun(n,[t,filter])):(n=new De(e),this.compileAndRun(n,[t,filter]))}depthwiseConv2DDerInput(t,filter,e){const n=new Ie(e);return this.compileAndRun(n,[t,filter])}depthwiseConv2DDerFilter(t,e,n){const r=new Te(n);return this.compileAndRun(r,[t,e])}conv3d(t,filter,e){const n=new ke(e);return this.compileAndRun(n,[t,filter])}conv3dDerInput(t,filter,e){const n=new Se(e);return this.compileAndRun(n,[t,filter])}conv3dDerFilter(t,e,n){const r=new Re(n);return this.compileAndRun(r,[t,e])}cast(t,e){return o.R.castTensor(t,e,this)}unstack(t,e){const n=t.shape[e],r=new Array(t.rank-1);let o=0;for(let i=0;i<t.rank;i++)i!==e&&(r[o++]=t.shape[i]);const c=new Array(t.rank).fill(0),l=t.shape.slice();l[e]=1;const d=new Array(n);for(let i=0;i<d.length;i++)c[e]=i,d[i]=this.slice(t,c,l).reshape(r);return d}avgPool3d(t,e){const n=new Cn(e,"avg",!1);return this.compileAndRun(n,[t],"float32")}avgPool3dBackprop(t,e,n){const r=new ue(n);return this.compileAndRun(r,[t],e.dtype)}maxPool3d(t,e){const n=new Cn(e,"max",!1);return this.compileAndRun(n,[t],"float32")}maxPool3dBackprop(t,e,n,r){const o=new Cn(r,"max",!0),c=this.compileAndRun(o,[e]),l=new yn(r),d=this.compileAndRun(l,[t,c],e.dtype);return c.dispose(),d}resizeBilinear(t,e,n,r){const c=Object(o.bb)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new In(t.shape,e,n,r):new Tn(t.shape,e,n,r);return this.compileAndRun(c,[t],"float32")}resizeBilinearBackprop(t,e,n){const r=new Sn(t,e,n);return this.compileAndRun(r,[t])}resizeNearestNeighbor(t,e,n,r){const o=new kn(t.shape,e,n,r);return this.compileAndRun(o,[t])}resizeNearestNeighborBackprop(t,e,n){const r=new An(t,e,n);return this.compileAndRun(r,[t])}multinomial(t,e,n,r){const c=e?t:Object(o.tb)(t),l=c.shape[0],d=c.shape[1],h=new xn(l,d,n),f=h.getCustomSetupFunc(r);return this.compileAndRun(h,[c],"int32",f)}oneHot(t,e,n,r){const o=new vn(t.size,e,n,r);return this.compileAndRun(o,[t])}diag(t){const e=new Ue(t.size);return this.compileAndRun(e,[t])}cropAndResize(image,t,e,n,r,o){const c=new Fe(image.shape,t.shape,n,r,o);return this.compileAndRun(c,[image,t,e],"float32")}depthToSpace(t,e,n){o.Eb.assert(e>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`));const r=t.shape[0],c="NHWC"===n?t.shape[1]:t.shape[2],l="NHWC"===n?t.shape[2]:t.shape[3],d="NHWC"===n?t.shape[3]:t.shape[1],h=c*e,f=l*e,m=d/(e*e),y=new ze("NHWC"===n?[r,h,f,m]:[r,m,h,f],e,n);return this.compileAndRun(y,[t])}split(t,e,n){return mr(t,e,n)}scatterND(t,e,n){const{sliceRank:r,numUpdates:c,sliceSize:l,strides:d,outputSize:h}=o.R.calculateShapes(e,t,n),f=[h/l,l],m=t.reshape([c,r]),y=e.reshape([c,l]);if(0===h)return o.R.reshapeTensor(Object(o.xb)([]),n);const O=Object(o.pb)(0),x=new Fn(c,r,m.rank,y.rank,d,f);return this.compileAndRun(x,[y,m,O]).reshape(n)}sparseToDense(t,e,n,r){const{sliceRank:c,numUpdates:l,strides:d,outputSize:h}=o.R.calculateShapes(e,t,n),f=new Fn(l,c,t.rank,e.rank,d,[h,1],!1);return this.compileAndRun(f,[e,t,r]).reshape(n)}fft(t){return this.fftImpl(t,!1)}ifft(t){return this.fftImpl(t,!0)}fftImpl(t,e){const n=this.texData.get(t.dataId),r=new Ye(Ke,t.shape,e),o=new Ye(Xe,t.shape,e),c=[this.makeComplexComponentTensorInfo(t,n.complexTensors.real),this.makeComplexComponentTensorInfo(t,n.complexTensors.imag)],l=this.compileAndRun(r,c),d=this.compileAndRun(o,c),h=this.complex(l,d).as2D(t.shape[0],t.shape[1]);return l.dispose(),d.dispose(),h}gatherND(t,e){const n=e.shape,r=n[n.length-1],[c,l,d,h]=o.R.prepareAndValidate(t,e),f=e.reshape([l,r]),m=t.reshape([t.size/d,d]),y=new Ze(r,h,[l,d]);return this.compileAndRun(y,[m,f]).reshape(c)}fill(t,e,n){if("string"===(n=n||o.Eb.inferDtype(e))){const r=o.Eb.getArrayFromDType(n,o.Eb.sizeFromShape(t));return r.fill(e),Object(o.ab)().makeTensor(r,t,n,this)}{const r=new Qe(t,e),o=r.getCustomSetupFunc(e);return this.compileAndRun(r,[],n,o)}}onesLike(t){if("string"===t.dtype)throw new Error("onesLike is not supported under string dtype");return this.fill(t.shape,1,t.dtype)}zerosLike(t){return this.fill(t.shape,"string"===t.dtype?"":0,t.dtype)}linspace(t,e,n){return o.R.linspaceImpl(t,e,n)}makeTensorInfo(t,e,n){const r=this.write(n,t,e);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:e}}makeOutput(t,e,n){const{dataId:r}=this.makeTensorInfo(t,e,n);return Object(o.ab)().makeTensorFromDataId(r,t,e,this)}unpackTensor(input){const t=new pr(input.shape);return this.runWebGLProgram(t,[input],input.dtype)}packTensor(input){const t=new wn(input.shape);return this.runWebGLProgram(t,[input],input.dtype,null,!0)}packedReshape(input,t){const e=[_(input.shape),...F(input.shape)],n={dtype:input.dtype,shape:e,dataId:input.dataId},r=[_(t),...F(t)],o=new Rn(r,e),output=this.runWebGLProgram(o,[n],input.dtype,null,!0);return{dataId:output.dataId,shape:t,dtype:output.dtype}}decode(t){const e=this.texData.get(t),{isPacked:n,shape:r,dtype:o}=e,c=P(r);let l;l=n?new Ve(c):new Le(c);return{dtype:o,shape:r,dataId:this.runWebGLProgram(l,[{shape:c,dtype:o,dataId:t}],o,null,!0).dataId}}runWebGLProgram(t,e,n,r,c=!1){const output=this.makeTensorInfo(t.outputShape,n),l=this.texData.get(output.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===h.DENSE){const e=O(t.outputShape);l.texShape=e.map((t=>2*t))}if(null!=t.outTexUsage&&(l.usage=t.outTexUsage),0===o.Eb.sizeFromShape(output.shape))return l.values=o.Eb.getTypedArrayFromDType(output.dtype,0),output;const d=[],f=e.map((input=>{if("complex64"===input.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let e=this.texData.get(input.dataId);if(null==e.texture){if(!t.packedInputs&&o.Eb.sizeFromShape(input.shape)<=Object(o.bb)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:input.shape,texData:null,isUniform:!0,uniformValues:e.values};t.packedInputs&&(e.isPacked=!0,e.shape=input.shape)}else if(!!e.isPacked!=!!t.packedInputs)input=e.isPacked?this.unpackTensor(input):this.packTensor(input),d.push(input),e=this.texData.get(input.dataId);else if(e.isPacked&&!B(e.shape,input.shape)){const t=input,n=input.shape;input.shape=e.shape,input=this.packedReshape(input,n),d.push(input),e=this.texData.get(input.dataId),t.shape=n}return this.uploadToGPU(input.dataId),{shape:input.shape,texData:e,isUniform:!1}}));this.uploadToGPU(output.dataId);const m={shape:output.shape,texData:l,isUniform:!1},y=function(t,e,output){let n="";e.concat(output).forEach((t=>{const e=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0,r=t.isUniform?"uniform":t.texData.texShape;n+=`${t.shape}_${r}_${e}`}));const r=t.userCode;let o=t.constructor.name;return o+="_"+n+"_"+r,o}(t,f,m),x=this.getAndSaveBinary(y,(()=>function(t,e,n,output){const r=e.userCode,c=n.map(((input,i)=>{const t={logicalShape:input.shape,texShape:input.isUniform?null:input.texData.texShape,isUniform:input.isUniform,isPacked:!input.isUniform&&input.texData.isPacked,flatOffset:null};return null!=input.texData&&null!=input.texData.slice&&input.texData.slice.flatOffset>0&&(t.flatOffset=input.texData.slice.flatOffset),{name:e.variableNames[i],shapeInfo:t}})),l=c.map((t=>t.shapeInfo)),d={logicalShape:output.shape,texShape:output.texData.texShape,isUniform:!1,isPacked:output.texData.isPacked,flatOffset:null},source=Kt(c,d,r,e.packedInputs),h=t.createProgram(source);let f=null;const m=t.getUniformLocation(h,"NAN",!1);1===Object(o.bb)().getNumber("WEBGL_VERSION")&&(f=t.getUniformLocation(h,"INFINITY",!1));const y={};for(let i=0;i<e.variableNames.length;i++){const n=e.variableNames[i],r=!1;y[n]=t.getUniformLocation(h,n,r),y[`offset${n}`]=t.getUniformLocation(h,`offset${n}`,r)}return{program:e,source:source,webGLProgram:h,uniformLocations:y,inShapeInfos:l,outShapeInfo:d,infLoc:f,nanLoc:m}}(this.gpgpu,t,f,m))),v=null!=this.activeTimers;let w;if(v&&(w=this.startTimer()),function(t,e,n,output,r){pn(e.inShapeInfos,n),pn([e.outShapeInfo],[output]);const c=output.texData.texture,l=output.texData.texShape;output.texData.isPacked?t.setOutputPackedMatrixTexture(c,l[0],l[1]):t.setOutputMatrixTexture(c,l[0],l[1]),t.setProgram(e.webGLProgram),1===Object(o.bb)().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach(((input,i)=>{const n=e.program.variableNames[i],r=e.uniformLocations[n],c=e.uniformLocations[`offset${n}`];if(null!=r)if(input.isUniform)if(o.Eb.sizeFromShape(input.shape)<2)t.gl.uniform1f(r,input.uniformValues[0]);else{let e=input.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(r,e)}else null!=input.texData.slice&&null!=c&&t.gl.uniform1i(c,input.texData.slice.flatOffset),t.setInputMatrixTexture(input.texData.texture,r,i)})),null!=r&&r(t,e.webGLProgram),t.executeProgram()}(this.gpgpu,x,f,m,r),d.forEach((t=>this.disposeIntermediateTensorInfo(t))),v&&(w=this.endTimer(w),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(w)})),!Object(o.bb)().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&!1===c){const t=this.unpackTensor(output);return this.disposeIntermediateTensorInfo(output),t}return output}compileAndRun(t,e,n,r,c=!1){n=n||e[0].dtype;const l=this.runWebGLProgram(t,e,n,r,c);return Object(o.ab)().makeTensorFromDataId(l.dataId,l.shape,l.dtype)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!Object(o.bb)().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Object(o.Ab)((()=>{if(!Object(o.bb)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=Object(o.bb)().getBool("DEBUG");Object(o.bb)().set("DEBUG",!1);const e=this.abs(Object(o.pb)(1e-8)).dataSync()[0];if(Object(o.bb)().set("DEBUG",t),e>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:r,values:c,texture:l,usage:d,isPacked:h}=e;if(null!=l)return;const m=null!=this.activeTimers;let y;m&&(y=o.Eb.now());let O=e.texShape;if(null==O&&(O=function(t,e=!1){let n=Object(o.bb)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e&&(n*=2,1===(t=t.map(((e,i)=>i>=t.length-2?o.Eb.nearestLargerEven(t[i]):t[i]))).length&&(t=[2,t[0]])),2!==t.length){const e=o.Eb.squeezeShape(t);t=e.newShape}let r=o.Eb.sizeFromShape(t);if(t.length<=1&&r<=n)return[1,r];if(2===t.length&&t[0]<=n&&t[1]<=n)return t;if(3===t.length&&t[0]*t[1]<=n&&t[2]<=n)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=n&&t[1]*t[2]<=n)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=n&&t[3]<=n)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=n&&t[1]*t[2]*t[3]<=n)return[t[0],t[1]*t[2]*t[3]];if(e){const e=_(t);let n=2,c=2;return t.length&&([n,c]=F(t)),r=e*(n/2)*(c/2),o.Eb.sizeToSquarishShape(r).map((t=>2*t))}return o.Eb.sizeToSquarishShape(r)}(n,h),e.texShape=O),null!=c){const t=P(n);let l,d=O[1],v=O[0];const w=c instanceof Uint8Array;h?([d,v]=x(O[0],O[1]),l=new qe(t,[v,d],w)):l=new He(t,[v,d],w);const j=this.makeTensorInfo([v,d],r);this.texData.get(j.dataId).usage=w?f.PIXELS:f.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(j.dataId),d,v,c);const E=!0,$=this.runWebGLProgram(l,[j],r,null,E),C=this.texData.get($.dataId);e.texture=C.texture,e.texShape=C.texShape,e.isPacked=C.isPacked,e.usage=C.usage,this.disposeIntermediateTensorInfo(j),this.texData.delete($.dataId),e.values=null,m&&(this.uploadWaitMs+=o.Eb.now()-y)}else{const t=this.acquireTexture(O,d,r,h);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:r}=n;return this.releaseGPUData(t),null!=e&&(n.values=function(a,t){if("float32"===t||"complex64"===t)return a;if("int32"===t||"bool"===t){const e="int32"===t?new Int32Array(a.length):new Uint8Array(a.length);for(let i=0;i<e.length;++i)e[i]=Math.round(a[i]);return e}throw new Error(`Unknown dtype ${t}`)}(e,r)),n.values}acquireTexture(t,e,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${t} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,r)}computeBytes(t,e){return t[0]*t[1]*o.Eb.bytesPerElement(e)}tryRunOnCpuOrThrow(t,e){if(this.shouldExecuteOnCPU(t))try{return e()}catch(t){if(Object(o.bb)().getBool("IS_TEST"))throw new Error("CPU forwarding failed")}return null}}o.Y.isBrowser()&&Object(o.mb)("webgl",(()=>new wr),2);function jr(t){return({inputs:e,backend:n})=>{const{x:r}=e,o=n,c=new Kn(r.shape,t);return o.runWebGLProgram(c,[r],r.dtype)}}function Er(t,e,n,r){return({inputs:c,backend:l})=>{const{a:a,b:b}=c,d=l,h=Object(o.bb)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Oe(e,a.shape,b.shape,!!n):new ge(t,a.shape,b.shape),f=r||a.dtype;return d.runWebGLProgram(h,[a,b],f)}}const $r=Er("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n","\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"),Cr={kernelName:o.c,backendName:"webgl",kernelFunc:$r};function Nr(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Rr={kernelName:o.r,backendName:"webgl",kernelFunc:Nr};const Sr={kernelName:o.d,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:c}=e;H(c,"avgPool");const{filterSize:l,strides:d,pad:h,dimRoundingMode:f}=r;o.Eb.assert(o.R.eitherStridesOrDilationsAreOne(d,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${d} and dilations '1'`));const m=o.R.computePool2DInfo(c.shape,l,d,1,h,f);if(1===m.filterWidth&&1===m.filterHeight&&o.Eb.arraysEqual(m.inShape,m.outShape))return Nr({inputs:{x:c},backend:n});const y=new $n(m,"avg",!1);return n.runWebGLProgram(y,[c],"float32")}};const Tr={kernelName:o.e,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:c,input:input}=e,l=input;H([c,input],"avgPoolBackprop");const{filterSize:d,strides:h,pad:f}=r,m=o.R.computePool2DInfo(l.shape,d,h,1,f),y=new ce(m);return n.runWebGLProgram(y,[c],l.dtype)}};class Ir{constructor(t,e,n,r,c,l){this.outputShape=[],this.variableNames=["x","mean","variance"],o.R.assertAndGetBroadcastShape(t,e),o.R.assertAndGetBroadcastShape(t,n);let d="0.0";null!=r&&(o.R.assertAndGetBroadcastShape(t,r),this.variableNames.push("offset"),d="getOffsetAtOutCoords()");let h="1.0";null!=c&&(o.R.assertAndGetBroadcastShape(t,c),this.variableNames.push("scale"),h="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${d};\n        float scale = ${h};\n        float inv = scale * inversesqrt(variance + float(${l}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Ar{constructor(t,e,n,r,c,l){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],o.R.assertAndGetBroadcastShape(t,e),o.R.assertAndGetBroadcastShape(t,n);let d="vec4(0.0)";null!=r&&(o.R.assertAndGetBroadcastShape(t,r),this.variableNames.push("offset"),d="getOffsetAtOutCoords()");let h="vec4(1.0)";null!=c&&(o.R.assertAndGetBroadcastShape(t,c),this.variableNames.push("scale"),h="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${d};\n        vec4 scale = ${h};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${l}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const kr={kernelName:o.q,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,mean:c,variance:l,offset:d,scale:h}=t;o.Eb.assert(c.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),o.Eb.assert(null==d||c.shape.length===d.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),o.Eb.assert(null==h||c.shape.length===h.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:f}=n;null==f&&(f=.001);const m=[r,c,l];let y=null;null!=d&&(y=d.shape,m.push(d));let O=null;null!=h&&(O=h.shape,m.push(h));const x=Object(o.bb)().getBool("WEBGL_PACK_NORMALIZATION")?new Ar(r.shape,c.shape,l.shape,y,O,f):new Ir(r.shape,c.shape,l.shape,y,O,f);return e.runWebGLProgram(x,m,m[0].dtype)}},Dr=jr("if (isnan(x)) return x;\n  return cos(x);\n"),_r={kernelName:o.i,backendName:"webgl",kernelFunc:Dr},Fr=Er("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;","\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",!0),Pr={kernelName:o.k,backendName:"webgl",kernelFunc:Fr};class Mr{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Br={kernelName:o.n,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:image}=t,n=e,r=new Mr(image.shape);return n.runWebGLProgram(r,[image],image.dtype)}};class Lr{constructor(t){this.variableNames=["A"];const e=Ut(),[n,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class Vr{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=Ut(),[n,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const zr={kernelName:o.p,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:c}=e;const{numChannels:l}=r,d="undefined"!=typeof HTMLVideoElement&&c instanceof HTMLVideoElement,h="undefined"!=typeof HTMLImageElement&&c instanceof HTMLImageElement,[m,y]=d?[c.videoWidth,c.videoHeight]:[c.width,c.height],O=[y,m],x=[y,m,l];(h||d)&&(null==Ur&&(Ur=document.createElement("canvas").getContext("2d")),Ur.canvas.width=m,Ur.canvas.height=y,Ur.drawImage(c,0,0,m,y),c=Ur.canvas);const v=n.makeTensorInfo(O,"int32");n.texData.get(v.dataId).usage=f.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(v.dataId),c);const w=Object(o.bb)().getBool("WEBGL_PACK")?new Vr(x):new Lr(x),j=n.runWebGLProgram(w,[v],"int32");return n.disposeData(v.dataId),j}};let Ur;function Wr(t,e,n,r){const c=function(t){const e=[];for(;0===e.length||1!==e[e.length-1].outSize;){const n=e.length?e[e.length-1].outSize:t[1],r=o.R.computeOptimalWindowSize(n);e.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return e}(t.shape);let l=t;for(let i=0;i<c.length;i++){const{inSize:o,windowSize:d,outSize:h}=c[i],f=new Nn({windowSize:d,inSize:o,batchSize:t.shape[0],outSize:h},n),m=l;l=r.runWebGLProgram(f,[l],e),m.dataId!==t.dataId&&r.disposeData(m.dataId)}return l}function Gr(t){const{inputs:e,backend:n,attrs:r}=t,{x:c}=e,{shape:l}=r,d=n,h=o.Eb.sizeFromShape(c.shape),f=o.Eb.inferFromImplicitShape(l,h),m=o.Eb.sizeFromShape(f);o.Eb.assert(h===m,(()=>`The new shape (${f}) has ${m} elements and the old shape (${c.shape}) has ${h} elements. The new shape and old shape must have the same number of elements.`));const y=d.texData.get(c.dataId);return!y.isPacked||B(c.shape,f)||null!==y.texture&&B(y.shape,f)?(d.incRef(c.dataId),{dataId:c.dataId,shape:f,dtype:c.dtype}):function(input,t,e){const n=[_(input.shape),...F(input.shape)],r={dtype:input.dtype,shape:n,dataId:input.dataId},o=[_(t),...F(t)],c=new Rn(o,n),output=e.runWebGLProgram(c,[r],input.dtype,null,!0);return{dataId:output.dataId,shape:t,dtype:output.dtype}}(c,f,d)}const Hr={kernelName:o.D,backendName:"webgl",kernelFunc:Gr};class qr{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[e[i]];this.outputShape=n,this.rank=n.length;const r=ae(this.rank),o=function(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let i=0;i<t.length;i++)r[t[i]]=n[i];return r.join()}(e);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}class Kr{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[e[i]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=ae(this.rank),o=Vt("rc",this.rank),c=new Array(this.rank);for(let i=0;i<e.length;i++)c[e[i]]=o[i];const l=`vec2(${c.slice(-2).join()})`,d=`++${o[this.rank-1]} < ${n[this.rank-1]}`,h=`getChannel(getA(${c.join()}), ${l})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${h};\n      if(${d}) {\n        result[1] = ${h};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${h};\n        if(${d}) {\n          result[3] = ${h};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Xr(t,e,n){const r=Object(o.bb)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Kr(t.shape,e):new qr(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}const Yr={kernelName:o.u,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{reductionIndices:c,keepDims:l}=e,d=n,h=r.shape.length,f=o.Eb.parseAxisParam(c,r.shape);let m=f;const y=o.R.getAxesPermutation(m,h),O=null!=y,x=d.shouldExecuteOnCPU([r]);let v=r;if(O){if(x){const t=d.texData.get(v.dataId).values,e=new Array(h);for(let i=0;i<e.length;i++)e[i]=r.shape[y[i]];const n=Ft(t,r.shape,r.dtype,y,e);v=d.makeTensorInfo(e,r.dtype);d.texData.get(v.dataId).values=n}else v=Xr(r,y,d);m=o.R.getInnerMostAxes(m.length,h)}o.R.assertAxesAreInnerMostDims("max",m,h);const[w,j]=o.R.computeOutAndReduceShapes(v.shape,m);let E,$=w;if(l&&($=o.R.expandShapeToKeepDim(w,f)),x){const t=d.texData.get(v.dataId).values,e=It(t,o.Eb.sizeFromShape(j),$,r.dtype);E=d.makeTensorInfo($,r.dtype);d.texData.get(E.dataId).values=e}else E=function(t,e,n,r){const c=o.Eb.sizeFromShape(e),l=Gr({inputs:{x:t},attrs:{shape:[o.Eb.sizeFromShape(t.shape)/c,c]},backend:r}),d=Wr(l,t.dtype,"max",r),h=Gr({inputs:{x:d},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(d),h}(v,j,$,d);return O&&d.disposeIntermediateTensorInfo(v),E}};const Qr={kernelName:o.v,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:c}=e;H(c,"maxPool");const{filterSize:l,strides:d,pad:h,dimRoundingMode:f}=r;o.Eb.assert(o.R.eitherStridesOrDilationsAreOne(d,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${d} and dilations '1'`));const m=o.R.computePool2DInfo(c.shape,l,d,1,h,f);if(1===m.filterWidth&&1===m.filterHeight&&o.Eb.arraysEqual(m.inShape,m.outShape))return Nr({inputs:{x:c},backend:n});const y=new $n(m,"max",!1);return n.runWebGLProgram(y,[c],c.dtype)}};const Jr={kernelName:o.w,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:c,input:input,output:output}=e,l=input;H([input,output],"maxPoolBackprop");const{filterSize:d,strides:h,pad:f,dimRoundingMode:m}=r,y=o.R.computePool2DInfo(l.shape,d,h,1,f,m),O=new $n(y,"max",!0),x=n.runWebGLProgram(O,[l],l.dtype),v=new gn(y),w=n.runWebGLProgram(v,[c,x],l.dtype);return n.disposeIntermediateTensorInfo(x),w}};const Zr={kernelName:o.x,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:c,strides:l,pad:d,includeBatchInIndex:h}=e,f=n;o.Eb.assert(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const m=[1,1];o.Eb.assert(o.R.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const y=o.R.computePool2DInfo(r.shape,c,l,m,d),[O,x]=function(t,e,n,r){let o=new $n(n,"max",!1);const c=r.runWebGLProgram(o,[t],"float32");return o=new $n(n,"max",!0,!0,e),[c,r.runWebGLProgram(o,[t],"float32")]}(r,h,y,f);return[O,x]}},ta={kernelName:o.z,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{o.R.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:r,scores:c}=t,{maxOutputSize:l,iouThreshold:d,scoreThreshold:h}=n,f=e,m=f.readSync(r.dataId),y=f.readSync(c.dataId),O=l,x=d,v=h;return o.hb.nonMaxSuppressionV3Impl(m,y,O,x,v)}},ea=o.hb.nonMaxSuppressionV4Impl,na={kernelName:o.A,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{o.R.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:r,scores:c}=t,{maxOutputSize:l,iouThreshold:d,scoreThreshold:h,padToMaxOutputSize:f}=n,m=e,y=m.readSync(r.dataId),O=m.readSync(c.dataId),{selectedIndices:x,validOutputs:v}=ea(y,O,l,d,h,f);return[x,v]}},ra=o.hb.nonMaxSuppressionV5Impl,aa={kernelName:o.B,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{o.R.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:r,scores:c}=t,{maxOutputSize:l,iouThreshold:d,scoreThreshold:h,softNmsSigma:f}=n,m=e,y=m.readSync(r.dataId),O=m.readSync(c.dataId),x=l,v=d,w=h,j=f,{selectedIndices:E,selectedScores:$}=ra(y,O,x,v,w,j);return[E,$]}};class sa{constructor(t,e,n,r){this.variableNames=["Image"],this.outputShape=[];const c=t[1],l=t[2],d=Math.sin(e).toFixed(3),h=Math.cos(e).toFixed(3);this.outputShape=t;const[f,m]=o.R.getImageCenter(r,c,l),y=f.toFixed(3),O=m.toFixed(3);let x="";x="number"==typeof n?`float outputValue = ${n.toFixed(2)};`:`\n        vec3 fill = vec3(${n.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - ${y}) * ${h} - (float(y) - ${O}) * ${d};\n          float coordYFloat = (float(x) - ${y}) * ${d} + (float(y) - ${O}) * ${h};\n          int coordX = int(round(coordXFloat + ${y}));\n          int coordY = int(round(coordYFloat + ${O}));\n          ${x}\n          if(coordX >= 0 && coordX < ${l} && coordY >= 0 && coordY < ${c}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const oa={kernelName:o.E,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:image}=t,{radians:r,fillValue:o,center:c}=e,l=n,d=new sa(image.shape,r,o,c);return l.runWebGLProgram(d,[image],image.dtype)}},ia=jr("if (isnan(x)) return x;\n  return sin(x);\n"),ca={kernelName:o.G,backendName:"webgl",kernelFunc:ia},ua=jr("return x * x;"),la={kernelName:o.I,backendName:"webgl",kernelFunc:ua},da="return (a - b) * (a - b);",pa=Er(da,da),ha={kernelName:o.J,backendName:"webgl",kernelFunc:pa},fa=jr("return tan(x);");const ma=[Cr,Sr,Tr,kr,_r,Pr,Br,zr,Rr,Yr,Qr,Jr,Zr,ta,na,aa,Hr,oa,ca,la,ha,{kernelName:o.L,backendName:"webgl",kernelFunc:fa},{kernelName:o.O,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{perm:o}=e,c=n,l=r.shape.length,d=new Array(l);for(let i=0;i<d.length;i++)d[i]=r.shape[o[i]];let h;if(c.shouldExecuteOnCPU([r])){const t=c.texData.get(r.dataId).values,e=Ft(t,r.shape,r.dtype,o,d);h=c.makeTensorInfo(d,r.dtype);c.texData.get(h.dataId).values=e}else h=Xr(r,o,c);return h}},{kernelName:o.P,backendName:"webgl",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{axis:o}=n,{x:c}=e;H(c,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const l=r.readSync(c.dataId),{outputValues:d,outputShape:h,indices:f}=Pt(l,o,c.shape,c.dtype);return[r.makeTensorInfo(h,c.dtype,d),r.makeTensorInfo([f.length],"int32",f)]}}];for(const t of ma)Object(o.nb)(t)},function(t,e,n){"use strict";n.d(e,"a",(function(){return Fn})),n.d(e,"b",(function(){return Mn}));var r=n(226),o=n(445),c=n(240);class l{constructor(t,e,n){this.node=t,this.tensorMap=e,this.context=n,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map((t=>this.getInput(t))),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce(((t,e)=>(t[e]=this.getAttr(e),t)),{}))}getInput(t){return Object(c.e)(t,this.tensorMap,this.context)}getAttr(t,e){const n=this.node.rawAttrs[t];if(null!=n.tensor)return Object(c.e)(t,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return Object(o.f)(this.node.rawAttrs,t,e);if(null!=n.s)return Object(o.i)(this.node.rawAttrs,t,e);if(null!=n.b)return Object(o.c)(this.node.rawAttrs,t,e);if(null!=n.shape)return Object(o.k)(this.node.rawAttrs,t,e);if(null!=n.type)return Object(o.e)(this.node.rawAttrs,t,e);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return Object(o.g)(this.node.rawAttrs,t,e);if(null!=n.list.s)return Object(o.h)(this.node.rawAttrs,t,e);if(null!=n.list.shape)return Object(o.j)(this.node.rawAttrs,t,e);if(null!=n.list.b)return Object(o.b)(this.node.rawAttrs,t,e);if(null!=n.list.type)return Object(o.d)(this.node.rawAttrs,t,e)}return e}}var d=n(327),h=n(245),f=n(446),m=n(351),y=n(229),div=n(235),O=n(393),x=n(332),sub=n(233),v=n(320),w=n(298),j=n(281),E=n(321);var $=n(291),C=n(421),N=n(422),R=n(424),S=n(425),T=n(426),I=n(388),A=n(427),k=n(428),D=n(267),_=n(348),F=n(383),P=n(343),M=n(431),B=n(263),L=n(432),V=n(382),z=n(294),U=n(372),W=n(314),G=n(246),H=n(439),K=n(315),X=n(293),Y=n(440),Q=n(402),J=n(333),Z=n(379),tt=n(441),et=n(380),nt=n(397),at=n(272),st=n(250),ot=n(444),it=n(443),ct=n(429),ut=n(381),lt=n(401),pt=n(395),ht=n(345);function ft(t,e,n=""){r.Eb.assert(function(t,e){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(-1!==t[i]&&-1!==e[i]&&t[i]!==e[i])return!1;return!0}(t,e),(()=>n+` Shapes ${t} and ${e} must match`))}class mt{constructor(t,e,n,o,c,l,d){this.name=t,this.dtype=e,this.maxSize=n,this.elementShape=o,this.identicalElementShapes=c,this.dynamicSize=l,this.clearAfterRead=d,this.tensors=[],this.closed_=!1,this.idTensor=Object(r.pb)(0),Object(r.gb)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach((e=>{null!=t&&t.has(e.tensor.id)||e.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map((t=>this.read(t)))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=e.shape),ft(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);n.tensor=e,Object(r.gb)(e),n.written=!0,this.tensors[t]=n}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach(((i,t)=>this.write(i,e[t])))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let i=0;i<this.size();i++)t.push(i)}if(0===t.length)return Object(r.xb)([],[0].concat(this.elementShape));const n=this.readMany(t);return ft(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Object(r.ub)(n,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return Object(r.xb)([],[0].concat(this.elementShape));const e=[];for(let i=0;i<this.size();i++)e.push(i);const n=this.readMany(e);return ft(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Object(r.W)(n,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const n=Math.max(...t);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(t,Object(r.Cb)(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let n=0;const o=t.map((t=>(n+=t,n)));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const c=0===n?0:e.size/n,l=[];Object(r.Ab)((()=>{e=Object(r.ob)(e,[1,n,c]);for(let i=0;i<t.length;++i){const n=[0,0===i?0:o[i-1],0],d=[1,t[i],c];l[i]=Object(r.ob)(Object(r.rb)(e,n,d),this.elementShape)}return l}));const d=[];for(let i=0;i<t.length;i++)d[i]=i;this.writeMany(d,l)}}class bt{constructor(t,e,n,o=-1){this.tensors=t,this.elementShape=e,this.elementDtype=n,null!=t&&t.forEach((t=>{if(n!==t.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${t.dtype}`);ft(e,t.shape,"TensorList shape mismatch: "),Object(r.gb)(t)})),this.idTensor=Object(r.pb)(0),this.maxNumElements=o,Object(r.gb)(this.idTensor)}get id(){return this.idTensor.id}copy(){return new bt([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach((e=>{null!=t&&t.has(e.id)||e.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,n=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);return ft(t,this.elementShape,"TensorList shape mismatch: "),Object(r.Ab)((()=>{const e=this.tensors.map((e=>Object(r.ob)(e,t)));return Object(r.ub)(e,0)}))}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=this.tensors.pop();return ft(n.shape,t,"TensorList shape mismatch: "),Object(r.ob)(n,t)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(ft(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Object(r.gb)(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=t}getItem(t,e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);return ft(this.tensors[t].shape,e,"TensorList shape mismatch: "),this.tensors[t]}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);ft(this.elementShape,e.shape,"TensorList shape mismatch: "),Object(r.gb)(e),this.tensors[t]=e}gather(t,e,n){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);return ft(this.elementShape,n,"TensorList shape mismatch: "),0===(t=t.slice(0,this.size())).length?Object(r.xb)([],[0].concat(this.elementShape)):Object(r.Ab)((()=>{const e=t.map((i=>Object(r.ob)(this.tensors[i],n)));return Object(r.ub)(e,0)}))}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);return ft(this.elementShape,e,"TensorList shape mismatch: "),0===this.size()?Object(r.xb)([],[0].concat(this.elementShape)):Object(r.Ab)((()=>{const t=this.tensors.map((t=>Object(r.ob)(t,e)));return Object(r.W)(t,0)}))}}const gt=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const r=Object(c.d)("thenBranch",t,e,n),o=Object(c.d)("elseBranch",t,e,n),l=Object(c.d)("cond",t,e,n),d=Object(c.d)("args",t,e,n);return(await l.data())[0]?n.functionMap[r].executeFunctionAsync(d,n.tensorArrayMap,n.tensorListMap):n.functionMap[o].executeFunctionAsync(d,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=Object(c.d)("body",t,e,n),o=Object(c.d)("cond",t,e,n),l=Object(c.d)("args",t,e,n),d=await n.functionMap[o].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap),h=l.map((t=>t.id));let f=await d[0].data();d.forEach((t=>{t.kept||-1!==h.indexOf(t.id)||t.dispose()}));let m=l;for(;f[0];){const t=m;m=await n.functionMap[r].executeFunctionAsync(m,n.tensorArrayMap,n.tensorListMap);const e=m.map((t=>t.id));t.forEach((t=>{t.kept||-1!==h.indexOf(t.id)||-1!==e.indexOf(t.id)||t.dispose()}));const c=await n.functionMap[o].executeFunctionAsync(m,n.tensorArrayMap,n.tensorListMap);f=await c[0].data(),c.forEach((t=>{t.kept||-1!==h.indexOf(t.id)||-1!==e.indexOf(t.id)||t.dispose()}))}return m}case"LoopCond":{const r=Object(c.d)("pred",t,e,n);return[Object(c.a)(r)]}case"Switch":{const r=Object(c.d)("pred",t,e,n);let data=Object(c.d)("data",t,e,n);return data.kept||(data=Object(c.a)(data)),(await r.data())[0]?[void 0,data]:[data,void 0]}case"Merge":{const r=t.inputNames.find((t=>void 0!==Object(c.e)(t,e,n)));if(r){const data=Object(c.e)(r,e,n);return[Object(c.a)(data)]}return}case"Enter":{const r=Object(c.d)("frameName",t,e,n),data=Object(c.d)("tensor",t,e,n);return n.enterFrame(r),[Object(c.a)(data)]}case"Exit":{const data=Object(c.d)("tensor",t,e,n);return n.exitFrame(),[Object(c.a)(data)]}case"NextIteration":{const data=Object(c.d)("tensor",t,e,n);return n.nextIteration(),[Object(c.a)(data)]}case"TensorArrayV3":{const o=Object(c.d)("size",t,e,n),l=Object(c.d)("dtype",t,e,n),d=Object(c.d)("elementShape",t,e,n),h=Object(c.d)("dynamicSize",t,e,n),f=Object(c.d)("clearAfterRead",t,e,n),m=Object(c.d)("identicalElementShapes",t,e,n),y=Object(c.d)("name",t,e,n),O=new mt(y,l,o,d,m,h,f);return n.addTensorArray(O),[O.idTensor,Object(r.pb)(1)]}case"TensorArrayWriteV3":{const r=Object(c.d)("tensorArrayId",t,e,n),o=Object(c.d)("index",t,e,n),l=Object(c.d)("tensor",t,e,n),d=n.getTensorArray(r.id);return d.write(o,l),[d.idTensor]}case"TensorArrayReadV3":{const r=Object(c.d)("tensorArrayId",t,e,n),o=Object(c.d)("index",t,e,n);return[n.getTensorArray(r.id).read(o)]}case"TensorArrayGatherV3":{const r=Object(c.d)("tensorArrayId",t,e,n),o=Object(c.d)("indices",t,e,n),l=Object(c.d)("dtype",t,e,n);return[n.getTensorArray(r.id).gather(o,l)]}case"TensorArrayScatterV3":{const r=Object(c.d)("tensorArrayId",t,e,n),o=Object(c.d)("indices",t,e,n),l=Object(c.d)("tensor",t,e,n),d=n.getTensorArray(r.id);return d.scatter(o,l),[d.idTensor]}case"TensorArrayConcatV3":{const r=Object(c.d)("tensorArrayId",t,e,n),o=n.getTensorArray(r.id),l=Object(c.d)("dtype",t,e,n);return[o.concat(l)]}case"TensorArraySplitV3":{const r=Object(c.d)("tensorArrayId",t,e,n),o=Object(c.d)("tensor",t,e,n),l=Object(c.d)("lengths",t,e,n),d=n.getTensorArray(r.id);return d.split(l,o),[d.idTensor]}case"TensorArraySizeV3":{const o=Object(c.d)("tensorArrayId",t,e,n),l=n.getTensorArray(o.id);return[Object(r.pb)(l.size(),"int32")]}case"TensorArrayCloseV3":{const r=Object(c.d)("tensorArrayId",t,e,n),o=n.getTensorArray(r.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{const r=Object(c.d)("tensorListId",t,e,n),o=Object(c.d)("index",t,e,n),l=Object(c.d)("tensor",t,e,n),d=n.getTensorList(r.id);return d.setItem(o,l),[d.idTensor]}case"TensorListGetItem":{const r=Object(c.d)("tensorListId",t,e,n),o=Object(c.d)("index",t,e,n),l=Object(c.d)("elementShape",t,e,n),d=Object(c.d)("elementDType",t,e,n);return[n.getTensorList(r.id).getItem(o,l,d)]}case"TensorListScatterV2":case"TensorListScatter":{const o=Object(c.d)("indices",t,e,n),l=function(t,e,n,o){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const c=Math.max(...e);if(null!=o&&-1!==o&&c>=o)throw new Error(`Max index must be < array size (${c}  vs. ${o})`);const l=new bt([],n,t.dtype,o),d=Object(r.Cb)(t,0);return e.forEach(((t,e)=>{l.setItem(t,d[e])})),l}(Object(c.d)("tensor",t,e,n),o,Object(c.d)("elementShape",t,e,n),Object(c.d)("numElements",t,e,n));return n.addTensorList(l),[l.idTensor]}case"TensorListReserve":{const r=function(t,e,n){return new bt([],t,e,n)}(Object(c.d)("elementShape",t,e,n),Object(c.d)("elementDType",t,e,n),Object(c.d)("numElements",t,e,n));return n.addTensorList(r),[r.idTensor]}case"TensorListGather":{const r=Object(c.d)("tensorListId",t,e,n),o=Object(c.d)("indices",t,e,n),l=Object(c.d)("elementShape",t,e,n),d=Object(c.d)("elementDType",t,e,n);return[n.getTensorList(r.id).gather(o,d,l)]}case"TensorListStack":{const r=Object(c.d)("tensorListId",t,e,n),o=Object(c.d)("elementShape",t,e,n),l=Object(c.d)("elementDType",t,e,n),d=Object(c.d)("numElements",t,e,n);return[n.getTensorList(r.id).stack(o,l,d)]}case"TensorListFromTensor":{const o=function(t,e,n){const o=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);ft(t.shape.slice(1),e,"TensorList shape mismatch: ");const c=Object(r.Cb)(t);return new bt(c,e,o)}(Object(c.d)("tensor",t,e,n),Object(c.d)("elementShape",t,e,n),Object(c.d)("elementDType",t,e,n));return n.addTensorList(o),[o.idTensor]}case"TensorListConcat":{const r=Object(c.d)("tensorListId",t,e,n),o=n.getTensorList(r.id),l=Object(c.d)("dtype",t,e,n),d=Object(c.d)("elementShape",t,e,n);return[o.concat(l,d)]}case"TensorListPushBack":{const r=Object(c.d)("tensorListId",t,e,n),o=Object(c.d)("tensor",t,e,n),l=n.getTensorList(r.id);return l.pushBack(o),[l.idTensor]}case"TensorListPopBack":{const r=Object(c.d)("tensorListId",t,e,n),o=Object(c.d)("elementShape",t,e,n),l=Object(c.d)("elementDType",t,e,n);return[n.getTensorList(r.id).popBack(o,l)]}case"TensorListSplit":{const o=Object(c.d)("tensor",t,e,n),l=Object(c.d)("elementShape",t,e,n),d=function(t,e,n){let o=0;const c=e.map((t=>(o+=t,o)));if(o!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${o}, and tensor's shape is: ${t.shape}`);const l=0===o?0:t.size/o,d=Object(r.Ab)((()=>{const d=[];t=Object(r.ob)(t,[1,o,l]);for(let i=0;i<e.length;++i){const o=[0,0===i?0:c[i-1],0],h=[1,e[i],l];d[i]=Object(r.ob)(Object(r.rb)(t,o,h),n)}return t.dispose(),d})),h=new bt([],n,t.dtype,e.length);for(let i=0;i<d.length;i++)h.setItem(i,d[i]);return h}(o,Object(c.d)("lengths",t,e,n),l);return n.addTensorList(d),[d.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};var yt=n(389),Ot=n(284),xt=n(228),vt=n(390),wt=n(296),jt=n(447),Et=n(352),$t=n(354),Ct=n(448),Nt=n(449),Rt=n(450),St=n(392);function Tt(t,e,n){const[r,o]=Object(c.d)("fusedOps",t,e,n),l="biasadd"===r,d="prelu"===o,h="fusedbatchnorm"===r,f=Object(c.d)("numArgs",t,e,n);if(l){if(d&&2!==f)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!d&&1!==f)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(h)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");const m=Object(c.d)("strides",t,e,n),y=Object(c.c)(t,e,n),O=Object(c.d)("dataFormat",t,e,n).toUpperCase(),x=Object(c.d)("dilations",t,e,n),[v,w]=Object(c.d)("args",t,e,n);return{stride:m,pad:y,dataFormat:O,dilations:x,biasArg:v,preluArg:w,activationFunc:o}}var It=n(371),At=n(451),kt=n(452),Dt=n(399),_t=n(292),Ft=n(438),Pt=n(453),Mt=n(368),Bt=n(455),Lt=n(269),Vt=n(238);var zt=n(230),Ut=n(456),Wt=n(457);function Gt(t,e,n){return{boxes:Object(c.d)("boxes",t,e,n),scores:Object(c.d)("scores",t,e,n),maxOutputSize:Object(c.d)("maxOutputSize",t,e,n),iouThreshold:Object(c.d)("iouThreshold",t,e,n),scoreThreshold:Object(c.d)("scoreThreshold",t,e,n),softNmsSigma:Object(c.d)("softNmsSigma",t,e,n)}}var Ht=n(404),qt=n(405);var Kt=n(288),Xt=n(232);var Yt=n(297),Qt=n(319),Jt=n(264),Zt=n(271),te=n(324),ee=n(270),ne=n(280),re=n(325),ae=n(353),se=n(260);var oe=n(282),ie=n(241);var ce=n(411),ue=n(396),le=n(416),de=n(437),pe=n(464);var he=n(287),fe=n(341),me=n(340),be=n(236),ge=n(384),ye=n(385),Oe=n(386),xe=n(387),ve=n(346);var we=n(258),je=n(350),Ee=n(317),$e=n(259),Ce=n(442),Ne=n(338),Re=n(227),Se=n(279),Te=n(316),Ie=n(318),Ae=n(290),ke=n(458),De=n(459);var _e=n(334),Fe=n(335),Pe=n(336),Me=n(370);var Be=n(289),Le=n(349),Ve=n(323),ze=n(326),Ue=n(391),We=n(337);function Ge(t,e,n){const o=((t,e,n)=>{switch(t.category){case"arithmetic":return r.Ab((()=>((t,e,n)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[h.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"AddN":return[f.a(Object(c.d)("tensors",t,e,n))];case"FloorMod":case"Mod":return[m.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"Mul":return[y.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"RealDiv":case"Div":return[div.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"DivNoNan":return[O.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"FloorDiv":return[x.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"Sub":return[sub.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"Minimum":return[v.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"Maximum":return[w.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"Pow":return[j.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"SquaredDifference":return[E.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"basic_math":return r.Ab((()=>((t,e,n)=>{switch(t.op){case"Abs":case"ComplexAbs":return[$.a(Object(c.d)("x",t,e,n))];case"Acos":return[C.a(Object(c.d)("x",t,e,n))];case"Acosh":return[N.a(Object(c.d)("x",t,e,n))];case"Asin":return[R.a(Object(c.d)("x",t,e,n))];case"Asinh":return[S.a(Object(c.d)("x",t,e,n))];case"Atan":return[T.a(Object(c.d)("x",t,e,n))];case"Atan2":return[I.a(Object(c.d)("x",t,e,n),Object(c.d)("y",t,e,n))];case"Atanh":return[A.a(Object(c.d)("x",t,e,n))];case"Ceil":return[k.a(Object(c.d)("x",t,e,n))];case"Complex":return[D.a(Object(c.d)("real",t,e,n),Object(c.d)("imag",t,e,n))];case"Cos":return[_.a(Object(c.d)("x",t,e,n))];case"Cosh":return[F.a(Object(c.d)("x",t,e,n))];case"Elu":return[P.a(Object(c.d)("x",t,e,n))];case"Erf":return[M.a(Object(c.d)("x",t,e,n))];case"Exp":return[B.a(Object(c.d)("x",t,e,n))];case"Expm1":return[L.a(Object(c.d)("x",t,e,n))];case"Floor":return[V.a(Object(c.d)("x",t,e,n))];case"Log":return[z.a(Object(c.d)("x",t,e,n))];case"Log1p":return[U.a(Object(c.d)("x",t,e,n))];case"Imag":return[W.a(Object(c.d)("x",t,e,n))];case"Neg":return[G.a(Object(c.d)("x",t,e,n))];case"Reciprocal":return[H.a(Object(c.d)("x",t,e,n))];case"Real":return[K.a(Object(c.d)("x",t,e,n))];case"Relu":return[X.a(Object(c.d)("x",t,e,n))];case"Round":return[Y.a(Object(c.d)("x",t,e,n))];case"Selu":return[Q.a(Object(c.d)("x",t,e,n))];case"Sigmoid":return[J.a(Object(c.d)("x",t,e,n))];case"Sin":return[Z.a(Object(c.d)("x",t,e,n))];case"Sign":return[tt.a(Object(c.d)("x",t,e,n))];case"Sinh":return[et.a(Object(c.d)("x",t,e,n))];case"Softplus":return[nt.a(Object(c.d)("x",t,e,n))];case"Sqrt":return[at.a(Object(c.d)("x",t,e,n))];case"Square":return[st.a(Object(c.d)("x",t,e,n))];case"Tanh":return[ot.a(Object(c.d)("x",t,e,n))];case"Tan":return[it.a(Object(c.d)("x",t,e,n))];case"Relu6":case"ClipByValue":return[ct.a(Object(c.d)("x",t,e,n),Object(c.d)("clipValueMin",t,e,n),Object(c.d)("clipValueMax",t,e,n))];case"Rsqrt":return[ut.a(Object(c.e)(t.inputNames[0],e,n))];case"Prod":return[lt.a(Object(c.d)("x",t,e,n),Object(c.d)("axes",t,e,n))];case"LeakyRelu":return[pt.a(Object(c.d)("x",t,e,n),Object(c.d)("alpha",t,e,n))];case"Prelu":return[ht.a(Object(c.d)("x",t,e,n),Object(c.d)("alpha",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"control":return gt(t,e,n);case"convolution":return r.Ab((()=>((t,e,n)=>{switch(t.op){case"Conv1D":{const r=Object(c.d)("stride",t,e,n),o=Object(c.d)("pad",t,e,n),l=Object(c.d)("dataFormat",t,e,n).toUpperCase(),d=Object(c.d)("dilation",t,e,n);return[yt.a(Object(c.d)("x",t,e,n),Object(c.d)("filter",t,e,n),r,o,l,d)]}case"Conv2D":{const r=Object(c.d)("strides",t,e,n),o=Object(c.c)(t,e,n),l=Object(c.d)("dataFormat",t,e,n).toUpperCase(),d=Object(c.d)("dilations",t,e,n);return[Ot.a(Object(c.d)("x",t,e,n),Object(c.d)("filter",t,e,n),[r[1],r[2]],o,l,[d[1],d[2]])]}case"_FusedConv2D":{const{stride:r,pad:o,dataFormat:l,dilations:d,biasArg:h,preluArg:f,activationFunc:m}=Tt(t,e,n);return[xt.h.conv2d({x:Object(c.d)("x",t,e,n),filter:Object(c.d)("filter",t,e,n),strides:[r[1],r[2]],pad:o,dataFormat:l,dilations:[d[1],d[2]],bias:h,activation:m,preluActivationWeights:f})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:o,dataFormat:l,dilations:d,biasArg:h,preluArg:f,activationFunc:m}=Tt(t,e,n);return[xt.h.depthwiseConv2d({x:Object(c.d)("x",t,e,n),filter:Object(c.d)("filter",t,e,n),strides:[r[1],r[2]],pad:o,dataFormat:l,dilations:[d[1],d[2]],bias:h,activation:m,preluActivationWeights:f})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=Object(c.d)("outputShape",t,e,n),o=Object(c.d)("strides",t,e,n),l=Object(c.c)(t,e,n);return[vt.a(Object(c.d)("x",t,e,n),Object(c.d)("filter",t,e,n),r,[o[1],o[2]],l)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=Object(c.d)("strides",t,e,n),o=Object(c.c)(t,e,n),l=Object(c.d)("dilations",t,e,n),d=Object(c.d)("dataFormat",t,e,n).toUpperCase();return[wt.a(Object(c.d)("input",t,e,n),Object(c.d)("filter",t,e,n),[r[1],r[2]],o,d,[l[1],l[2]])]}case"Conv3D":{const r=Object(c.d)("strides",t,e,n),o=Object(c.d)("pad",t,e,n),l=Object(c.d)("dataFormat",t,e,n).toUpperCase(),d=Object(c.d)("dilations",t,e,n);return[jt.a(Object(c.d)("x",t,e,n),Object(c.d)("filter",t,e,n),[r[1],r[2],r[3]],o,l,[d[1],d[2],d[3]])]}case"AvgPool":{const r=Object(c.d)("strides",t,e,n),o=Object(c.d)("pad",t,e,n),l=Object(c.d)("kernelSize",t,e,n);return[Et.a(Object(c.d)("x",t,e,n),[l[1],l[2]],[r[1],r[2]],o)]}case"MaxPool":{const r=Object(c.d)("strides",t,e,n),o=Object(c.d)("pad",t,e,n),l=Object(c.d)("kernelSize",t,e,n);return[$t.a(Object(c.d)("x",t,e,n),[l[1],l[2]],[r[1],r[2]],o)]}case"MaxPoolWithArgmax":{const r=Object(c.d)("strides",t,e,n),o=Object(c.d)("pad",t,e,n),l=Object(c.d)("kernelSize",t,e,n),d=Object(c.d)("includeBatchInIndex",t,e,n),{result:h,indexes:f}=Ct.a(Object(c.d)("x",t,e,n),[l[1],l[2]],[r[1],r[2]],o,d);return[h,f]}case"AvgPool3D":{const r=Object(c.d)("strides",t,e,n),o=Object(c.d)("pad",t,e,n),l=Object(c.d)("kernelSize",t,e,n);return[Nt.a(Object(c.d)("x",t,e,n),[l[1],l[2],l[3]],[r[1],r[2],r[3]],o)]}case"MaxPool3D":{const r=Object(c.d)("strides",t,e,n),o=Object(c.d)("pad",t,e,n),l=Object(c.d)("kernelSize",t,e,n);return[Rt.a(Object(c.d)("x",t,e,n),[l[1],l[2],l[3]],[r[1],r[2],r[3]],o)]}case"Dilation2D":{const r=Object(c.d)("strides",t,e,n),o=Object(c.d)("pad",t,e,n),l=Object(c.d)("dilations",t,e,n),d=r[1],h=r[2],f=l[1],m=l[2];return[St.a(Object(c.d)("x",t,e,n),Object(c.d)("filter",t,e,n),[d,h],o,[f,m],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"creation":return r.Ab((()=>((t,e,n)=>{switch(t.op){case"Fill":{const r=Object(c.d)("shape",t,e,n),o=Object(c.d)("dtype",t,e,n),l=Object(c.d)("value",t,e,n);return[It.a(r,l,o)]}case"LinSpace":{const r=Object(c.d)("start",t,e,n),o=Object(c.d)("stop",t,e,n),l=Object(c.d)("num",t,e,n);return[At.a(r,o,l)]}case"Multinomial":{const r=Object(c.d)("logits",t,e,n),o=Object(c.d)("numSamples",t,e,n),l=Object(c.d)("seed",t,e,n);return[kt.a(r,o,l)]}case"OneHot":{const r=Object(c.d)("indices",t,e,n),o=Object(c.d)("depth",t,e,n),l=Object(c.d)("onValue",t,e,n),d=Object(c.d)("offValue",t,e,n);return[Dt.a(r,o,l,d)]}case"Ones":return[_t.a(Object(c.d)("shape",t,e,n),Object(c.d)("dtype",t,e,n))];case"OnesLike":return[Ft.a(Object(c.d)("x",t,e,n))];case"RandomUniform":return[Pt.a(Object(c.d)("shape",t,e,n),Object(c.d)("minval",t,e,n),Object(c.d)("maxval",t,e,n),Object(c.d)("dtype",t,e,n))];case"Range":{const r=Object(c.d)("start",t,e,n),o=Object(c.d)("stop",t,e,n),l=Object(c.d)("step",t,e,n);return[Mt.a(r,o,l,Object(c.d)("dtype",t,e,n))]}case"TruncatedNormal":{const r=Object(c.d)("shape",t,e,n),o=Object(c.d)("mean",t,e,n),l=Object(c.d)("stdDev",t,e,n),d=Object(c.d)("seed",t,e,n);return[Bt.a(r,o,l,Object(c.d)("dtype",t,e,n),d)]}case"Zeros":return[Lt.a(Object(c.d)("shape",t,e,n),Object(c.d)("dtype",t,e,n))];case"ZerosLike":return[Vt.a(Object(c.d)("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"dynamic":return(async(t,e,n)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:o,maxOutputSize:c,iouThreshold:l,scoreThreshold:d,softNmsSigma:h}=Gt(t,e,n),f=await xt.j.nonMaxSuppressionWithScoreAsync(r,o,c,l,d,h);return[f.selectedIndices,f.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:o,maxOutputSize:l,iouThreshold:d,scoreThreshold:h}=Gt(t,e,n),f=Object(c.d)("padToMaxOutputSize",t,e,n),m=await xt.j.nonMaxSuppressionPaddedAsync(r,o,l,d,h,f);return[m.selectedIndices,m.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:o,maxOutputSize:c,iouThreshold:l,scoreThreshold:d}=Gt(t,e,n);return[await xt.j.nonMaxSuppressionAsync(r,o,c,l,d)]}case"Where":{const r=zt.a(Object(c.d)("condition",t,e,n),"bool"),o=[await Ut.a(r)];return r.dispose(),o}case"ListDiff":return Wt.a(Object(c.d)("x",t,e,n),Object(c.d)("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n);case"evaluation":return r.Ab((()=>((t,e,n)=>{switch(t.op){case"TopKV2":{const r=Object(c.d)("x",t,e,n),o=Object(c.d)("k",t,e,n),l=Object(c.d)("sorted",t,e,n),d=Ht.a(r,o,l);return[d.values,d.indices]}case"Unique":{const r=Object(c.d)("x",t,e,n),o=qt.a(r);return[o.values,o.indices]}case"UniqueV2":{const r=Object(c.d)("x",t,e,n),o=Object(c.d)("axis",t,e,n),l=qt.a(r,o);return[l.values,l.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"image":return r.Ab((()=>((t,e,n)=>{switch(t.op){case"ResizeBilinear":{const r=Object(c.d)("images",t,e,n),o=Object(c.d)("size",t,e,n),l=Object(c.d)("alignCorners",t,e,n);return[xt.j.resizeBilinear(r,[o[0],o[1]],l)]}case"ResizeNearestNeighbor":{const r=Object(c.d)("images",t,e,n),o=Object(c.d)("size",t,e,n),l=Object(c.d)("alignCorners",t,e,n);return[xt.j.resizeNearestNeighbor(r,[o[0],o[1]],l)]}case"CropAndResize":{const image=Object(c.d)("image",t,e,n),r=Object(c.d)("boxes",t,e,n),o=Object(c.d)("boxInd",t,e,n),l=Object(c.d)("cropSize",t,e,n),d=Object(c.d)("method",t,e,n),h=Object(c.d)("extrapolationValue",t,e,n);return[xt.j.cropAndResize(image,r,o,l,d,h)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"graph":return r.Ab((()=>((t,e,n)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const r=Object(c.d)("default",t,e,n);return[Object(c.e)(t.name,e,n)||r];case"Placeholder":return[Object(c.e)(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const data=Object(c.d)("x",t,e,n);return[Object(c.a)(data)]}case"IdentityN":return Object(c.d)("x",t,e,n).map((t=>Object(c.a)(t)));case"Snapshot":const o=Object(c.d)("x",t,e,n);return[Object(c.a)(o)];case"Shape":return[Kt.a(Object(c.d)("x",t,e,n).shape,"int32")];case"ShapeN":return Object(c.d)("x",t,e,n).map((t=>Kt.a(t.shape)));case"Size":return[Xt.a(Object(c.d)("x",t,e,n).size,"int32")];case"Rank":return[Xt.a(Object(c.d)("x",t,e,n).rank,"int32")];case"NoOp":return[Xt.a(1)];case"Print":const input=Object(c.d)("x",t,e,n),data=Object(c.d)("data",t,e,n),l=Object(c.d)("message",t,e,n),d=Object(c.d)("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let i=0;i<data.length;i++)console.log(Array.prototype.slice.call(data[i].dataSync()).slice(0,d));return[input];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"logical":return r.Ab((()=>((t,e,n)=>{switch(t.op){case"Equal":return[Yt.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"NotEqual":return[Qt.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"Greater":return[Jt.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"GreaterEqual":return[Zt.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"Less":return[te.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"LessEqual":return[ee.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"LogicalAnd":return[ne.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"LogicalNot":return[re.a(Object(c.d)("a",t,e,n))];case"LogicalOr":return[ae.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];case"Select":case"SelectV2":return[se.a(Object(c.d)("condition",t,e,n),Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"matrices":return r.Ab((()=>((t,e,n)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[oe.a(Object(c.d)("a",t,e,n),Object(c.d)("b",t,e,n),Object(c.d)("transposeA",t,e,n),Object(c.d)("transposeB",t,e,n))];case"Transpose":return[ie.a(Object(c.d)("x",t,e,n),Object(c.d)("perm",t,e,n))];case"_FusedMatMul":const[r,o]=Object(c.d)("fusedOps",t,e,n),l="biasadd"===r,d="prelu"===o,h=Object(c.d)("numArgs",t,e,n);if(l){if(d&&2!==h)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!d&&1!==h)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[f,m]=Object(c.d)("args",t,e,n);return[xt.h.matMul({a:Object(c.d)("a",t,e,n),b:Object(c.d)("b",t,e,n),transposeA:Object(c.d)("transposeA",t,e,n),transposeB:Object(c.d)("transposeB",t,e,n),bias:f,activation:o,preluActivationWeights:m})];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"normalization":return r.Ab((()=>((t,e,n)=>{switch(t.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[ce.a(Object(c.d)("x",t,e,n),Object(c.d)("mean",t,e,n),Object(c.d)("variance",t,e,n),Object(c.d)("offset",t,e,n),Object(c.d)("scale",t,e,n),Object(c.d)("epsilon",t,e,n))];case"LRN":return[ue.a(Object(c.d)("x",t,e,n),Object(c.d)("radius",t,e,n),Object(c.d)("bias",t,e,n),Object(c.d)("alpha",t,e,n),Object(c.d)("beta",t,e,n))];case"Softmax":return[le.a(Object(c.d)("x",t,e,n))];case"LogSoftmax":return[de.a(Object(c.d)("x",t,e,n))];case"SparseToDense":return[pe.a(Object(c.d)("sparseIndices",t,e,n),Object(c.d)("outputShape",t,e,n),Object(c.d)("sparseValues",t,e,n),Object(c.d)("defaultValue",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"reduction":return r.Ab((()=>((t,e,n)=>{switch(t.op){case"Max":{const r=Object(c.d)("axis",t,e,n),o=Object(c.d)("keepDims",t,e,n);return[he.a(Object(c.d)("x",t,e,n),r,o)]}case"Mean":{const r=Object(c.d)("axis",t,e,n),o=Object(c.d)("keepDims",t,e,n);return[fe.a(Object(c.d)("x",t,e,n),r,o)]}case"Min":{const r=Object(c.d)("axis",t,e,n),o=Object(c.d)("keepDims",t,e,n);return[me.a(Object(c.d)("x",t,e,n),r,o)]}case"Sum":{const r=Object(c.d)("axis",t,e,n),o=Object(c.d)("keepDims",t,e,n);return[be.a(Object(c.d)("x",t,e,n),r,o)]}case"All":{const r=Object(c.d)("axis",t,e,n),o=Object(c.d)("keepDims",t,e,n);return[ge.a(Object(c.d)("x",t,e,n),r,o)]}case"Any":{const r=Object(c.d)("axis",t,e,n),o=Object(c.d)("keepDims",t,e,n);return[ye.a(Object(c.d)("x",t,e,n),r,o)]}case"ArgMax":{const r=Object(c.d)("axis",t,e,n);return[Oe.a(Object(c.d)("x",t,e,n),r)]}case"ArgMin":{const r=Object(c.d)("axis",t,e,n);return[xe.a(Object(c.d)("x",t,e,n),r)]}case"Prod":{const r=Object(c.d)("axis",t,e,n),o=Object(c.d)("keepDims",t,e,n);return[lt.a(Object(c.d)("x",t,e,n),r,o)]}case"Cumsum":{const r=Object(c.d)("axis",t,e,n),o=Object(c.d)("exclusive",t,e,n),l=Object(c.d)("reverse",t,e,n);return[ve.a(Object(c.d)("x",t,e,n),r,o,l)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"slice_join":return r.Ab((()=>((t,e,n)=>{switch(t.op){case"ConcatV2":case"Concat":{const r=Object(c.d)("n",t,e,n),o=Object(c.d)("axis",t,e,n);let l=Object(c.d)("tensors",t,e,n);return l=l.slice(0,r),[we.a(l,o)]}case"GatherV2":case"Gather":{const r=Object(c.d)("axis",t,e,n),input=Object(c.d)("x",t,e,n),o=Object(c.d)("indices",t,e,n);return[je.a(input,zt.a(o,"int32"),r)]}case"ReverseV2":case"Reverse":{const r=Object(c.d)("axis",t,e,n),input=Object(c.d)("x",t,e,n);return[Ee.a(input,r)]}case"Slice":{const r=Object(c.d)("begin",t,e,n),o=Object(c.d)("size",t,e,n);return[$e.a(Object(c.d)("x",t,e,n),r,o)]}case"StridedSlice":{const r=Object(c.d)("begin",t,e,n),o=Object(c.d)("end",t,e,n),l=Object(c.d)("strides",t,e,n),d=Object(c.d)("beginMask",t,e,n),h=Object(c.d)("endMask",t,e,n),f=Object(c.d)("ellipsisMask",t,e,n),m=Object(c.d)("newAxisMask",t,e,n),y=Object(c.d)("shrinkAxisMask",t,e,n),O=Object(c.d)("x",t,e,n);return[Ce.a(O,r,o,l,d,h,f,m,y)]}case"Pack":return Object(r.Ab)((()=>{const o=Object(c.d)("axis",t,e,n),l=Object(c.d)("tensors",t,e,n),d=l[0].shape,h=Ne.a(l[0]).shape,f=l.map((t=>{const e=r.Eb.arraysEqual(t.shape,d);if(!e&&!r.Eb.arraysEqual(Ne.a(t).shape,h))throw new Error("the input tensors shape does not match");return e?t:Re.a(t,d)}));return[Se.a(f,o)]}));case"Unpack":{const r=Object(c.d)("axis",t,e,n),o=Object(c.d)("tensor",t,e,n);return Te.a(o,r)}case"Tile":{const r=Object(c.d)("reps",t,e,n);return[Ie.a(Object(c.d)("x",t,e,n),r)]}case"Split":case"SplitV":{const r=Object(c.d)("axis",t,e,n),o=Object(c.d)("numOrSizeSplits",t,e,n),l=Object(c.d)("x",t,e,n);return Ae.a(l,o,r)}case"ScatterNd":{const r=Object(c.d)("indices",t,e,n),o=Object(c.d)("values",t,e,n),l=Object(c.d)("shape",t,e,n);return[ke.a(r,o,l)]}case"GatherNd":{const r=Object(c.d)("x",t,e,n),o=Object(c.d)("indices",t,e,n);return[De.a(r,o)]}case"SparseToDense":{const r=Object(c.d)("sparseIndices",t,e,n),o=Object(c.d)("outputShape",t,e,n),l=Object(c.d)("sparseValues",t,e,n),d=Object(c.d)("defaultValue",t,e,n);return[pe.a(r,l,o,l.dtype===d.dtype?d:zt.a(d,l.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"spectral":return r.Ab((()=>((t,e,n)=>{switch(t.op){case"FFT":return[_e.a(Object(c.d)("x",t,e,n))];case"IFFT":return[Fe.a(Object(c.d)("x",t,e,n))];case"RFFT":return[Pe.a(Object(c.d)("x",t,e,n))];case"IRFFT":return[Me.a(Object(c.d)("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"transformation":return r.Ab((()=>((t,e,n)=>{switch(t.op){case"Cast":return[zt.a(Object(c.d)("x",t,e,n),Object(c.d)("dtype",t,e,n))];case"ExpandDims":{const r=Object(c.d)("axis",t,e,n);return[Be.a(Object(c.d)("x",t,e,n),r)]}case"Squeeze":{const r=Object(c.d)("axis",t,e,n);return[Ne.a(Object(c.d)("x",t,e,n),r)]}case"Reshape":return[Re.a(Object(c.d)("x",t,e,n),Object(c.d)("shape",t,e,n))];case"PadV2":case"Pad":return[Le.a(Object(c.d)("x",t,e,n),Object(c.d)("padding",t,e,n),Object(c.d)("constantValue",t,e,n))];case"SpaceToBatchND":{const r=Object(c.d)("blockShape",t,e,n),o=Object(c.d)("paddings",t,e,n);return[Ve.a(Object(c.d)("x",t,e,n),r,o)]}case"BatchToSpaceND":{const r=Object(c.d)("blockShape",t,e,n),o=Object(c.d)("crops",t,e,n);return[ze.a(Object(c.d)("x",t,e,n),r,o)]}case"DepthToSpace":{const r=Object(c.d)("blockSize",t,e,n),o=Object(c.d)("dataFormat",t,e,n).toUpperCase();return[Ue.a(Object(c.d)("x",t,e,n),r,o)]}case"BroadcastTo":return[We.a(Object(c.d)("x",t,e,n),Object(c.d)("shape",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"custom":const o=Object(d.a)(t.op);if(o&&o.customExecutor)return o.customExecutor(new l(t,e,n));throw TypeError(`Custom op ${t.op} is not registered.`);default:throw TypeError(`Unknown op '${t.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return o instanceof Promise?o.then((data=>[].concat(data))):[].concat(o)}class He{constructor(t={},e={},n={},r={}){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=n,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let i=0;i<this.contexts.length-1;i++){const e=this.contexts.slice(0,this.contexts.length-i);t.push(this.contextIdforContexts(e))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map((t=>0===t.id&&0===t.iterationId?"":`${t.frameName}-${t.iterationId}`)).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function qe(t,e,n,r){const o=new Set,l=[];let d=null,h=null;const f=new Set,m=Object.keys(t).map((t=>Object(c.g)(t)[0]));let y=[];null!=r&&(y=r.map((t=>Object(c.g)(t.name)[0])));const O=[...e];for(;O.length>0;){const t=O.pop();(Ye(t)||Qe(t))&&null==d&&(d=t,h=d.children.map((t=>t.name)).filter((t=>o.has(t)))),o.add(t.name),null==n[t.name]&&(-1===m.indexOf(t.name)&&-1===y.indexOf(t.name)&&(0!==t.inputs.length?t.inputs.forEach((input=>{f.has(input.name)||(f.add(input.name),O.push(input))})):l.push(t.name)))}return{inputs:t,outputs:e,usedNodes:o,missingInputs:l,dynamicNode:d,syncInputs:h}}const Ke=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Xe=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"];function Ye(t){return Ke.indexOf(t.op)>=0}function Qe(t){return Xe.indexOf(t.op)>=0}class Je{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach((e=>{this._functionExecutorMap[e]=new Je(t.functions[e],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map((e=>t[e].map((t=>t.id))));this._weightIds=[].concat(...e),this._weightMap=t}get inputs(){return this._inputs.map((t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((t=>t.signatureKey||t.name))}get outputNodes(){return this._outputs.map((t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e}))}get functions(){return Object.keys(this._functions).reduce(((map,t)=>(map[t]=this._functions[t].signature,map)),{})}getCompilationKey(t,e){const n=t.map((t=>t.name)).sort(),r=e.map((t=>t.name)).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(t,e){const n=qe(t,e,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:o,syncInputs:l}=n;if(null!=o)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${l}]`);if(r.length>0){const n=e.map((t=>t.name)),o=Object.keys(t);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${o}]. Missing the following inputs: [${r}]`)}return function(t,e,n){const{usedNodes:r,inputs:o}=n,l=[],d=Object.keys(o).map((t=>Object(c.g)(t)[0])).map((e=>t.nodes[e])),h=t.initNodes;d.forEach((input=>{r.has(input.name)&&l.push(input)})),t.weights.forEach((t=>{r.has(t.name)&&l.push(t)})),null!=h&&h.forEach((t=>{r.has(t.name)&&l.push(t)}));const f=new Set,m=[];for(;l.length>0;){const t=l.pop();f.add(t.name),e[t.name]||m.push(t),t.children.forEach((t=>{!f.has(t.name)&&r.has(t.name)&&t.inputs.every((input=>f.has(input.name)))&&l.push(t)}))}return m}(this.graph,this.weightMap,n)}execute(t,e){t=this.mapInputs(t);const n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const o=n.map((t=>this.graph.nodes[Object(c.g)(t)[0]])),l=e.map((t=>Object(c.g)(t)[0]));let d=l.map((t=>this.graph.nodes[t]));0===d.length&&(d=this._outputs);const h=this.getCompilationKey(o,d);let f=this.compiledMap.get(h);null==f&&(f=this.compile(t,d),this.compiledMap.set(h,f));const m={},y={};return Object(r.Ab)((()=>{const n=new He(this.weightMap,m,y,this.functionExecutorMap),r=Object.assign({},this.weightMap);Object.keys(t).forEach((e=>{const[n,o]=Object(c.g)(e),l=[];l[o]=t[e],r[n]=l}));const o=this.getFrozenTensorIds(r),d={};for(let i=0;i<f.length;i++){const t=f[i];if(!r[t.name]){const e=Ge(t,r,n);if(e instanceof Promise)throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);r[t.name]=e,this.checkTensorForDisposal(t.name,t,r,n,o,l,d)}}return null==this.parent&&n.dispose(o),e.map((t=>Object(c.e)(t,r,n)))}))}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map((e=>t[e])).map((t=>t.map((t=>t.id)))));return new Set(e)}checkTensorForDisposal(t,e,n,r,o,l,d){"control"!==e.category&&-1===l.indexOf(t)&&(n[t].forEach((t=>{null!=t&&(d[t.id]=(d[t.id]||0)+e.children.length)})),e.inputs.forEach((input=>{if("control"!==input.category){const t=Object(c.f)(input.name,n,r);null!=t&&t.forEach((t=>{if(t&&!o.has(t.id)){const e=d[t.id];1===e?(t.dispose(),delete d[t.id]):null!=e&&d[t.id]--}}))}})))}async executeAsync(t,e){return this._executeAsync(t,e)}async _executeAsync(t,e,n=!1,r={},o={}){n||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));const l=new He(this.weightMap,r,o,this.functionExecutorMap),d=await this.executeWithControlFlow(t,l,e,n),h=e.map((t=>Object(c.e)(t,d,l))),f=h.map((t=>t.id)),m=Object.keys(t).map((e=>t[e].id)),y=new Set([...f,...m,...this.weightIds]);return Object.keys(d).forEach((t=>{d[t].forEach((t=>{!t||t.isDisposed||y.has(t.id)||t.dispose()}))})),null==this.parent&&l.dispose(y),h}async executeFunctionAsync(t,e,n){const r=t.reduce(((map,t,e)=>(map[this.inputs[e].name]=t,map)),{});return this._executeAsync(r,this.outputNodes,!0,e,n)}async executeWithControlFlow(t,e,n,r){const o=Object.keys(t),l=o.map((t=>this.graph.nodes[Object(c.g)(t)[0]])),d=n.map((t=>Object(c.g)(t)[0])),h=d.map((t=>this.graph.nodes[t])),{usedNodes:f,missingInputs:m,dynamicNode:y,syncInputs:O}=qe(t,h,this.weightMap),x=[...l,...this.graph.weights].map((t=>({node:t,contexts:e.currentContext}))),v=Object.assign({},this.weightMap);Object.keys(t).forEach((e=>{const[n,r]=Object(c.g)(e),o=[];o[r]=t[e],v[n]=o}));const w={},j=this.getFrozenTensorIds(v),E={};for(;x.length>0;){const t=this.processStack(l,x,e,v,E,j,d,w,f);await Promise.all(t)}null!=y||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const $=h.filter((t=>!Ye(t)&&!Object(c.e)(t.name,v,e))).map((t=>t.name));if($.length>0){let t="";throw null!=y&&(t=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${O}]`),new Error(`Cannot compute the outputs [${$}] from the provided inputs [${o}]. Consider providing the following inputs: [${m}]. ${t}`)}return v}processStack(t,e,n,r,o,l,d,h,f){const m=[];for(;e.length>0;){const y=e.pop();n.currentContext=y.contexts;let O="";if("Enter"===y.node.op&&Object(c.d)("isConstant",y.node,r,n)&&([O]=Object(c.b)(y.node.name,n)),-1===t.indexOf(y.node)){const t=Ge(y.node,r,n);O||([O]=Object(c.b)(y.node.name,n));const x=n.currentContext;t instanceof Promise?m.push(t.then((t=>(r[O]=t,n.currentContext=x,this.checkTensorForDisposal(O,y.node,r,n,l,d,h),this.processChildNodes(y.node,e,n,r,o,f),t)))):(r[O]=t,this.checkTensorForDisposal(O,y.node,r,n,l,d,h),this.processChildNodes(y.node,e,n,r,o,f))}else this.processChildNodes(y.node,e,n,r,o,f)}return m}processChildNodes(t,e,n,r,o,l){t.children.forEach((t=>{const[d]=Object(c.b)(t.name,n);!o[d]&&l.has(t.name)&&("Merge"===t.op?t.inputNames.some((t=>!!Object(c.e)(t,r,n)))&&(o[d]=!0,e.push({contexts:n.currentContext,node:t})):t.inputNames.every((t=>!!Object(c.e)(t,r,n)))&&(o[d]=!0,e.push({contexts:n.currentContext,node:t})))}))}dispose(){Object.keys(this.weightMap).forEach((t=>this.weightMap[t].forEach((t=>t.dispose()))))}checkInputShapeAndType(t){Object.keys(t).forEach((e=>{const input=t[e],[n]=Object(c.g)(e),o=this.graph.nodes[n];if(o.attrParams.shape&&o.attrParams.shape.value){const t=o.attrParams.shape.value,e=t.length===input.shape.length&&input.shape.every(((e,n)=>-1===t[n]||t[n]===e));r.Eb.assert(e,(()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${t}], but was [${input.shape}]`))}o.attrParams.dtype&&o.attrParams.dtype.value&&r.Eb.assert(input.dtype===o.attrParams.dtype.value,(()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${input.dtype}`))}))}mapInputs(t){const e={};for(const n in t)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]){e[this._signature.inputs[n].name]=t[n]}else e[n]=t[n];return e}checkInputs(t){const e=Object.keys(t).filter((t=>{const[e]=Object(c.g)(t);return null==this.graph.nodes[e]}));if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map((t=>{if(null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[t]){return this._signature.outputs[t].name}return t}),{})}checkOutputs(t){t.forEach((t=>{const[e]=Object(c.g)(t);if(!this.graph.nodes[e])throw new Error(`The output '${t}' is not found in the graph`)}))}}class Ze{constructor(t,e={}){this.modelUrl=t,this.loadOptions=e,this.version="n/a",null==e&&(this.loadOptions={})}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}findIOHandler(){const path=this.modelUrl;if(null!=path.load)this.handler=path;else if(null!=this.loadOptions.requestInit)this.handler=r.fb.browserHTTPRequest(path,this.loadOptions);else{const t=r.fb.getLoadHandlers(path,this.loadOptions);if(0===t.length)t.push(r.fb.browserHTTPRequest(path,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[path]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=await this.handler.load();return this.loadSync(t)}loadSync(t){this.artifacts=t;const e=this.artifacts.modelTopology;let n={};null!=this.artifacts.userDefinedMetadata&&(n=this.artifacts.userDefinedMetadata.signature),this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const c=r.fb.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Je(o.a.Instance.transformGraph(e,n)),this.executor.weightMap=this.convertTensorMapToTensorsMap(c),null!=t.modelInitializer){const e=o.a.Instance.transformGraph(t.modelInitializer);this.initializer=new Je(e),this.initializer.weightMap=this.executor.weightMap,this.initializer.execute({},[])}return!0}async save(t,e){if("string"==typeof t){const e=r.fb.getSaveHandlers(t);if(0===e.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new Error(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}predict(t,e){return this.execute(t,this.outputNodes)}normalizeInputs(t){if(!(t instanceof r.M||Array.isArray(t)))return t;if((t=Array.isArray(t)?t:[t]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce(((map,e,i)=>(map[e]=t[i],map)),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const n=this.executor.execute(t,e);return n.length>1?n:n[0]}async executeAsync(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const n=await this.executor.executeAsync(t,e);return n.length>1?n:n[0]}convertTensorMapToTensorsMap(map){return Object.keys(map).reduce(((t,e)=>(t[e]=[map[e]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose()}}async function tn(t,e={}){if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==e&&(e={}),e.fromTFHub&&null==t.load&&(t.endsWith("/")||(t+="/"),t=`${t}model.json?tfjs-format=file`);const n=new Ze(t,e);return await n.load(),n}var en=function(){return(en=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var o in e=arguments[n])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)};function nn(t,e,n,r){return new(n||(n=Promise))((function(o,i){function s(t){try{c(r.next(t))}catch(t){i(t)}}function a(t){try{c(r.throw(t))}catch(t){i(t)}}function c(t){var e;t.done?o(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(s,a)}c((r=r.apply(t,e||[])).next())}))}function rn(t,e){var n,r,o,i,s={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function a(i){return function(a){return function(i){if(n)throw new TypeError("Generator is already executing.");for(;s;)try{if(n=1,r&&(o=2&i[0]?r.return:i[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,i[1])).done)return o;switch(r=0,o&&(i=[2&i[0],o.value]),i[0]){case 0:case 1:o=i;break;case 4:return s.label++,{value:i[1],done:!1};case 5:s.label++,r=i[1],i=[0];continue;case 7:i=s.ops.pop(),s.trys.pop();continue;default:if(!((o=(o=s.trys).length>0&&o[o.length-1])||6!==i[0]&&2!==i[0])){s=0;continue}if(3===i[0]&&(!o||i[1]>o[0]&&i[1]<o[3])){s.label=i[1];break}if(6===i[0]&&s.label<o[1]){s.label=o[1],o=i;break}if(o&&s.label<o[2]){s.label=o[2],s.ops.push(i);break}o[2]&&s.ops.pop(),s.trys.pop();continue}i=e.call(t,s)}catch(t){i=[6,t],r=0}finally{n=o=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,a])}}}const an=t=>({startEndTensor:t,startPoint:Object(r.rb)(t,[0,0],[-1,2]),endPoint:Object(r.rb)(t,[0,2],[-1,2])}),sn={strides:[8,16],anchors:[2,6]};function on(t,i){let s,a,e;if(t.topLeft instanceof r.M&&t.bottomRight instanceof r.M){const[u,n]=Object(r.Ab)((()=>[Object(r.W)([Object(r.vb)(i-1,t.topLeft.slice(0,1)),t.topLeft.slice(1,1)]),Object(r.W)([Object(r.vb)(i-1,t.bottomRight.slice(0,1)),t.bottomRight.slice(1,1)])]));s=u,a=n,null!=t.landmarks&&(e=Object(r.Ab)((()=>{const e=Object(r.vb)(Object(r.yb)([i-1,0]),t.landmarks),s=Object(r.yb)([1,-1]);return Object(r.jb)(e,s)})))}else{const[n,r]=t.topLeft,[o,c]=t.bottomRight;s=[i-1-n,r],a=[i-1-o,c],null!=t.landmarks&&(e=t.landmarks.map((t=>[i-1-t[0],t[1]])))}const u={topLeft:s,bottomRight:a};return null!=e&&(u.landmarks=e),null!=t.probability&&(u.probability=t.probability instanceof r.M?t.probability.clone():t.probability),u}function cn(t,e){return Object(r.Ab)((()=>{let n;return n=t.hasOwnProperty("box")?t.box:t,((t,e)=>{const n=Object(r.jb)(t.startPoint,e),o=Object(r.jb)(t.endPoint,e),s=Object(r.X)([n,o],1);return an(s)})(n,e).startEndTensor.squeeze()}))}class un{constructor(t,e,n,i,s,a){this.blazeFaceModel=t,this.width=e,this.height=n,this.maxFaces=i,this.anchorsData=function(t,e,n){const r=[];for(let o=0;o<n.strides.length;o++){const i=n.strides[o],s=Math.floor((e+i-1)/i),a=Math.floor((t+i-1)/i),c=n.anchors[o];for(let t=0;t<s;t++){const e=i*(t+.5);for(let t=0;t<a;t++){const n=i*(t+.5);for(let t=0;t<c;t++)r.push([n,e])}}}return r}(e,n,sn),this.anchors=Object(r.zb)(this.anchorsData),this.inputSizeData=[e,n],this.inputSize=Object(r.yb)([e,n]),this.iouThreshold=s,this.scoreThreshold=a}async getBoundingBoxes(t,e,n=!0){const[p,o,g]=Object(r.Ab)((()=>{const e=t.resizeBilinear([this.width,this.height]),n=Object(r.jb)(Object(r.vb)(e.div(255),.5),2),o=this.blazeFaceModel.predict(n).squeeze(),c=function(t,e,n){const a=Object(r.rb)(t,[0,1],[-1,2]),o=Object(r.Q)(a,e),c=Object(r.rb)(t,[0,3],[-1,2]),l=Object(r.Z)(c,n),d=Object(r.Z)(o,n),p=Object(r.Z)(l,2),h=Object(r.vb)(d,p),g=Object(r.Q)(d,p),f=Object(r.jb)(h,n),b=Object(r.jb)(g,n);return Object(r.X)([f,b],1)}(o,this.anchors,this.inputSize),l=Object(r.rb)(o,[0,0],[-1,1]);return[o,c,Object(r.qb)(l).squeeze()]})),c=console.warn;console.warn=()=>{};const b=r.eb.nonMaxSuppression(o,g,this.maxFaces,this.iouThreshold,this.scoreThreshold);console.warn=c;const l=await b.array();b.dispose();let d=l.map((t=>Object(r.rb)(o,[t,0],[1,-1])));e||(d=await Promise.all(d.map((async t=>{const e=await t.array();return t.dispose(),e}))));const h=t.shape[1],f=t.shape[2];let m;m=e?Object(r.Z)([f,h],this.inputSize):[f/this.inputSizeData[0],h/this.inputSizeData[1]];const y=[];for(let t=0;t<d.length;t++){const o=d[t],c=Object(r.Ab)((()=>{const c=an(o instanceof r.M?o:Object(r.zb)(o));if(!n)return c;const d=l[t];let i;return i=e?this.anchors.slice([d,0],[1,2]):this.anchorsData[d],{box:c,landmarks:Object(r.rb)(p,[d,5],[1,-1]).squeeze().reshape([6,-1]),probability:Object(r.rb)(g,[d],[1]),anchor:i}}));y.push(c)}return o.dispose(),g.dispose(),p.dispose(),{boxes:y,scaleFactor:m}}async estimateFaces(t,e=!1,n=!1,o=!0){const[,i]=function(t){return t instanceof r.M?[t.shape[0],t.shape[1]]:[t.height,t.width]}(t),s=Object(r.Ab)((()=>(t instanceof r.M||(t=r.S.fromPixels(t)),t.toFloat().expandDims(0)))),{boxes:a,scaleFactor:c}=await this.getBoundingBoxes(s,e,o);return s.dispose(),e?a.map((t=>{const e=cn(t,c);let r={topLeft:e.slice([0],[2]),bottomRight:e.slice([2],[2])};if(o){const{landmarks:e,probability:n,anchor:o}=t,i=e.add(o).mul(c);r.landmarks=i,r.probability=n}return n&&(r=on(r,i)),r})):Promise.all(a.map((async t=>{const e=cn(t,c);let r;if(o){const[n,o,i]=await Promise.all([t.landmarks,e,t.probability].map((async t=>t.array()))),s=t.anchor,[a,u]=c,l=n.map((t=>[(t[0]+s[0])*a,(t[1]+s[1])*u]));r={topLeft:o.slice(0,2),bottomRight:o.slice(2),landmarks:l,probability:i},(t=>{t.startEndTensor.dispose(),t.startPoint.dispose(),t.endPoint.dispose()})(t.box),t.landmarks.dispose(),t.probability.dispose()}else{const t=await e.array();r={topLeft:t.slice(0,2),bottomRight:t.slice(2)}}return e.dispose(),n&&(r=on(r,i)),r})))}}async function ln({maxFaces:t=10,inputWidth:e=128,inputHeight:n=128,iouThreshold:r=.3,scoreThreshold:o=.75}={}){const i=await tn("https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1",{fromTFHub:!0});return new un(i,e,n,t,r,o)}var dn={silhouette:[10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109],lipsUpperOuter:[61,185,40,39,37,0,267,269,270,409,291],lipsLowerOuter:[146,91,181,84,17,314,405,321,375,291],lipsUpperInner:[78,191,80,81,82,13,312,311,310,415,308],lipsLowerInner:[78,95,88,178,87,14,317,402,318,324,308],rightEyeUpper0:[246,161,160,159,158,157,173],rightEyeLower0:[33,7,163,144,145,153,154,155,133],rightEyeUpper1:[247,30,29,27,28,56,190],rightEyeLower1:[130,25,110,24,23,22,26,112,243],rightEyeUpper2:[113,225,224,223,222,221,189],rightEyeLower2:[226,31,228,229,230,231,232,233,244],rightEyeLower3:[143,111,117,118,119,120,121,128,245],rightEyebrowUpper:[156,70,63,105,66,107,55,193],rightEyebrowLower:[35,124,46,53,52,65],rightEyeIris:[473,474,475,476,477],leftEyeUpper0:[466,388,387,386,385,384,398],leftEyeLower0:[263,249,390,373,374,380,381,382,362],leftEyeUpper1:[467,260,259,257,258,286,414],leftEyeLower1:[359,255,339,254,253,252,256,341,463],leftEyeUpper2:[342,445,444,443,442,441,413],leftEyeLower2:[446,261,448,449,450,451,452,453,464],leftEyeLower3:[372,340,346,347,348,349,350,357,465],leftEyebrowUpper:[383,300,293,334,296,336,285,417],leftEyebrowLower:[265,353,276,283,282,295],leftEyeIris:[468,469,470,471,472],midwayBetweenEyes:[168],noseTip:[1],noseBottom:[2],noseRightCorner:[98],noseLeftCorner:[327],rightCheek:[205],leftCheek:[425]};function pn(t){return[Math.abs(t.endPoint[0]-t.startPoint[0]),Math.abs(t.endPoint[1]-t.startPoint[1])]}function hn(t){return[t.startPoint[0]+(t.endPoint[0]-t.startPoint[0])/2,t.startPoint[1]+(t.endPoint[1]-t.startPoint[1])/2]}function fn(t,e){void 0===e&&(e=1.5);var n=hn(t),r=pn(t),o=[e*r[0]/2,e*r[1]/2];return{startPoint:[n[0]-o[0],n[1]-o[1]],endPoint:[n[0]+o[0],n[1]+o[1]],landmarks:t.landmarks}}var mn=[[1,0,0],[0,1,0],[0,0,1]];function bn(t,e){return[[1,0,t],[0,1,e],[0,0,1]]}function gn(t,e){for(var n=0,r=0;r<t.length;r++)n+=t[r]*e[r];return n}function yn(t,e){for(var n=[],r=0;r<t.length;r++)n.push(t[r][e]);return n}function On(t,e){for(var n=[],r=t.length,o=0;o<r;o++){n.push([]);for(var i=0;i<r;i++)n[o].push(gn(t[o],yn(e,i)))}return n}function xn(t,e){var n=Math.cos(t),r=Math.sin(t),o=[[n,-r,0],[r,n,0],[0,0,1]],i=On(bn(e[0],e[1]),o);return On(i,bn(-e[0],-e[1]))}var vn=[13,dn.midwayBetweenEyes[0]],wn=[3,2],jn=dn.leftEyeLower0,En=[jn[0],jn[jn.length-1]],$n=dn.rightEyeLower0,Cn=[$n[0],$n[$n.length-1]],Nn=[{key:"EyeUpper0",indices:[9,10,11,12,13,14,15]},{key:"EyeUpper1",indices:[25,26,27,28,29,30,31]},{key:"EyeUpper2",indices:[41,42,43,44,45,46,47]},{key:"EyeLower0",indices:[0,1,2,3,4,5,6,7,8]},{key:"EyeLower1",indices:[16,17,18,19,20,21,22,23,24]},{key:"EyeLower2",indices:[32,33,34,35,36,37,38,39,40]},{key:"EyeLower3",indices:[54,55,56,57,58,59,60,61,62]},{key:"EyebrowUpper",indices:[63,64,65,66,67,68,69,70]},{key:"EyebrowLower",indices:[48,49,50,51,52,53]}];function Rn(t,e,n,r){for(var o=0;o<Nn.length;o++){var i=Nn[o],s=i.key,a=i.indices,c=dn[""+n+s];if(null==r||r.includes(s))for(var u=0;u<a.length;u++){var l=a[u];t[c[u]]=[e[l][0],e[l][1],(e[l][2]+t[c[u]][2])/2]}}}var Sn=function(){function t(t,e,n,r,o,i,s){this.regionsOfInterest=[],this.runsWithoutFaceDetector=0,this.boundingBoxDetector=t,this.meshDetector=e,this.irisModel=s,this.meshWidth=n,this.meshHeight=r,this.maxContinuousChecks=o,this.maxFaces=i}return t.prototype.transformRawCoords=function(t,e,n,r){var o,i,s,a,c=this,u=pn({startPoint:e.startPoint,endPoint:e.endPoint}),l=[u[0]/this.meshWidth,u[1]/this.meshHeight],d=t.map((function(t){return[l[0]*(t[0]-c.meshWidth/2),l[1]*(t[1]-c.meshHeight/2),t[2]]})),h=xn(n,[0,0]),f=d.map((function(t){return function(t,e){return[gn(t,e[0]),gn(t,e[1])]}(t,h).concat([t[2]])})),p=(i=[[(o=r)[0][0],o[1][0]],[o[0][1],o[1][1]]],s=[o[0][2],o[1][2]],a=[-gn(i[0],s),-gn(i[1],s)],[i[0].concat(a[0]),i[1].concat(a[1]),[0,0,1]]),m=hn({startPoint:e.startPoint,endPoint:e.endPoint}).concat([1]),g=[gn(m,p[0]),gn(m,p[1])];return f.map((function(t){return[t[0]+g[0],t[1]+g[1],t[2]]}))},t.prototype.getLeftToRightEyeDepthDifference=function(t){return t[En[0]][2]-t[Cn[0]][2]},t.prototype.getEyeBox=function(t,e,n,o,c){void 0===c&&(c=!1);var i=function(t){var e=hn(t),n=pn(t),r=Math.max.apply(Math,n)/2;return{startPoint:[e[0]-r,e[1]-r],endPoint:[e[0]+r,e[1]+r],landmarks:t.landmarks}}(fn(this.calculateLandmarksBoundingBox([t[n],t[o]]),2.3)),s=pn(i),a=r.eb.cropAndResize(e,[[i.startPoint[1]/this.meshHeight,i.startPoint[0]/this.meshWidth,i.endPoint[1]/this.meshHeight,i.endPoint[0]/this.meshWidth]],[0],[64,64]);return c&&(a=r.eb.flipLeftRight(a)),{box:i,boxSize:s,crop:a}},t.prototype.getEyeCoords=function(t,e,n,r){void 0===r&&(r=!1);for(var o=[],i=0;i<76;i++){var s=t[3*i],a=t[3*i+1],c=t[3*i+2];o.push([(r?1-s/64:s/64)*n[0]+e.startPoint[0],a/64*n[1]+e.startPoint[1],c])}return{rawCoords:o,iris:o.slice(71)}},t.prototype.getAdjustedIrisCoords=function(t,e,n){var r=t[dn[n+"EyeUpper0"][3]][2],o=t[dn[n+"EyeLower0"][4]][2],i=(r+o)/2;return e.map((function(t,e){var n=i;return 2===e?n=r:4===e&&(n=o),[t[0],t[1],n]}))},t.prototype.predict=function(t,e){return nn(this,void 0,void 0,(function(){var n,i,s,a,u=this;return rn(this,(function(o){switch(o.label){case 0:return this.shouldUpdateRegionsOfInterest()?[4,this.boundingBoxDetector.getBoundingBoxes(t,!1,!0)]:[3,2];case 1:return n=o.sent(),i=n.boxes,s=n.scaleFactor,0===i.length?(this.regionsOfInterest=[],[2,null]):(a=i.map((function(t){var e,n,r={startPoint:t.box.startPoint.squeeze().arraySync(),endPoint:t.box.endPoint.squeeze().arraySync()},o=fn((n=s,{startPoint:[(e=r).startPoint[0]*n[0],e.startPoint[1]*n[1]],endPoint:[e.endPoint[0]*n[0],e.endPoint[1]*n[1]]}));return en({},o,{landmarks:t.landmarks.arraySync()})})),i.forEach((function(t){null!=t&&null!=t.startPoint&&(t.startEndTensor.dispose(),t.startPoint.dispose(),t.endPoint.dispose())})),this.updateRegionsOfInterest(a),this.runsWithoutFaceDetector=0,[3,3]);case 2:this.runsWithoutFaceDetector++,o.label=3;case 3:return[2,Object(r.Ab)((function(){return u.regionsOfInterest.map((function(n,o){var i,s=n.landmarks.length>=468,a=vn[0],c=vn[1];!1===s&&(a=wn[0],c=wn[1]),i=function(t,e){var n;return(n=Math.PI/2-Math.atan2(-(e[1]-t[1]),e[0]-t[0]))-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}(n.landmarks[a],n.landmarks[c]);var l=hn({startPoint:n.startPoint,endPoint:n.endPoint}),d=[l[0]/t.shape[2],l[1]/t.shape[1]],h=t,g=mn;0!==i&&(h=r.eb.rotateWithOffset(t,i,0,d),g=xn(-i,l));var f=function(t,e,n){var o=e.shape[1],c=e.shape[2],i=[[t.startPoint[1]/o,t.startPoint[0]/c,t.endPoint[1]/o,t.endPoint[0]/c]];return r.eb.cropAndResize(e,i,[0],n)}({startPoint:n.startPoint,endPoint:n.endPoint},h,[u.meshHeight,u.meshWidth]).div(255),m=u.meshDetector.predict(f),y=m[1],O=m[2],x=Object(r.ob)(O,[-1,3]).arraySync();if(e){var v=u.getEyeBox(x,f,En[0],En[1],!0),w=v.box,j=v.boxSize,E=v.crop,$=u.getEyeBox(x,f,Cn[0],Cn[1]),C=$.box,N=$.boxSize,R=$.crop,S=u.irisModel.predict(Object(r.W)([E,R])).dataSync(),T=S.slice(0,228),I=u.getEyeCoords(T,w,j,!0),q=I.rawCoords,A=I.iris,k=S.slice(228),D=u.getEyeCoords(k,C,N),_=D.rawCoords,F=D.iris,P=u.getLeftToRightEyeDepthDifference(x);Math.abs(P)<30?(Rn(x,q,"left"),Rn(x,_,"right")):P<1?Rn(x,q,"left",["EyeUpper0","EyeLower0"]):Rn(x,_,"right",["EyeUpper0","EyeLower0"]);var M=u.getAdjustedIrisCoords(x,A,"left"),B=u.getAdjustedIrisCoords(x,F,"right");x=x.concat(M).concat(B)}var L=u.transformRawCoords(x,n,i,g),V=Object(r.zb)(L),z=fn(u.calculateLandmarksBoundingBox(L));return u.regionsOfInterest[o]=en({},z,{landmarks:V.arraySync()}),{coords:Object(r.zb)(x,[x.length,3]),scaledCoords:V,box:z,flag:y.squeeze()}}))}))]}}))}))},t.prototype.updateRegionsOfInterest=function(t){for(var e=0;e<t.length;e++){var n=t[e],r=this.regionsOfInterest[e],o=0;if(r&&r.startPoint){var i=n.startPoint,s=i[0],a=i[1],c=n.endPoint,u=c[0],l=c[1],d=r.startPoint,h=d[0],f=d[1],p=r.endPoint,m=p[0],g=p[1],y=Math.max(s,h),b=Math.max(a,f),O=(Math.min(u,m)-y)*(Math.min(l,g)-b);o=O/((u-s)*(l-a)+(m-h)*(g-a)-O)}o<.25&&(this.regionsOfInterest[e]=n)}this.regionsOfInterest=this.regionsOfInterest.slice(0,t.length)},t.prototype.clearRegionOfInterest=function(t){null!=this.regionsOfInterest[t]&&(this.regionsOfInterest=this.regionsOfInterest.slice(0,t).concat(this.regionsOfInterest.slice(t+1)))},t.prototype.shouldUpdateRegionsOfInterest=function(){var t=this.regionsOfInterest.length,e=0===t;return 1===this.maxFaces||e?e:t!==this.maxFaces&&this.runsWithoutFaceDetector>=this.maxContinuousChecks},t.prototype.calculateLandmarksBoundingBox=function(t){var e=t.map((function(t){return t[0]})),n=t.map((function(t){return t[1]}));return{startPoint:[Math.min.apply(Math,e),Math.min.apply(Math,n)],endPoint:[Math.max.apply(Math,e),Math.max.apply(Math,n)]}},t}(),Tn=[[.499976992607117,.652534008026123],[.500025987625122,.547487020492554],[.499974012374878,.602371990680695],[.482113003730774,.471979022026062],[.500150978565216,.527155995368958],[.499909996986389,.498252987861633],[.499523013830185,.40106201171875],[.289712011814117,.380764007568359],[.499954998493195,.312398016452789],[.499987006187439,.269918978214264],[.500023007392883,.107050001621246],[.500023007392883,.666234016418457],[.5000159740448,.679224014282227],[.500023007392883,.692348003387451],[.499976992607117,.695277988910675],[.499976992607117,.70593398809433],[.499976992607117,.719385027885437],[.499976992607117,.737019002437592],[.499967992305756,.781370997428894],[.499816000461578,.562981009483337],[.473773002624512,.573909997940063],[.104906998574734,.254140973091125],[.365929991006851,.409575998783112],[.338757991790771,.41302502155304],[.311120003461838,.409460008144379],[.274657994508743,.389131009578705],[.393361985683441,.403706014156342],[.345234006643295,.344011008739471],[.370094001293182,.346076011657715],[.319321990013123,.347265005111694],[.297903001308441,.353591024875641],[.24779200553894,.410809993743896],[.396889001131058,.842755019664764],[.280097991228104,.375599980354309],[.106310002505779,.399955987930298],[.2099249958992,.391353011131287],[.355807989835739,.534406006336212],[.471751004457474,.65040397644043],[.474155008792877,.680191993713379],[.439785003662109,.657229006290436],[.414617002010345,.66654098033905],[.450374007225037,.680860996246338],[.428770989179611,.682690978050232],[.374971002340317,.727805018424988],[.486716985702515,.547628998756409],[.485300987958908,.527395009994507],[.257764995098114,.314490020275116],[.401223003864288,.455172002315521],[.429818987846375,.548614978790283],[.421351999044418,.533740997314453],[.276895999908447,.532056987285614],[.483370006084442,.499586999416351],[.33721199631691,.282882988452911],[.296391993761063,.293242990970612],[.169294998049736,.193813979625702],[.447580009698868,.302609980106354],[.392390012741089,.353887975215912],[.354490011930466,.696784019470215],[.067304998636246,.730105042457581],[.442739009857178,.572826027870178],[.457098007202148,.584792017936707],[.381974011659622,.694710969924927],[.392388999462128,.694203019142151],[.277076005935669,.271932005882263],[.422551989555359,.563233017921448],[.385919004678726,.281364023685455],[.383103013038635,.255840003490448],[.331431001424789,.119714021682739],[.229923993349075,.232002973556519],[.364500999450684,.189113974571228],[.229622006416321,.299540996551514],[.173287004232407,.278747975826263],[.472878992557526,.666198015213013],[.446828007698059,.668527007102966],[.422762006521225,.673889994621277],[.445307999849319,.580065965652466],[.388103008270264,.693961024284363],[.403039008378983,.706539988517761],[.403629004955292,.693953037261963],[.460041999816895,.557139039039612],[.431158006191254,.692366003990173],[.452181994915009,.692366003990173],[.475387006998062,.692366003990173],[.465828001499176,.779190003871918],[.472328990697861,.736225962638855],[.473087012767792,.717857003211975],[.473122000694275,.704625964164734],[.473033010959625,.695277988910675],[.427942007780075,.695277988910675],[.426479011774063,.703539967536926],[.423162013292313,.711845993995667],[.4183090031147,.720062971115112],[.390094995498657,.639572978019714],[.013953999616206,.560034036636353],[.499913990497589,.58014702796936],[.413199990987778,.69539999961853],[.409626007080078,.701822996139526],[.468080013990402,.601534962654114],[.422728985548019,.585985004901886],[.463079988956451,.593783974647522],[.37211999297142,.47341400384903],[.334562003612518,.496073007583618],[.411671012639999,.546965003013611],[.242175996303558,.14767599105835],[.290776997804642,.201445996761322],[.327338010072708,.256527006626129],[.399509996175766,.748921036720276],[.441727995872498,.261676013469696],[.429764986038208,.187834024429321],[.412198007106781,.108901023864746],[.288955003023148,.398952007293701],[.218936994671822,.435410976409912],[.41278201341629,.398970007896423],[.257135003805161,.355440020561218],[.427684992551804,.437960982322693],[.448339998722076,.536936044692993],[.178560003638268,.45755398273468],[.247308000922203,.457193970680237],[.286267012357712,.467674970626831],[.332827985286713,.460712015628815],[.368755996227264,.447206974029541],[.398963987827301,.432654976844788],[.476410001516342,.405806005001068],[.189241006970406,.523923993110657],[.228962004184723,.348950982093811],[.490725994110107,.562400996685028],[.404670000076294,.485132992267609],[.019469000399113,.401564002037048],[.426243007183075,.420431017875671],[.396993011236191,.548797011375427],[.266469985246658,.376977026462555],[.439121007919312,.51895797252655],[.032313998788595,.644356966018677],[.419054001569748,.387154996395111],[.462783008813858,.505746960639954],[.238978996872902,.779744982719421],[.198220998048782,.831938028335571],[.107550002634525,.540755033493042],[.183610007166862,.740257024765015],[.134409993886948,.333683013916016],[.385764002799988,.883153975009918],[.490967005491257,.579378008842468],[.382384985685349,.508572995662689],[.174399003386497,.397670984268188],[.318785011768341,.39623498916626],[.343364000320435,.400596976280212],[.396100014448166,.710216999053955],[.187885001301765,.588537991046906],[.430987000465393,.944064974784851],[.318993002176285,.898285031318665],[.266247987747192,.869701027870178],[.500023007392883,.190576016902924],[.499976992607117,.954452991485596],[.366169989109039,.398822009563446],[.393207013607025,.39553701877594],[.410373002290726,.391080021858215],[.194993004202843,.342101991176605],[.388664990663528,.362284004688263],[.365961998701096,.355970978736877],[.343364000320435,.355356991291046],[.318785011768341,.35834002494812],[.301414996385574,.363156020641327],[.058132998645306,.319076001644135],[.301414996385574,.387449026107788],[.499987989664078,.618434011936188],[.415838003158569,.624195992946625],[.445681989192963,.566076993942261],[.465844005346298,.620640993118286],[.49992299079895,.351523995399475],[.288718998432159,.819945991039276],[.335278987884521,.852819979190826],[.440512001514435,.902418971061707],[.128294005990028,.791940987110138],[.408771991729736,.373893976211548],[.455606997013092,.451801002025604],[.499877005815506,.908990025520325],[.375436991453171,.924192011356354],[.11421000212431,.615022003650665],[.448662012815475,.695277988910675],[.4480200111866,.704632043838501],[.447111994028091,.715808033943176],[.444831997156143,.730794012546539],[.430011987686157,.766808986663818],[.406787008047104,.685672998428345],[.400738000869751,.681069016456604],[.392399996519089,.677703022956848],[.367855995893478,.663918972015381],[.247923001646996,.601333022117615],[.452769994735718,.420849978923798],[.43639200925827,.359887003898621],[.416164010763168,.368713974952698],[.413385987281799,.692366003990173],[.228018000721931,.683571994304657],[.468268007040024,.352671027183533],[.411361992359161,.804327011108398],[.499989002943039,.469825029373169],[.479153990745544,.442654013633728],[.499974012374878,.439637005329132],[.432112008333206,.493588984012604],[.499886006116867,.866917014122009],[.49991300702095,.821729004383087],[.456548988819122,.819200992584229],[.344549000263214,.745438992977142],[.37890899181366,.574010014533997],[.374292999505997,.780184984207153],[.319687992334366,.570737957954407],[.357154995203018,.604269981384277],[.295284003019333,.621580958366394],[.447750002145767,.862477004528046],[.410986006259918,.508723020553589],[.31395098567009,.775308012962341],[.354128003120422,.812552988529205],[.324548006057739,.703992962837219],[.189096003770828,.646299958229065],[.279776990413666,.71465802192688],[.1338230073452,.682700991630554],[.336768001317978,.644733011722565],[.429883986711502,.466521978378296],[.455527991056442,.548622965812683],[.437114000320435,.558896005153656],[.467287987470627,.529924988746643],[.414712011814117,.335219979286194],[.37704598903656,.322777986526489],[.344107985496521,.320150971412659],[.312875986099243,.32233202457428],[.283526003360748,.333190023899078],[.241245999932289,.382785975933075],[.102986000478268,.468762993812561],[.267612010240555,.424560010433197],[.297879010438919,.433175981044769],[.333433985710144,.433878004550934],[.366427004337311,.426115989685059],[.396012008190155,.416696012020111],[.420121014118195,.41022801399231],[.007561000064015,.480777025222778],[.432949006557465,.569517970085144],[.458638995885849,.479089021682739],[.473466008901596,.545744001865387],[.476087987422943,.563830018043518],[.468472003936768,.555056989192963],[.433990985155106,.582361996173859],[.483518004417419,.562983989715576],[.482482999563217,.57784903049469],[.42645001411438,.389798998832703],[.438998997211456,.39649498462677],[.450067013502121,.400434017181396],[.289712011814117,.368252992630005],[.276670008897781,.363372981548309],[.517862021923065,.471948027610779],[.710287988185883,.380764007568359],[.526226997375488,.573909997940063],[.895093023777008,.254140973091125],[.634069979190826,.409575998783112],[.661242008209229,.41302502155304],[.688880026340485,.409460008144379],[.725341975688934,.389131009578705],[.606630027294159,.40370500087738],[.654766023159027,.344011008739471],[.629905998706818,.346076011657715],[.680678009986877,.347265005111694],[.702096998691559,.353591024875641],[.75221198797226,.410804986953735],[.602918028831482,.842862963676453],[.719901978969574,.375599980354309],[.893692970275879,.399959981441498],[.790081977844238,.391354024410248],[.643998026847839,.534487962722778],[.528249025344849,.65040397644043],[.525849997997284,.680191040039062],[.560214996337891,.657229006290436],[.585384011268616,.66654098033905],[.549625992774963,.680860996246338],[.57122802734375,.682691991329193],[.624852001667023,.72809898853302],[.513050019741058,.547281980514526],[.51509702205658,.527251958847046],[.742246985435486,.314507007598877],[.598631024360657,.454979002475739],[.570338010787964,.548575043678284],[.578631997108459,.533622980117798],[.723087012767792,.532054007053375],[.516445994377136,.499638974666595],[.662801027297974,.282917976379395],[.70362401008606,.293271005153656],[.830704987049103,.193813979625702],[.552385985851288,.302568018436432],[.607609987258911,.353887975215912],[.645429015159607,.696707010269165],[.932694971561432,.730105042457581],[.557260990142822,.572826027870178],[.542901992797852,.584792017936707],[.6180260181427,.694710969924927],[.607590973377228,.694203019142151],[.722943007946014,.271963000297546],[.577413976192474,.563166975975037],[.614082992076874,.281386971473694],[.616907000541687,.255886018276215],[.668509006500244,.119913995265961],[.770092010498047,.232020974159241],[.635536015033722,.189248979091644],[.77039098739624,.299556016921997],[.826722025871277,.278755009174347],[.527121007442474,.666198015213013],[.553171992301941,.668527007102966],[.577238023281097,.673889994621277],[.554691970348358,.580065965652466],[.611896991729736,.693961024284363],[.59696102142334,.706539988517761],[.596370995044708,.693953037261963],[.539958000183105,.557139039039612],[.568841993808746,.692366003990173],[.547818005084991,.692366003990173],[.52461302280426,.692366003990173],[.534089982509613,.779141008853912],[.527670979499817,.736225962638855],[.526912987232208,.717857003211975],[.526877999305725,.704625964164734],[.526966989040375,.695277988910675],[.572058022022247,.695277988910675],[.573521018028259,.703539967536926],[.57683801651001,.711845993995667],[.581691026687622,.720062971115112],[.609944999217987,.639909982681274],[.986046016216278,.560034036636353],[.5867999792099,.69539999961853],[.590372025966644,.701822996139526],[.531915009021759,.601536989212036],[.577268004417419,.585934996604919],[.536915004253387,.593786001205444],[.627542972564697,.473352015018463],[.665585994720459,.495950996875763],[.588353991508484,.546862006187439],[.757824003696442,.14767599105835],[.709249973297119,.201507985591888],[.672684013843536,.256581008434296],[.600408971309662,.74900496006012],[.55826598405838,.261672019958496],[.570303976535797,.187870979309082],[.588165998458862,.109044015407562],[.711045026779175,.398952007293701],[.781069993972778,.435405015945435],[.587247014045715,.398931980133057],[.742869973182678,.355445981025696],[.572156012058258,.437651991844177],[.55186802148819,.536570012569427],[.821442008018494,.457556009292603],[.752701997756958,.457181990146637],[.71375697851181,.467626988887787],[.66711300611496,.460672974586487],[.631101012229919,.447153985500336],[.6008620262146,.432473003864288],[.523481011390686,.405627012252808],[.810747981071472,.523926019668579],[.771045982837677,.348959028720856],[.509127020835876,.562718033790588],[.595292985439301,.485023975372314],[.980530977249146,.401564002037048],[.573499977588654,.420000016689301],[.602994978427887,.548687994480133],[.733529984951019,.376977026462555],[.560611009597778,.519016981124878],[.967685997486115,.644356966018677],[.580985009670258,.387160003185272],[.537728011608124,.505385041236877],[.760966002941132,.779752969741821],[.801778972148895,.831938028335571],[.892440974712372,.54076099395752],[.816350996494293,.740260004997253],[.865594983100891,.333687007427216],[.614073991775513,.883246004581451],[.508952975273132,.579437971115112],[.617941975593567,.508316040039062],[.825608015060425,.397674977779388],[.681214988231659,.39623498916626],[.656635999679565,.400596976280212],[.603900015354156,.710216999053955],[.81208598613739,.588539004325867],[.56801301240921,.944564998149872],[.681007981300354,.898285031318665],[.733752012252808,.869701027870178],[.633830010890961,.398822009563446],[.606792986392975,.39553701877594],[.589659988880157,.391062021255493],[.805015981197357,.342108011245728],[.611334979534149,.362284004688263],[.634037971496582,.355970978736877],[.656635999679565,.355356991291046],[.681214988231659,.35834002494812],[.698584973812103,.363156020641327],[.941866993904114,.319076001644135],[.698584973812103,.387449026107788],[.584177017211914,.624107003211975],[.554318010807037,.566076993942261],[.534153997898102,.62064003944397],[.711217999458313,.819975018501282],[.664629995822906,.852871000766754],[.559099972248077,.902631998062134],[.871706008911133,.791940987110138],[.591234028339386,.373893976211548],[.544341027736664,.451583981513977],[.624562978744507,.924192011356354],[.88577002286911,.615028977394104],[.551338016986847,.695277988910675],[.551980018615723,.704632043838501],[.552887976169586,.715808033943176],[.555167973041534,.730794012546539],[.569944024085999,.767035007476807],[.593203008174896,.685675978660583],[.599261999130249,.681069016456604],[.607599973678589,.677703022956848],[.631937980651855,.663500010967255],[.752032995223999,.601315021514893],[.547226011753082,.420395016670227],[.563543975353241,.359827995300293],[.583841025829315,.368713974952698],[.586614012718201,.692366003990173],[.771915018558502,.683578014373779],[.531597018241882,.352482974529266],[.588370978832245,.804440975189209],[.52079701423645,.442565023899078],[.567984998226166,.493479013442993],[.543282985687256,.819254994392395],[.655317008495331,.745514988899231],[.621008992195129,.574018001556396],[.625559985637665,.78031200170517],[.680198013782501,.570719003677368],[.64276397228241,.604337990283966],[.704662978649139,.621529996395111],[.552012026309967,.862591981887817],[.589071989059448,.508637011051178],[.685944974422455,.775357007980347],[.645735025405884,.812640011310577],[.675342977046967,.703978002071381],[.810858011245728,.646304965019226],[.72012197971344,.714666962623596],[.866151988506317,.682704985141754],[.663187026977539,.644596993923187],[.570082008838654,.466325998306274],[.544561982154846,.548375964164734],[.562758982181549,.558784961700439],[.531987011432648,.530140042304993],[.585271000862122,.335177004337311],[.622952997684479,.32277899980545],[.655896008014679,.320163011550903],[.687132000923157,.322345972061157],[.716481983661652,.333200991153717],[.758756995201111,.382786989212036],[.897013008594513,.468769013881683],[.732392013072968,.424547016620636],[.70211398601532,.433162987232208],[.66652500629425,.433866024017334],[.633504986763,.426087975502014],[.603875994682312,.416586995124817],[.579657971858978,.409945011138916],[.992439985275269,.480777025222778],[.567192018032074,.569419980049133],[.54136598110199,.478899002075195],[.526564002037048,.546118021011353],[.523913025856018,.563830018043518],[.531529009342194,.555056989192963],[.566035985946655,.582329034805298],[.51631098985672,.563053965568542],[.5174720287323,.577877044677734],[.573594987392426,.389806985855103],[.560697972774506,.395331978797913],[.549755990505219,.399751007556915],[.710287988185883,.368252992630005],[.723330020904541,.363372981548309]];function In(t){return nn(this,void 0,void 0,(function(){var e,n,r,o,i,s,a,c,u,l,d,h,f,p,m;return rn(this,(function(g){switch(g.label){case 0:return e=t.maxContinuousChecks,n=void 0===e?5:e,r=t.detectionConfidence,o=void 0===r?.9:r,i=t.maxFaces,s=void 0===i?10:i,a=t.iouThreshold,c=void 0===a?.3:a,u=t.scoreThreshold,l=void 0===u?.75:u,d=t.shouldLoadIrisModel,h=void 0===d||d,f=t.modelUrl,p=t.irisModelUrl,h?[4,Promise.all([An(s,c,l),kn(f),Dn(p)])]:[3,2];case 1:return m=g.sent(),[3,4];case 2:return[4,Promise.all([An(s,c,l),kn(f)])];case 3:m=g.sent(),g.label=4;case 4:return[2,new Pn(m[0],m[1],n,o,s,h?m[2]:null)]}}))}))}function An(t,e,n){return nn(this,void 0,void 0,(function(){return rn(this,(function(r){return[2,ln({maxFaces:t,iouThreshold:e,scoreThreshold:n})]}))}))}function kn(t){return nn(this,void 0,void 0,(function(){return rn(this,(function(e){return null!=t?[2,tn(t)]:[2,tn("https://tfhub.dev/mediapipe/tfjs-model/facemesh/1/default/1",{fromTFHub:!0})]}))}))}function Dn(t){return nn(this,void 0,void 0,(function(){return rn(this,(function(e){return null!=t?[2,tn(t)]:[2,tn("https://tfhub.dev/mediapipe/tfjs-model/iris/1/default/2",{fromTFHub:!0})]}))}))}function _n(t,e){if(t.mesh instanceof r.M){var i=Object(r.Ab)((function(){var i=Object(r.yb)([e-1,0,0]),s=Object(r.yb)([1,-1,1]);return Object(r.Ab)((function(){return[Object(r.W)([Object(r.vb)(e-1,t.boundingBox.topLeft.slice(0,1)),t.boundingBox.topLeft.slice(1,1)]),Object(r.W)([Object(r.vb)(e-1,t.boundingBox.bottomRight.slice(0,1)),t.boundingBox.bottomRight.slice(1,1)]),Object(r.vb)(i,t.mesh).mul(s),Object(r.vb)(i,t.scaledMesh).mul(s)]}))})),s=i[0],a=i[1],n=i[2],u=i[3];return Object.assign({},t,{boundingBox:{topLeft:s,bottomRight:a},mesh:n,scaledMesh:u})}return Object.assign({},t,{boundingBox:{topLeft:[e-1-t.boundingBox.topLeft[0],t.boundingBox.topLeft[1]],bottomRight:[e-1-t.boundingBox.bottomRight[0],t.boundingBox.bottomRight[1]]},mesh:t.mesh.map((function(t){var n=t.slice(0);return n[0]=e-1-t[0],n})),scaledMesh:t.scaledMesh.map((function(t){var n=t.slice(0);return n[0]=e-1-t[0],n}))})}var Fn,Pn=function(){function t(t,e,n,r,o,i){this.pipeline=new Sn(t,e,192,192,n,o,i),this.detectionConfidence=r}return t.getAnnotations=function(){return dn},t.getUVCoords=function(){return Tn},t.prototype.estimateFaces=function(t){return nn(this,void 0,void 0,(function(){var e,n,i,s,a,o,u,c,l,p,d,b,h=this;return rn(this,(function(f){switch(f.label){case 0:if(e=t.returnTensors,n=void 0!==e&&e,i=t.flipHorizontal,s=void 0!==i&&i,a=t.predictIrises,o=void 0===a||a,u=t.input,o&&null==this.pipeline.irisModel)throw new Error("The iris model was not loaded as part of facemesh. Please initialize the model with facemesh.load({shouldLoadIrisModel: true}).");return c=function(t){return t instanceof r.M?[t.shape[0],t.shape[1]]:[t.height,t.width]}(u),l=c[1],p=Object(r.Ab)((function(){return u instanceof r.M||(u=r.S.fromPixels(u)),u.toFloat().expandDims(0)})),"webgl"!==Object(r.cb)()?[3,2]:(b=Object(r.bb)().get("WEBGL_PACK_DEPTHWISECONV"),Object(r.bb)().set("WEBGL_PACK_DEPTHWISECONV",!0),[4,this.pipeline.predict(p,o)]);case 1:return d=f.sent(),Object(r.bb)().set("WEBGL_PACK_DEPTHWISECONV",b),[3,4];case 2:return[4,this.pipeline.predict(p,o)];case 3:d=f.sent(),f.label=4;case 4:return p.dispose(),null!=d&&d.length>0?[2,Promise.all(d.map((function(t,e){return nn(h,void 0,void 0,(function(){var c,i,a,u,d,h,f,p,m,g,y,b,O,x,v=this;return rn(this,(function(w){switch(w.label){case 0:return c=t.coords,i=t.scaledCoords,a=t.box,u=t.flag,d=[u],n||(d=d.concat([c,i])),[4,Promise.all(d.map((function(t){return nn(v,void 0,void 0,(function(){return rn(this,(function(e){return[2,t.array()]}))}))})))];case 1:if(h=w.sent(),f=h[0],u.dispose(),f<this.detectionConfidence&&this.pipeline.clearRegionOfInterest(e),n)return p={faceInViewConfidence:f,mesh:c,scaledMesh:i,boundingBox:{topLeft:Object(r.yb)(a.startPoint),bottomRight:Object(r.yb)(a.endPoint)}},s?[2,_n(p,l)]:[2,p];for(x in m=h.slice(1),g=m[0],y=m[1],i.dispose(),c.dispose(),b={faceInViewConfidence:f,boundingBox:{topLeft:a.startPoint,bottomRight:a.endPoint},mesh:g,scaledMesh:y},s&&(b=_n(b,l)),O={},dn)(o||!1===x.includes("Iris"))&&(O[x]=dn[x].map((function(t){return b.scaledMesh[t]})));return b.annotations=O,[2,b]}}))}))})))]:[2,[]]}}))}))},t}();!function(){function t(){}t.prototype.estimateFaces=function(t){throw new Error("estimateFaces is not yet implemented.")}}();function Mn(t,e){return void 0===t&&(t=Fn.mediapipeFacemesh),void 0===e&&(e={}),nn(this,void 0,void 0,(function(){return rn(this,(function(n){if(t===Fn.mediapipeFacemesh)return[2,In(e)];throw new Error(t+" is not a valid package name.")}))}))}(Fn||(Fn={})).mediapipeFacemesh="mediapipe-facemesh"},function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(121);var o=n(163),c=n(93);function l(t){return function(t){if(Array.isArray(t))return Object(r.a)(t)}(t)||Object(o.a)(t)||Object(c.a)(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(t,e,n){"use strict";n.d(e,"a",(function(){return m}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(227);var h=n(221);function f(t){return null==t?null:0===t.rank?Object(d.a)(t,[t.size]):1===t.rank?t:2===t.rank?Object(d.a)(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?Object(d.a)(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t}const m=Object(h.a)({batchNorm_:function(t,e,n,h,m,y){null==y&&(y=.001);const O=Object(c.a)(t,"x","batchNorm"),x=Object(c.a)(e,"mean","batchNorm"),v=Object(c.a)(n,"variance","batchNorm");let w,j;null!=m&&(w=Object(c.a)(m,"scale","batchNorm")),null!=h&&(j=Object(c.a)(h,"offset","batchNorm")),l.assert(x.rank===v.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),l.assert(null==j||x.rank===j.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),l.assert(null==w||x.rank===w.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const E=function(t){let e;return e=0===t.rank||1===t.rank?Object(d.a)(t,[1,1,1,t.size]):2===t.rank?Object(d.a)(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?Object(d.a)(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(O),$={x:E,scale:w,offset:j,mean:x,variance:v},C={varianceEpsilon:y},N=r.a.runKernelFunc(((t,e)=>(e([E,x,v,w]),t.batchNorm(E,f(x),f(v),f(j),f(w),y))),$,null,o.eb,C);return Object(d.a)(N,O.shape)}})},,function(t,e,n){"use strict";(function(t,r){let o;function c(){if(null==o){let e;if("undefined"!=typeof window)e=window;else if(void 0!==t)e=t;else if(void 0!==r)e=r;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}o=e}return o}function l(t,e){const n=function(){const t=c();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}n.d(e,"b",(function(){return c})),n.d(e,"a",(function(){return l}))}).call(this,n(33),n(171))},function(t,e,n){"use strict";(function(t){var r=n(516),o=n(517),c=n(518);function l(){return h.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function d(t,e){if(l()<e)throw new RangeError("Invalid typed array length");return h.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(e)).__proto__=h.prototype:(null===t&&(t=new h(e)),t.length=e),t}function h(t,e,n){if(!(h.TYPED_ARRAY_SUPPORT||this instanceof h))return new h(t,e,n);if("number"==typeof t){if("string"==typeof e)throw new Error("If encoding is specified then the first argument must be a string");return y(this,t)}return f(this,t,e,n)}function f(t,e,n,r){if("number"==typeof e)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&e instanceof ArrayBuffer?function(t,e,n,r){if(e.byteLength,n<0||e.byteLength<n)throw new RangeError("'offset' is out of bounds");if(e.byteLength<n+(r||0))throw new RangeError("'length' is out of bounds");e=void 0===n&&void 0===r?new Uint8Array(e):void 0===r?new Uint8Array(e,n):new Uint8Array(e,n,r);h.TYPED_ARRAY_SUPPORT?(t=e).__proto__=h.prototype:t=O(t,e);return t}(t,e,n,r):"string"==typeof e?function(t,e,n){"string"==typeof n&&""!==n||(n="utf8");if(!h.isEncoding(n))throw new TypeError('"encoding" must be a valid string encoding');var r=0|v(e,n),o=(t=d(t,r)).write(e,n);o!==r&&(t=t.slice(0,o));return t}(t,e,n):function(t,e){if(h.isBuffer(e)){var n=0|x(e.length);return 0===(t=d(t,n)).length||e.copy(t,0,0,n),t}if(e){if("undefined"!=typeof ArrayBuffer&&e.buffer instanceof ArrayBuffer||"length"in e)return"number"!=typeof e.length||(r=e.length)!=r?d(t,0):O(t,e);if("Buffer"===e.type&&c(e.data))return O(t,e.data)}var r;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(t,e)}function m(t){if("number"!=typeof t)throw new TypeError('"size" argument must be a number');if(t<0)throw new RangeError('"size" argument must not be negative')}function y(t,e){if(m(e),t=d(t,e<0?0:0|x(e)),!h.TYPED_ARRAY_SUPPORT)for(var i=0;i<e;++i)t[i]=0;return t}function O(t,e){var n=e.length<0?0:0|x(e.length);t=d(t,n);for(var i=0;i<n;i+=1)t[i]=255&e[i];return t}function x(t){if(t>=l())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+l().toString(16)+" bytes");return 0|t}function v(t,e){if(h.isBuffer(t))return t.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;"string"!=typeof t&&(t=""+t);var n=t.length;if(0===n)return 0;for(var r=!1;;)switch(e){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":case void 0:return X(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return Y(t).length;default:if(r)return X(t).length;e=(""+e).toLowerCase(),r=!0}}function w(t,e,n){var r=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(e>>>=0))return"";for(t||(t="utf8");;)switch(t){case"hex":return P(this,e,n);case"utf8":case"utf-8":return k(this,e,n);case"ascii":return _(this,e,n);case"latin1":case"binary":return F(this,e,n);case"base64":return A(this,e,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return M(this,e,n);default:if(r)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),r=!0}}function j(b,t,e){var i=b[t];b[t]=b[e],b[e]=i}function E(t,e,n,r,o){if(0===t.length)return-1;if("string"==typeof n?(r=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),n=+n,isNaN(n)&&(n=o?0:t.length-1),n<0&&(n=t.length+n),n>=t.length){if(o)return-1;n=t.length-1}else if(n<0){if(!o)return-1;n=0}if("string"==typeof e&&(e=h.from(e,r)),h.isBuffer(e))return 0===e.length?-1:$(t,e,n,r,o);if("number"==typeof e)return e&=255,h.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?o?Uint8Array.prototype.indexOf.call(t,e,n):Uint8Array.prototype.lastIndexOf.call(t,e,n):$(t,[e],n,r,o);throw new TypeError("val must be string, number or Buffer")}function $(t,e,n,r,o){var i,c=1,l=t.length,d=e.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(t.length<2||e.length<2)return-1;c=2,l/=2,d/=2,n/=2}function h(t,i){return 1===c?t[i]:t.readUInt16BE(i*c)}if(o){var f=-1;for(i=n;i<l;i++)if(h(t,i)===h(e,-1===f?0:i-f)){if(-1===f&&(f=i),i-f+1===d)return f*c}else-1!==f&&(i-=i-f),f=-1}else for(n+d>l&&(n=l-d),i=n;i>=0;i--){for(var m=!0,y=0;y<d;y++)if(h(t,i+y)!==h(e,y)){m=!1;break}if(m)return i}return-1}function C(t,e,n,r){n=Number(n)||0;var o=t.length-n;r?(r=Number(r))>o&&(r=o):r=o;var c=e.length;if(c%2!=0)throw new TypeError("Invalid hex string");r>c/2&&(r=c/2);for(var i=0;i<r;++i){var l=parseInt(e.substr(2*i,2),16);if(isNaN(l))return i;t[n+i]=l}return i}function N(t,e,n,r){return Q(X(e,t.length-n),t,n,r)}function R(t,e,n,r){return Q(function(t){for(var e=[],i=0;i<t.length;++i)e.push(255&t.charCodeAt(i));return e}(e),t,n,r)}function S(t,e,n,r){return R(t,e,n,r)}function T(t,e,n,r){return Q(Y(e),t,n,r)}function I(t,e,n,r){return Q(function(t,e){for(var n,r,o,c=[],i=0;i<t.length&&!((e-=2)<0);++i)r=(n=t.charCodeAt(i))>>8,o=n%256,c.push(o),c.push(r);return c}(e,t.length-n),t,n,r)}function A(t,e,n){return 0===e&&n===t.length?r.fromByteArray(t):r.fromByteArray(t.slice(e,n))}function k(t,e,n){n=Math.min(t.length,n);for(var r=[],i=e;i<n;){var o,c,l,d,h=t[i],f=null,m=h>239?4:h>223?3:h>191?2:1;if(i+m<=n)switch(m){case 1:h<128&&(f=h);break;case 2:128==(192&(o=t[i+1]))&&(d=(31&h)<<6|63&o)>127&&(f=d);break;case 3:o=t[i+1],c=t[i+2],128==(192&o)&&128==(192&c)&&(d=(15&h)<<12|(63&o)<<6|63&c)>2047&&(d<55296||d>57343)&&(f=d);break;case 4:o=t[i+1],c=t[i+2],l=t[i+3],128==(192&o)&&128==(192&c)&&128==(192&l)&&(d=(15&h)<<18|(63&o)<<12|(63&c)<<6|63&l)>65535&&d<1114112&&(f=d)}null===f?(f=65533,m=1):f>65535&&(f-=65536,r.push(f>>>10&1023|55296),f=56320|1023&f),r.push(f),i+=m}return function(t){var e=t.length;if(e<=D)return String.fromCharCode.apply(String,t);var n="",i=0;for(;i<e;)n+=String.fromCharCode.apply(String,t.slice(i,i+=D));return n}(r)}e.Buffer=h,e.SlowBuffer=function(t){+t!=t&&(t=0);return h.alloc(+t)},e.INSPECT_MAX_BYTES=50,h.TYPED_ARRAY_SUPPORT=void 0!==t.TYPED_ARRAY_SUPPORT?t.TYPED_ARRAY_SUPPORT:function(){try{var t=new Uint8Array(1);return t.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===t.foo()&&"function"==typeof t.subarray&&0===t.subarray(1,1).byteLength}catch(t){return!1}}(),e.kMaxLength=l(),h.poolSize=8192,h._augment=function(t){return t.__proto__=h.prototype,t},h.from=function(t,e,n){return f(null,t,e,n)},h.TYPED_ARRAY_SUPPORT&&(h.prototype.__proto__=Uint8Array.prototype,h.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&h[Symbol.species]===h&&Object.defineProperty(h,Symbol.species,{value:null,configurable:!0})),h.alloc=function(t,e,n){return function(t,e,n,r){return m(e),e<=0?d(t,e):void 0!==n?"string"==typeof r?d(t,e).fill(n,r):d(t,e).fill(n):d(t,e)}(null,t,e,n)},h.allocUnsafe=function(t){return y(null,t)},h.allocUnsafeSlow=function(t){return y(null,t)},h.isBuffer=function(b){return!(null==b||!b._isBuffer)},h.compare=function(a,b){if(!h.isBuffer(a)||!h.isBuffer(b))throw new TypeError("Arguments must be Buffers");if(a===b)return 0;for(var t=a.length,e=b.length,i=0,n=Math.min(t,e);i<n;++i)if(a[i]!==b[i]){t=a[i],e=b[i];break}return t<e?-1:e<t?1:0},h.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},h.concat=function(t,e){if(!c(t))throw new TypeError('"list" argument must be an Array of Buffers');if(0===t.length)return h.alloc(0);var i;if(void 0===e)for(e=0,i=0;i<t.length;++i)e+=t[i].length;var n=h.allocUnsafe(e),r=0;for(i=0;i<t.length;++i){var o=t[i];if(!h.isBuffer(o))throw new TypeError('"list" argument must be an Array of Buffers');o.copy(n,r),r+=o.length}return n},h.byteLength=v,h.prototype._isBuffer=!0,h.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var i=0;i<t;i+=2)j(this,i,i+1);return this},h.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var i=0;i<t;i+=4)j(this,i,i+3),j(this,i+1,i+2);return this},h.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var i=0;i<t;i+=8)j(this,i,i+7),j(this,i+1,i+6),j(this,i+2,i+5),j(this,i+3,i+4);return this},h.prototype.toString=function(){var t=0|this.length;return 0===t?"":0===arguments.length?k(this,0,t):w.apply(this,arguments)},h.prototype.equals=function(b){if(!h.isBuffer(b))throw new TypeError("Argument must be a Buffer");return this===b||0===h.compare(this,b)},h.prototype.inspect=function(){var t="",n=e.INSPECT_MAX_BYTES;return this.length>0&&(t=this.toString("hex",0,n).match(/.{2}/g).join(" "),this.length>n&&(t+=" ... ")),"<Buffer "+t+">"},h.prototype.compare=function(t,e,n,r,o){if(!h.isBuffer(t))throw new TypeError("Argument must be a Buffer");if(void 0===e&&(e=0),void 0===n&&(n=t?t.length:0),void 0===r&&(r=0),void 0===o&&(o=this.length),e<0||n>t.length||r<0||o>this.length)throw new RangeError("out of range index");if(r>=o&&e>=n)return 0;if(r>=o)return-1;if(e>=n)return 1;if(this===t)return 0;for(var c=(o>>>=0)-(r>>>=0),l=(n>>>=0)-(e>>>=0),d=Math.min(c,l),f=this.slice(r,o),m=t.slice(e,n),i=0;i<d;++i)if(f[i]!==m[i]){c=f[i],l=m[i];break}return c<l?-1:l<c?1:0},h.prototype.includes=function(t,e,n){return-1!==this.indexOf(t,e,n)},h.prototype.indexOf=function(t,e,n){return E(this,t,e,n,!0)},h.prototype.lastIndexOf=function(t,e,n){return E(this,t,e,n,!1)},h.prototype.write=function(t,e,n,r){if(void 0===e)r="utf8",n=this.length,e=0;else if(void 0===n&&"string"==typeof e)r=e,n=this.length,e=0;else{if(!isFinite(e))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");e|=0,isFinite(n)?(n|=0,void 0===r&&(r="utf8")):(r=n,n=void 0)}var o=this.length-e;if((void 0===n||n>o)&&(n=o),t.length>0&&(n<0||e<0)||e>this.length)throw new RangeError("Attempt to write outside buffer bounds");r||(r="utf8");for(var c=!1;;)switch(r){case"hex":return C(this,t,e,n);case"utf8":case"utf-8":return N(this,t,e,n);case"ascii":return R(this,t,e,n);case"latin1":case"binary":return S(this,t,e,n);case"base64":return T(this,t,e,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return I(this,t,e,n);default:if(c)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),c=!0}},h.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var D=4096;function _(t,e,n){var r="";n=Math.min(t.length,n);for(var i=e;i<n;++i)r+=String.fromCharCode(127&t[i]);return r}function F(t,e,n){var r="";n=Math.min(t.length,n);for(var i=e;i<n;++i)r+=String.fromCharCode(t[i]);return r}function P(t,e,n){var r=t.length;(!e||e<0)&&(e=0),(!n||n<0||n>r)&&(n=r);for(var o="",i=e;i<n;++i)o+=K(t[i]);return o}function M(t,e,n){for(var r=t.slice(e,n),o="",i=0;i<r.length;i+=2)o+=String.fromCharCode(r[i]+256*r[i+1]);return o}function B(t,e,n){if(t%1!=0||t<0)throw new RangeError("offset is not uint");if(t+e>n)throw new RangeError("Trying to access beyond buffer length")}function L(t,e,n,r,o,c){if(!h.isBuffer(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(e>o||e<c)throw new RangeError('"value" argument is out of bounds');if(n+r>t.length)throw new RangeError("Index out of range")}function V(t,e,n,r){e<0&&(e=65535+e+1);for(var i=0,o=Math.min(t.length-n,2);i<o;++i)t[n+i]=(e&255<<8*(r?i:1-i))>>>8*(r?i:1-i)}function z(t,e,n,r){e<0&&(e=4294967295+e+1);for(var i=0,o=Math.min(t.length-n,4);i<o;++i)t[n+i]=e>>>8*(r?i:3-i)&255}function U(t,e,n,r,o,c){if(n+r>t.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function W(t,e,n,r,c){return c||U(t,0,n,4),o.write(t,e,n,r,23,4),n+4}function G(t,e,n,r,c){return c||U(t,0,n,8),o.write(t,e,n,r,52,8),n+8}h.prototype.slice=function(t,e){var n,r=this.length;if((t=~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),(e=void 0===e?r:~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),e<t&&(e=t),h.TYPED_ARRAY_SUPPORT)(n=this.subarray(t,e)).__proto__=h.prototype;else{var o=e-t;n=new h(o,void 0);for(var i=0;i<o;++i)n[i]=this[i+t]}return n},h.prototype.readUIntLE=function(t,e,n){t|=0,e|=0,n||B(t,e,this.length);for(var r=this[t],o=1,i=0;++i<e&&(o*=256);)r+=this[t+i]*o;return r},h.prototype.readUIntBE=function(t,e,n){t|=0,e|=0,n||B(t,e,this.length);for(var r=this[t+--e],o=1;e>0&&(o*=256);)r+=this[t+--e]*o;return r},h.prototype.readUInt8=function(t,e){return e||B(t,1,this.length),this[t]},h.prototype.readUInt16LE=function(t,e){return e||B(t,2,this.length),this[t]|this[t+1]<<8},h.prototype.readUInt16BE=function(t,e){return e||B(t,2,this.length),this[t]<<8|this[t+1]},h.prototype.readUInt32LE=function(t,e){return e||B(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},h.prototype.readUInt32BE=function(t,e){return e||B(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},h.prototype.readIntLE=function(t,e,n){t|=0,e|=0,n||B(t,e,this.length);for(var r=this[t],o=1,i=0;++i<e&&(o*=256);)r+=this[t+i]*o;return r>=(o*=128)&&(r-=Math.pow(2,8*e)),r},h.prototype.readIntBE=function(t,e,n){t|=0,e|=0,n||B(t,e,this.length);for(var i=e,r=1,o=this[t+--i];i>0&&(r*=256);)o+=this[t+--i]*r;return o>=(r*=128)&&(o-=Math.pow(2,8*e)),o},h.prototype.readInt8=function(t,e){return e||B(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},h.prototype.readInt16LE=function(t,e){e||B(t,2,this.length);var n=this[t]|this[t+1]<<8;return 32768&n?4294901760|n:n},h.prototype.readInt16BE=function(t,e){e||B(t,2,this.length);var n=this[t+1]|this[t]<<8;return 32768&n?4294901760|n:n},h.prototype.readInt32LE=function(t,e){return e||B(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},h.prototype.readInt32BE=function(t,e){return e||B(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},h.prototype.readFloatLE=function(t,e){return e||B(t,4,this.length),o.read(this,t,!0,23,4)},h.prototype.readFloatBE=function(t,e){return e||B(t,4,this.length),o.read(this,t,!1,23,4)},h.prototype.readDoubleLE=function(t,e){return e||B(t,8,this.length),o.read(this,t,!0,52,8)},h.prototype.readDoubleBE=function(t,e){return e||B(t,8,this.length),o.read(this,t,!1,52,8)},h.prototype.writeUIntLE=function(t,e,n,r){(t=+t,e|=0,n|=0,r)||L(this,t,e,n,Math.pow(2,8*n)-1,0);var o=1,i=0;for(this[e]=255&t;++i<n&&(o*=256);)this[e+i]=t/o&255;return e+n},h.prototype.writeUIntBE=function(t,e,n,r){(t=+t,e|=0,n|=0,r)||L(this,t,e,n,Math.pow(2,8*n)-1,0);var i=n-1,o=1;for(this[e+i]=255&t;--i>=0&&(o*=256);)this[e+i]=t/o&255;return e+n},h.prototype.writeUInt8=function(t,e,n){return t=+t,e|=0,n||L(this,t,e,1,255,0),h.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[e]=255&t,e+1},h.prototype.writeUInt16LE=function(t,e,n){return t=+t,e|=0,n||L(this,t,e,2,65535,0),h.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):V(this,t,e,!0),e+2},h.prototype.writeUInt16BE=function(t,e,n){return t=+t,e|=0,n||L(this,t,e,2,65535,0),h.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):V(this,t,e,!1),e+2},h.prototype.writeUInt32LE=function(t,e,n){return t=+t,e|=0,n||L(this,t,e,4,4294967295,0),h.TYPED_ARRAY_SUPPORT?(this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t):z(this,t,e,!0),e+4},h.prototype.writeUInt32BE=function(t,e,n){return t=+t,e|=0,n||L(this,t,e,4,4294967295,0),h.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):z(this,t,e,!1),e+4},h.prototype.writeIntLE=function(t,e,n,r){if(t=+t,e|=0,!r){var o=Math.pow(2,8*n-1);L(this,t,e,n,o-1,-o)}var i=0,c=1,sub=0;for(this[e]=255&t;++i<n&&(c*=256);)t<0&&0===sub&&0!==this[e+i-1]&&(sub=1),this[e+i]=(t/c>>0)-sub&255;return e+n},h.prototype.writeIntBE=function(t,e,n,r){if(t=+t,e|=0,!r){var o=Math.pow(2,8*n-1);L(this,t,e,n,o-1,-o)}var i=n-1,c=1,sub=0;for(this[e+i]=255&t;--i>=0&&(c*=256);)t<0&&0===sub&&0!==this[e+i+1]&&(sub=1),this[e+i]=(t/c>>0)-sub&255;return e+n},h.prototype.writeInt8=function(t,e,n){return t=+t,e|=0,n||L(this,t,e,1,127,-128),h.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),t<0&&(t=255+t+1),this[e]=255&t,e+1},h.prototype.writeInt16LE=function(t,e,n){return t=+t,e|=0,n||L(this,t,e,2,32767,-32768),h.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):V(this,t,e,!0),e+2},h.prototype.writeInt16BE=function(t,e,n){return t=+t,e|=0,n||L(this,t,e,2,32767,-32768),h.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):V(this,t,e,!1),e+2},h.prototype.writeInt32LE=function(t,e,n){return t=+t,e|=0,n||L(this,t,e,4,2147483647,-2147483648),h.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24):z(this,t,e,!0),e+4},h.prototype.writeInt32BE=function(t,e,n){return t=+t,e|=0,n||L(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),h.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):z(this,t,e,!1),e+4},h.prototype.writeFloatLE=function(t,e,n){return W(this,t,e,!0,n)},h.prototype.writeFloatBE=function(t,e,n){return W(this,t,e,!1,n)},h.prototype.writeDoubleLE=function(t,e,n){return G(this,t,e,!0,n)},h.prototype.writeDoubleBE=function(t,e,n){return G(this,t,e,!1,n)},h.prototype.copy=function(t,e,n,r){if(n||(n=0),r||0===r||(r=this.length),e>=t.length&&(e=t.length),e||(e=0),r>0&&r<n&&(r=n),r===n)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("sourceStart out of bounds");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),t.length-e<r-n&&(r=t.length-e+n);var i,o=r-n;if(this===t&&n<e&&e<r)for(i=o-1;i>=0;--i)t[i+e]=this[i+n];else if(o<1e3||!h.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)t[i+e]=this[i+n];else Uint8Array.prototype.set.call(t,this.subarray(n,n+o),e);return o},h.prototype.fill=function(t,e,n,r){if("string"==typeof t){if("string"==typeof e?(r=e,e=0,n=this.length):"string"==typeof n&&(r=n,n=this.length),1===t.length){var code=t.charCodeAt(0);code<256&&(t=code)}if(void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!h.isEncoding(r))throw new TypeError("Unknown encoding: "+r)}else"number"==typeof t&&(t&=255);if(e<0||this.length<e||this.length<n)throw new RangeError("Out of range index");if(n<=e)return this;var i;if(e>>>=0,n=void 0===n?this.length:n>>>0,t||(t=0),"number"==typeof t)for(i=e;i<n;++i)this[i]=t;else{var o=h.isBuffer(t)?t:X(new h(t,r).toString()),c=o.length;for(i=0;i<n-e;++i)this[i+e]=o[i%c]}return this};var H=/[^+\/0-9A-Za-z-_]/g;function K(t){return t<16?"0"+t.toString(16):t.toString(16)}function X(t,e){var n;e=e||1/0;for(var r=t.length,o=null,c=[],i=0;i<r;++i){if((n=t.charCodeAt(i))>55295&&n<57344){if(!o){if(n>56319){(e-=3)>-1&&c.push(239,191,189);continue}if(i+1===r){(e-=3)>-1&&c.push(239,191,189);continue}o=n;continue}if(n<56320){(e-=3)>-1&&c.push(239,191,189),o=n;continue}n=65536+(o-55296<<10|n-56320)}else o&&(e-=3)>-1&&c.push(239,191,189);if(o=null,n<128){if((e-=1)<0)break;c.push(n)}else if(n<2048){if((e-=2)<0)break;c.push(n>>6|192,63&n|128)}else if(n<65536){if((e-=3)<0)break;c.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((e-=4)<0)break;c.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return c}function Y(t){return r.toByteArray(function(t){if((t=function(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")}(t).replace(H,"")).length<2)return"";for(;t.length%4!=0;)t+="=";return t}(t))}function Q(t,e,n,r){for(var i=0;i<r&&!(i+n>=e.length||i>=t.length);++i)e[i+n]=t[i];return i}}).call(this,n(33))},function(t,e,n){"use strict";n.d(e,"a",(function(){return r}));const r={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({softmax_:function(t,e=-1){const n=Object(c.a)(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const l={logits:n},d={dim:e};return r.a.runKernelFunc(((t,r)=>{const o=t.softmax(n,e);return r([o]),o}),l,null,o.uc,d)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221),h=n(227);const f=Object(d.a)({resizeNearestNeighbor_:function(t,e,n=!1){const d=Object(c.a)(t,"images","resizeNearestNeighbor");l.assert(3===d.rank||4===d.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${d.rank}.`)),l.assert(2===e.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`)),l.assert("float32"===d.dtype||"int32"===d.dtype,(()=>"`images` must have `int32` or `float32` as dtype"));let f=d,m=!1;3===d.rank&&(m=!0,f=Object(h.a)(d,[1,d.shape[0],d.shape[1],d.shape[2]]));const[y,O]=e,x={images:f},v={alignCorners:n,size:e},w=r.a.runKernelFunc(((t,e)=>(e([f]),t.resizeNearestNeighbor(f,y,O,n))),x,null,o.gc,v);return m?Object(h.a)(w,[w.shape[1],w.shape[2],w.shape[3]]):w}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221),h=n(227);const f=Object(d.a)({resizeBilinear_:function(t,e,n=!1){const d=Object(c.a)(t,"images","resizeBilinear");l.assert(3===d.rank||4===d.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${d.rank}.`)),l.assert(2===e.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`));let f=d,m=!1;3===d.rank&&(m=!0,f=Object(h.a)(d,[1,d.shape[0],d.shape[1],d.shape[2]]));const[y,O]=e,x={images:f},v={alignCorners:n,size:e},w=r.a.runKernelFunc(((t,e)=>(e([f]),t.resizeBilinear(f,y,O,n))),x,null,o.ec,v);return m?Object(h.a)(w,[w.shape[1],w.shape[2],w.shape[3]]):w}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(221),l=n(227);const d=Object(c.a)({depthwiseConv2dNativeBackpropInput_:function(t,e,filter,n){let c=e,d=!1;3===e.rank&&(d=!0,c=Object(l.a)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const h={dy:c},f=r.a.runKernelFunc((t=>t.depthwiseConv2DDerInput(c,filter,n)),h,null,o.N);return d?Object(l.a)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(221),l=n(227);const d=Object(c.a)({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,c){let d=t;3===t.rank&&(d=Object(l.a)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let h=e;3===h.rank&&(h=Object(l.a)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const f={x:d,dy:h};return r.a.runKernelFunc((t=>t.depthwiseConv2DDerFilter(d,h,c)),f,null,o.M)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({acos_:function(t){const e=Object(c.a)(t,"x","acos"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.acos(e);return n([e]),r}),n,null,o.b)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({acosh_:function(t){const e=Object(c.a)(t,"x","acosh"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.acosh(e);return n([e]),r}),n,null,o.c)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return j})),n.d(e,"b",(function(){return E})),n.d(e,"c",(function(){return $})),n.d(e,"d",(function(){return C})),n.d(e,"e",(function(){return N})),n.d(e,"f",(function(){return R})),n.d(e,"g",(function(){return S})),n.d(e,"h",(function(){return T})),n.d(e,"i",(function(){return I}));var r=n(273),o=n(222),c=n(225),l=n(245),d=n(235),h=n(298),f=n(320),m=n(351),y=n(229),O=n(221),x=n(281),v=n(321),w=n(233);const j=Object(O.a)({addStrict_:function(a,b){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const t=Object(o.a)(a,"a","addStrict"),e=Object(o.a)(b,"b","addStrict");return c.assertShapesMatch(t.shape,e.shape,"Error in addStrict: "),Object(l.a)(t,e)}}),E=Object(O.a)({divStrict_:function(a,b){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const t=Object(o.a)(a,"a","div"),e=Object(o.a)(b,"b","div");return c.assertShapesMatch(t.shape,e.shape,"Error in divideStrict: "),Object(d.a)(t,e)}}),$=Object(O.a)({maximumStrict_:function(a,b){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const t=Object(o.a)(a,"a","maximumStrict"),e=Object(o.a)(b,"b","maximumStrict");return c.assertShapesMatch(t.shape,e.shape,"Error in maximumStrict: "),Object(h.a)(t,e)}}),C=Object(O.a)({minimumStrict_:function(a,b){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const t=Object(o.a)(a,"a","minimumStrict"),e=Object(o.a)(b,"b","minimumStrict");return c.assertShapesMatch(t.shape,e.shape,"Error in minimumStrict: "),Object(f.a)(t,e)}}),N=Object(O.a)({modStrict_:function(a,b){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const t=Object(o.a)(a,"a","modStrict"),e=Object(o.a)(b,"b","modStrict");return c.assertShapesMatch(t.shape,e.shape,"Error in modStrict: "),Object(m.a)(t,e)}}),R=Object(O.a)({mulStrict_:function(a,b){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const t=Object(o.a)(a,"a","mul"),e=Object(o.a)(b,"b","mul");return c.assertShapesMatch(t.shape,e.shape,"Error in multiplyStrict: "),Object(y.a)(t,e)}}),S=Object(O.a)({powStrict_:function(base,t){return Object(r.a)("strict variants of ops have been deprecated and will be removed in future"),c.assertShapesMatch(base.shape,t.shape,"Error in powStrict: "),Object(x.a)(base,t)}}),T=Object(O.a)({squaredDifferenceStrict_:function(a,b){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const t=Object(o.a)(a,"a","squaredDifferenceStrict"),e=Object(o.a)(b,"b","squaredDifferenceStrict");return c.assertShapesMatch(t.shape,e.shape,"Error in squaredDifferenceStrict: "),Object(v.a)(t,e)}}),I=Object(O.a)({subStrict_:function(a,b){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const t=Object(o.a)(a,"a","subStrict"),e=Object(o.a)(b,"b","subStrict");return c.assertShapesMatch(t.shape,e.shape,"Error in subStrict: "),Object(w.a)(t,e)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({asin_:function(t){const e=Object(c.a)(t,"x","asin"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.asin(e);return n([e]),r}),n,null,o.j)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({asinh_:function(t){const e=Object(c.a)(t,"x","asinh"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.asinh(e);return n([e]),r}),n,null,o.k)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({atan_:function(t){const e=Object(c.a)(t,"x","atan"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.atan(e);return n([e]),r}),n,null,o.l)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({atanh_:function(t){const e=Object(c.a)(t,"x","atanh"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.atanh(e);return n([e]),r}),n,null,o.n)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({ceil_:function(t){const e=Object(c.a)(t,"x","ceil"),n={x:e};return r.a.runKernelFunc((t=>t.ceil(e)),n,null,o.w)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221);const h=Object(d.a)({clipByValue_:function(t,e,n){const d=Object(c.a)(t,"x","clipByValue");l.assert(e<=n,(()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`));const h={x:d},f={clipValueMin:e,clipValueMax:n};return r.a.runKernelFunc(((t,r)=>{const o=t.clip(d,e,n);return r([d]),o}),h,null,o.x,f)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return x})),n.d(e,"b",(function(){return v})),n.d(e,"c",(function(){return w})),n.d(e,"d",(function(){return j})),n.d(e,"e",(function(){return E})),n.d(e,"f",(function(){return $}));var r=n(273),o=n(222),c=n(225),l=n(297),d=n(264),h=n(271),f=n(324),m=n(270),y=n(319),O=n(221);const x=Object(O.a)({equalStrict_:function(a,b){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const t=Object(o.a)(a,"a","equalStrict"),e=Object(o.a)(b,"b","equalStrict");return Object(c.assertShapesMatch)(t.shape,e.shape,"Error in equalStrict: "),Object(l.a)(t,e)}}),v=Object(O.a)({greaterEqualStrict_:function(a,b){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const t=Object(o.a)(a,"a","greaterEqualStrict"),e=Object(o.a)(b,"b","greaterEqualStrict");return Object(c.assertShapesMatch)(t.shape,e.shape,"Error in greaterEqualStrict: "),Object(h.a)(t,e)}}),w=Object(O.a)({greaterStrict_:function(a,b){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const t=Object(o.a)(a,"a","greaterStrict"),e=Object(o.a)(b,"b","greaterStrict");return Object(c.assertShapesMatch)(t.shape,e.shape,"Error in greaterStrict: "),Object(d.a)(t,e)}}),j=Object(O.a)({lessEqualStrict_:function(a,b){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const t=Object(o.a)(a,"a","lessEqualStrict"),e=Object(o.a)(b,"b","lessEqualStrict");return Object(c.assertShapesMatch)(t.shape,e.shape,"Error in lessEqualStrict: "),Object(m.a)(t,e)}}),E=Object(O.a)({lessStrict_:function(a,b){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const t=Object(o.a)(a,"a","lessStrict"),e=Object(o.a)(b,"b","lessStrict");return Object(c.assertShapesMatch)(t.shape,e.shape,"Error in lessStrict: "),Object(f.a)(t,e)}}),$=Object(O.a)({notEqualStrict_:function(a,b){Object(r.a)("strict variants of ops have been deprecated and will be removed in future");const t=Object(o.a)(a,"a","notEqualStrict"),e=Object(o.a)(b,"b","notEqualStrict");return Object(c.assertShapesMatch)(t.shape,e.shape,"Error in notEqualStrict: "),Object(y.a)(t,e)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(230),h=n(221);const f=Object(h.a)({erf_:function(t){let e=Object(c.a)(t,"x","erf");l.assert("int32"===e.dtype||"float32"===e.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===e.dtype&&(e=Object(d.a)(e,"float32"));const n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.erf(e);return n([e]),r}),n,null,o.V)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({expm1_:function(t){const e=Object(c.a)(t,"x","expm1"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.expm1(e);return n([e]),r}),n,null,o.X)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({isFinite_:function(t){const e=Object(c.a)(t,"x","isFinite"),n={x:e};return r.a.runKernelFunc((t=>t.isFinite(e)),n,null,o.ob)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({isInf_:function(t){const e=Object(c.a)(t,"x","isInf"),n={x:e};return r.a.runKernelFunc((t=>t.isInf(e)),n,null,o.pb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({isNaN_:function(t){const e=Object(c.a)(t,"x","isNaN"),n={x:e};return r.a.runKernelFunc((t=>t.isNaN(e)),n,null,o.qb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return m}));var r=n(253),o=n(222),c=n(229),l=n(246),d=n(221),h=n(333),f=n(397);const m=Object(d.a)({logSigmoid_:function(t){const e=Object(o.a)(t,"x","logSigmoid"),n=Object(r.a)((t=>({value:Object(l.a)(Object(f.a)(Object(l.a)(t))),gradFunc:e=>Object(c.a)(e,Object(h.a)(Object(l.a)(t)))})));return n(e)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return x}));var r=n(224),o=n(220),c=n(222),l=n(230),d=n(263),h=n(294),f=n(287),m=n(221),y=n(233),O=n(236);const x=Object(m.a)({logSoftmax_:function(t,e=-1){const n=Object(c.a)(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);const m={logits:n},x={axis:e};return r.a.runKernelFunc(((n,r)=>{const o=Object(f.a)(t,e,!0),c=Object(y.a)(t,o),m=Object(y.a)(Object(l.a)(c,"float32"),Object(h.a)(Object(O.a)(Object(d.a)(c),e,!0)));return r([m]),m}),m,null,o.yb,x)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return y}));var r=n(224),o=n(220),c=n(222),l=n(267),d=n(314),h=n(221),f=n(315),m=n(238);const y=Object(h.a)({onesLike_:function(t){const e=Object(c.a)(t,"x","onesLike"),n={x:e};return r.a.runKernelFunc(((t,n)=>{if("complex64"===e.dtype){const t=y(Object(f.a)(e)),i=Object(m.a)(Object(d.a)(e));return Object(l.a)(t,i)}return t.onesLike(e)}),n,null,o.Tb)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({reciprocal_:function(t){const e=Object(c.a)(t,"x","reciprocal"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.reciprocal(e);return n([e]),r}),n,null,o.ac)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({round_:function(t){const e=Object(c.a)(t,"x","round"),n={x:e};return r.a.runKernelFunc((t=>t.round(e)),n,null,o.kc)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({sign_:function(t){const e=Object(c.a)(t,"x","sign"),n={x:e};return r.a.runKernelFunc((t=>t.sign(e)),n,null,o.qc)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return m}));var r=n(224),o=n(220),c=n(222),l=n(221),d=n(227),h=n(259),f=n(278);const m=Object(l.a)({stridedSlice_:function(t,e,n,l,m=0,y=0,O=0,x=0,v=0){let w=Object(c.a)(t,"x","stridedSlice");const j={x:w},E={begin:e,end:n,strides:l,beginMask:m,endMask:y,ellipsisMask:O,newAxisMask:x,shrinkAxisMask:v};return r.a.runKernelFunc((t=>{null==l&&(l=new Array(e.length));const r=Object(f.maskToAxes)(O);if(r.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==O&&0!==x)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==O&&0!==v)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const o=w.rank-e.length,c=Object(f.maskToAxes)(x),j=w.shape.slice();c.forEach((t=>{e[t]=0,n[t]=1,j.splice(t,0,1)})),w=Object(d.a)(w,j);const{begin:E,end:$,strides:C}=Object(f.getNormalizedAxes)(w.shape,r,o,e,n,l,m,y,O);e=E,n=$,l=C;const N=Object(f.maskToAxes)(v);N.forEach((t=>{n[t]=e[t]+1,l[t]=1}));const R=Object(f.computeOutShape)(e,n,l),S=R.filter(((t,e)=>-1===N.indexOf(e)));if(l.every((t=>1===t)))return Object(d.a)(Object(h.a)(w,e,R),S);const T=t.stridedSlice(w,e,n,l);return Object(d.a)(T,S)}),j,null,o.Dc,E)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({tan_:function(t){const e=Object(c.a)(t,"x","tan"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.tan(e);return n([e]),r}),n,null,o.Gc)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({tanh_:function(t){const e=Object(c.a)(t,"x","tanh"),n={x:e};return r.a.runKernelFunc(((t,n)=>{const r=t.tanh(e);return n([r]),r}),n,null,o.Hc)}})},function(t,e,n){"use strict";(function(t){n.d(e,"a",(function(){return T})),n.d(e,"i",(function(){return A})),n.d(e,"c",(function(){return k})),n.d(e,"f",(function(){return D})),n.d(e,"e",(function(){return P})),n.d(e,"d",(function(){return M})),n.d(e,"k",(function(){return L})),n.d(e,"g",(function(){return V})),n.d(e,"h",(function(){return z})),n.d(e,"j",(function(){return U})),n.d(e,"b",(function(){return W}));var r=n(226),o=n(520),c=n(327),l=n(240),d=n(521),h=n(522),f=n(523),m=n(524),y=n(525),O=n(526),x=n(527),v=n(528),w=n(529),j=n(530),E=n(531),$=n(532),C=n(533),N=n(534),R=n(535),S=n(536);class T{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[].concat(...[d,h,f,m,y,O,x,j,w,v,E,$,C,N,R,S].map((t=>t.json)));this.opMappers=t.reduce(((map,t)=>(map[t.tfOpName]=t,map)),{})}transformGraph(t,e={}){const n=t.node,r=[],o=[],c=[],d=n.reduce(((map,t)=>(map[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(map[t.name]):"Const"===t.op?o.push(map[t.name]):null!=t.input&&0!==t.input.length||c.push(map[t.name]),map)),{});let h=[];const f=[];let m={},y={};null!=e&&(m=this.mapSignatureEntries(e.inputs),y=this.mapSignatureEntries(e.outputs));const O=Object.keys(d);O.forEach((t=>{const e=d[t];e.inputNames.forEach((t=>{const[n]=Object(l.b)(t);e.inputs.push(d[n]),d[n].children.push(e)}))})),0===Object.keys(y).length?O.forEach((t=>{const e=d[t];0===e.children.length&&f.push(e)})):Object.keys(y).forEach((t=>{const[e]=Object(l.b)(t),n=d[e];null!=n&&(n.signatureKey=y[t],f.push(n))})),Object.keys(m).length>0?Object.keys(m).forEach((t=>{const[e]=Object(l.b)(t),n=d[e];n&&(n.signatureKey=m[t],h.push(n))})):h=r;let x={};null!=t.library&&null!=t.library.function&&(x=t.library.function.reduce(((t,e)=>(t[e.signature.name]=this.mapFunction(e),t)),{}));const v={nodes:d,inputs:h,outputs:f,weights:o,placeholders:r,signature:e,functions:x};return c.length>0&&(v.initNodes=c),v}mapSignatureEntries(t){return Object.keys(t||{}).reduce(((e,n)=>(e[t[n].name]=n,e)),{})}mapNode(t){const e=Object(c.a)(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const n={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map((input=>input.startsWith("^")?input.substr(1):input)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr};return null!=e.inputs&&(n.inputParams=e.inputs.reduce(((map,param)=>(map[param.name]={type:param.type,inputIndexStart:param.start,inputIndexEnd:param.end},map)),{})),null!=e.attrs&&(n.attrParams=e.attrs.reduce(((map,param)=>{const e=param.type;let n;switch(param.type){case"string":n=A(t.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=A(t.attr,param.tfDeprecatedName,param.defaultValue));break;case"string[]":n=z(t.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=z(t.attr,param.tfDeprecatedName,param.defaultValue));break;case"number":n=D(t.attr,param.tfName,param.defaultValue||0),void 0===n&&param.tfDeprecatedName&&(n=D(t.attr,param.tfDeprecatedName,param.defaultValue));break;case"number[]":n=V(t.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=V(t.attr,param.tfDeprecatedName,param.defaultValue));break;case"bool":n=k(t.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=k(t.attr,param.tfDeprecatedName,param.defaultValue));break;case"bool[]":n=W(t.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=W(t.attr,param.tfDeprecatedName,param.defaultValue));break;case"shape":n=L(t.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=L(t.attr,param.tfDeprecatedName,param.defaultValue));break;case"shape[]":n=U(t.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=U(t.attr,param.tfDeprecatedName,param.defaultValue));break;case"dtype":n=P(t.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=P(t.attr,param.tfDeprecatedName,param.defaultValue));break;case"dtype[]":n=M(t.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=M(t.attr,param.tfDeprecatedName,param.defaultValue));break;case"func":n=F(t.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=F(t.attr,param.tfDeprecatedName,param.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${param.type} for op: ${t.op}`)}return map[param.name]={value:n,type:e},map}),{})),n}mapFunction(t){const e=t.nodeDef,n=[];let r={};null!=e&&(r=e.reduce(((map,t)=>(map[t.name]=this.mapNode(t),"Const"===t.op&&n.push(map[t.name]),map)),{}));const o=[],c=[];t.signature.inputArg.forEach((t=>{const[e]=Object(l.b)(t.name),n={name:e,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:_(t.type),type:"dtype"}},children:[]};n.signatureKey=t.name,o.push(n),r[e]=n}));Object.keys(r).forEach((t=>{const e=r[t];e.inputNames.forEach((t=>{const[n]=Object(l.b)(t);e.inputs.push(r[n]),r[n].children.push(e)}))}));const d=t.ret;t.signature.outputArg.forEach((output=>{const[t,e]=Object(l.b)(d[output.name]),n=r[t];null!=n&&(n.defaultOutput=e,c.push(n))}));const h=this.mapArgsToSignature(t);return{nodes:r,inputs:o,outputs:c,weights:n,placeholders:[],signature:h}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce(((map,t)=>(map[t.name]=this.mapArgToTensorInfo(t),map)),{}),outputs:t.signature.outputArg.reduce(((map,e)=>(map[e.name]=this.mapArgToTensorInfo(e,t.ret),map)),{})}}mapArgToTensorInfo(t,e){let n=t.name;return null!=e&&(n=e[n]),{name:n,dtype:t.type}}}function I(s,e){const n=Array.isArray(s)?String.fromCharCode.apply(null,s):function(text){const e=Object(r.bb)().global;if(void 0!==e.atob)return e.atob(text);if(void 0!==t)return new t(text,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(s);return e?n:n.toLowerCase()}function A(t,e,n,r=!1){const param=t[e];return null!=param?I(param.s,r):n}function k(t,e,n){const param=t[e];return param?param.b:n}function D(t,e,n){const param=t[e]||{},r=null!=param.i?param.i:null!=param.f?param.f:n;return"number"==typeof r?r:parseInt(r,10)}function _(t){switch("string"==typeof t&&(t=o.a[t]),t){case o.a.DT_FLOAT:return"float32";case o.a.DT_INT32:case o.a.DT_INT64:case o.a.DT_INT8:case o.a.DT_UINT8:return"int32";case o.a.DT_BOOL:return"bool";case o.a.DT_DOUBLE:return"float32";case o.a.DT_STRING:return"string";default:return null}}function F(t,e,n){const param=t[e];return param&&param.func?param.func.name:n}function P(t,e,n){const param=t[e];return param&&param.type?_(param.type):n}function M(t,e,n){const param=t[e];return param&&param.list&&param.list.type?param.list.type.map((t=>_(t))):n}function B(t){if(!t.unknownRank)return null!=t.dim?t.dim.map((t=>"number"==typeof t.size?t.size:parseInt(t.size,10))):[]}function L(t,e,n){const param=t[e];return param&&param.shape?B(param.shape):n}function V(t,e,n){const param=t[e];return param?((param.list.f&&param.list.f.length?param.list.f:param.list.i)||[]).map((t=>"number"==typeof t?t:parseInt(t,10))):n}function z(t,e,n,r=!1){const param=t[e];return param&&param.list&&param.list.s?param.list.s.map((t=>I(t,r))):n}function U(t,e,n){const param=t[e];return param&&param.list&&param.list.shape?param.list.shape.map((t=>B(t))):n}function W(t,e,n){const param=t[e];return param&&param.list&&param.list.b?param.list.b:n}}).call(this,n(414).Buffer)},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(221);const h=Object(d.a)({addN_:function(t){l.assert(Array.isArray(t),(()=>"The argument passed to tf.addN() must be a list of tensors")),l.assert(t.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`));const e=t.map(((t,i)=>Object(c.a)(t,`tensors${i}`,"addN"))),n=e[0];e.forEach((t=>{if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),e.forEach((t=>{if(!l.arraysEqual(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const d=e;return r.a.runKernelFunc(((t,n)=>{const r=t.addN(e);return n(e),r}),d,null,o.e)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return m}));var r=n(224),o=n(220),c=n(222),l=n(225),d=n(237),h=n(221),f=n(227);const m=Object(h.a)({conv3d_:function(t,filter,e,n,h="NDHWC",m=[1,1,1]){const y=Object(c.a)(t,"x","conv3d"),O=Object(c.a)(filter,"filter","conv3d");let x=y,v=!1;4===y.rank&&(v=!0,x=Object(f.a)(y,[1,y.shape[0],y.shape[1],y.shape[2],y.shape[3]])),l.assert(5===x.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${x.rank}.`)),l.assert(5===O.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${O.rank}.`)),l.assert(x.shape[4]===O.shape[3],(()=>`Error in conv3d: depth of input (${x.shape[4]}) must match input depth for filter ${O.shape[3]}.`)),l.assert(Object(d.h)(e,m),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${m}'`)),l.assert("NDHWC"===h,(()=>`Error in conv3d: got dataFormat of ${h} but only NDHWC is currently supported.`));const w={x:x,filter:O},j={strides:e,pad:n,dataFormat:h,dilations:m},E=r.a.runKernelFunc(((t,r)=>{const o=d.b(x.shape,O.shape,e,m,n),c=t.conv3d(x,O,o);return r([x,O]),c}),w,null,o.D,j);return v?Object(f.a)(E,[E.shape[1],E.shape[2],E.shape[3],E.shape[4]]):E}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({maxPoolWithArgmax_:function(t,e,n,l,d=!1){const h={x:Object(c.a)(t,"x","maxPoolWithArgmax")},f={filterSize:e,strides:n,pad:l,includeBatchInIndex:d},m=r.a.runKernel(o.Hb,h,f);return{result:m[0],indexes:m[1]}}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return O}));var r=n(224),o=n(273),c=n(220),l=n(222),d=n(225),h=n(230),f=n(237),m=n(221),y=n(227);const O=Object(m.a)({avgPool3d_:function(t,e,n,m,O,x="NDHWC",v){null==v?v=[1,1,1]:Object(o.a)("dilations is deprecated, this field will be gone in v3.0.0.");const w=Object(l.a)(t,"x","avgPool3d","float32");let j=w,E=!1;4===w.rank&&(E=!0,j=Object(y.a)(w,[1,w.shape[0],w.shape[1],w.shape[2],w.shape[3]])),d.assert(5===j.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${j.rank}.`)),d.assert("NDHWC"===x,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${x}`)),d.assert(f.h(n,v),(()=>`Error in avgPool3d: Either strides or dilations must be 1. Got strides ${n} and dilations '${v}'`)),null!=O&&d.assert(d.isInt(m),(()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${O} but got pad ${m}.`));const $={x:j},C={filterSize:e,strides:n,pad:m,dimRoundingMode:O,dataFormat:x,dilations:v};let N=r.a.runKernelFunc(((t,r)=>{null==v&&(v=[1,1,1]);const o=f.f(j.shape,e,n,v,m,O,x);return r([j]),t.avgPool3d(j,o)}),$,null,c.p,C);return N=Object(h.a)(N,j.dtype),E?Object(y.a)(N,[N.shape[1],N.shape[2],N.shape[3],N.shape[4]]):N}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return y}));var r=n(224),o=n(273),c=n(220),l=n(222),d=n(225),h=n(237),f=n(221),m=n(227);const y=Object(f.a)({maxPool3d_:function(t,e=[1,1,1],n,f,y,O="NDHWC",x){null==x?x=[1,1,1]:Object(o.a)("dilations is deprecated, this field will be gone in v3.0.0.");const v=Object(l.a)(t,"x","maxPool3d");let w=v,j=!1;4===v.rank&&(j=!0,w=Object(m.a)(v,[1,v.shape[0],v.shape[1],v.shape[2],v.shape[3]])),d.assert(5===w.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${w.rank}.`)),d.assert("NDHWC"===O,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${O}`)),d.assert(h.h(n,x),(()=>`Error in maxPool3d: Either strides or dilations must be 1. Got strides ${n} and dilations '${x}'`)),null!=y&&d.assert(d.isInt(f),(()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${y} but got pad ${f}.`));const E={x:w},$={filterSize:e,strides:n,pad:f,dimRoundingMode:y,dataFormat:O,dilations:x},C=r.a.runKernelFunc(((t,r)=>{null==x&&(x=[1,1,1]);const o=h.f(w.shape,e,n,x,f,y,O),c=t.maxPool3d(w,o);return r([w,c]),c}),E,null,c.Eb,$);return j?Object(m.a)(C,[C.shape[1],C.shape[2],C.shape[3],C.shape[4]]):C}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(224),o=n(220);function c(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const c={start:t,stop:e,num:n};return r.a.runKernelFunc((r=>r.linspace(t,e,n)),{},null,o.vb,c)}},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(222),c=n(221),l=n(227);const d=Object(c.a)({multinomial_:function(t,e,n,c=!1){const d=Object(o.a)(t,"logits","multinomial"),h=d.size,f=d.rank;if(h<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${h}.`);if(f>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${f}`);n=n||Math.random();const m=1===f?Object(l.a)(d,[1,-1]):d,y=r.a.runKernelFunc((t=>t.multinomial(m,c,e,n)),{logits2D:m});return 1===f?Object(l.a)(y,[y.size]):y}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(268),o=n(221),c=n(454);const l=Object(o.a)({randomUniform_:function(t,e=0,n=1,o="float32",l){const d=Object(r.a)(t,o),h=new c.b(e,n,null,l);for(let i=0;i<d.values.length;i++)d.values[i]=h.nextValue();return d.toTensor()}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return o})),n.d(e,"b",(function(){return c}));var r=n(537);n(407);class o{constructor(t,e,n,o,c){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const l=c||Math.random();this.random=r.alea(l.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,o,s;do{r=2*this.random()-1,o=2*this.random()-1,s=r*r+o*o}while(s>=1||0===s);const c=Math.sqrt(-2*Math.log(s)/s);t=this.mean+this.stdDev*r*c,e=this.mean+this.stdDev*o*c,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class c{constructor(t=0,e=1,n,o){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==o&&(o=Math.random()),"number"==typeof o&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=r.alea(o)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}},function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(268),o=n(221),c=n(454);const l=Object(o.a)({truncatedNormal_:function(t,e=0,n=1,o,l){if(null!=o&&"bool"===o)throw new Error("Unsupported data type $ { dtype }");const d=new c.a(e,n,o,!0,l),h=Object(r.a)(t,o);for(let i=0;i<h.values.length;i++)h.values[i]=d.nextValue();return h.toTensor()}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return c}));var r=n(378),o=n(222);const c=async function(t){const e=Object(o.a)(t,"condition","whereAsync","bool"),n=await e.data(),c=Object(r.a)(e.shape,n);return t!==e&&e.dispose(),c}},function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var r=n(223),o=n(222),c=n(225);const l=async function(t,e){const n=Object(o.a)(t,"x","setdiff1d"),l=Object(o.a)(e,"y","setdiff1d");c.assert(n.dtype===l.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${l.dtype}).`)),c.assert(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),c.assert(1===l.rank,(()=>`y should be 1D tensor, but got y (${l.shape}).`));const d=await n.data(),h=await l.data(),f=new Set(h);let m=0;for(let i=0;i<d.length;i++)f.has(d[i])||m++;const y=new r.b([m],n.dtype),O=new r.b([m],"int32");for(let i=0,p=0;i<d.length;i++)f.has(d[i])||(y.values[p]=d[i],O.values[p]=i,p++);return[y.toTensor(),O.toTensor()]}},function(t,e,n){"use strict";n.d(e,"a",(function(){return h}));var r=n(224),o=n(220),c=n(222),l=n(221),d=n(322);const h=Object(l.a)({scatterND_:function(t,e,n){const l=Object(c.a)(t,"indices","scatterND","int32"),h=Object(c.a)(e,"updates","scatterND");d.b(h,l,n);const f={indices:l,updates:h},m={shape:n};return r.a.runKernelFunc((t=>t.scatterND(l,h,n)),f,null,o.mc,m)}})},function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220),c=n(222),l=n(221);const d=Object(l.a)({gatherND_:function(t,e){const n=Object(c.a)(e,"indices","gatherND","int32"),l=Object(c.a)(t,"x","gatherND"),d={params:l,indices:n};return r.a.runKernelFunc((t=>t.gatherND(l,n)),d,null,o.hb)}})},,,,,function(t,e,n){"use strict";n.d(e,"a",(function(){return d}));var r=n(224),o=n(220);var c=n(222),l=n(221);const d=Object(l.a)({sparseToDense_:function(t,e,n,l=0){const d=Object(c.a)(t,"sparseIndices","sparseToDense","int32"),h=Object(c.a)(e,"sparseValues","sparseToDense"),f=Object(c.a)(l,"defaultValue","sparseToDense",h.dtype);!function(t,e,n,r){if("int32"!==t.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const o=t.rank>0?t.shape[0]:1,c=t.rank>1?t.shape[1]:1;if(n.length!==c)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${c}.`);const l=e.size;if(0!==e.rank&&(1!==e.rank||l!==o))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${o}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(d,h,n,f);const m={sparseIndices:d,sparseValues:h,defaultValue:f},y={outputShape:n};return r.a.runKernelFunc((t=>t.sparseToDense(d,h,n,f)),m,null,o.xc,y)}})},,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,function(t,e,n){"use strict";e.byteLength=function(t){var e=d(t),n=e[0],r=e[1];return 3*(n+r)/4-r},e.toByteArray=function(t){var e,i,n=d(t),r=n[0],l=n[1],h=new c(function(t,e,n){return 3*(e+n)/4-n}(0,r,l)),f=0,m=l>0?r-4:r;for(i=0;i<m;i+=4)e=o[t.charCodeAt(i)]<<18|o[t.charCodeAt(i+1)]<<12|o[t.charCodeAt(i+2)]<<6|o[t.charCodeAt(i+3)],h[f++]=e>>16&255,h[f++]=e>>8&255,h[f++]=255&e;2===l&&(e=o[t.charCodeAt(i)]<<2|o[t.charCodeAt(i+1)]>>4,h[f++]=255&e);1===l&&(e=o[t.charCodeAt(i)]<<10|o[t.charCodeAt(i+1)]<<4|o[t.charCodeAt(i+2)]>>2,h[f++]=e>>8&255,h[f++]=255&e);return h},e.fromByteArray=function(t){for(var e,n=t.length,o=n%3,c=[],l=16383,i=0,d=n-o;i<d;i+=l)c.push(h(t,i,i+l>d?d:i+l));1===o?(e=t[n-1],c.push(r[e>>2]+r[e<<4&63]+"==")):2===o&&(e=(t[n-2]<<8)+t[n-1],c.push(r[e>>10]+r[e>>4&63]+r[e<<2&63]+"="));return c.join("")};for(var r=[],o=[],c="undefined"!=typeof Uint8Array?Uint8Array:Array,code="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0,l=code.length;i<l;++i)r[i]=code[i],o[code.charCodeAt(i)]=i;function d(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var n=t.indexOf("=");return-1===n&&(n=e),[n,n===e?0:4-n%4]}function h(t,e,n){for(var o,c,output=[],i=e;i<n;i+=3)o=(t[i]<<16&16711680)+(t[i+1]<<8&65280)+(255&t[i+2]),output.push(r[(c=o)>>18&63]+r[c>>12&63]+r[c>>6&63]+r[63&c]);return output.join("")}o["-".charCodeAt(0)]=62,o["_".charCodeAt(0)]=63},function(t,e){e.read=function(t,e,n,r,o){var c,l,d=8*o-r-1,h=(1<<d)-1,f=h>>1,m=-7,i=n?o-1:0,y=n?-1:1,s=t[e+i];for(i+=y,c=s&(1<<-m)-1,s>>=-m,m+=d;m>0;c=256*c+t[e+i],i+=y,m-=8);for(l=c&(1<<-m)-1,c>>=-m,m+=r;m>0;l=256*l+t[e+i],i+=y,m-=8);if(0===c)c=1-f;else{if(c===h)return l?NaN:1/0*(s?-1:1);l+=Math.pow(2,r),c-=f}return(s?-1:1)*l*Math.pow(2,c-r)},e.write=function(t,e,n,r,o,c){var l,d,h,f=8*c-o-1,m=(1<<f)-1,y=m>>1,rt=23===o?Math.pow(2,-24)-Math.pow(2,-77):0,i=r?0:c-1,O=r?1:-1,s=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(d=isNaN(e)?1:0,l=m):(l=Math.floor(Math.log(e)/Math.LN2),e*(h=Math.pow(2,-l))<1&&(l--,h*=2),(e+=l+y>=1?rt/h:rt*Math.pow(2,1-y))*h>=2&&(l++,h/=2),l+y>=m?(d=0,l=m):l+y>=1?(d=(e*h-1)*Math.pow(2,o),l+=y):(d=e*Math.pow(2,y-1)*Math.pow(2,o),l=0));o>=8;t[n+i]=255&d,i+=O,d/=256,o-=8);for(l=l<<o|d,f+=o;f>0;t[n+i]=255&l,i+=O,l/=256,f-=8);t[n+i-O]|=128*s}},function(t,e){var n={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==n.call(t)}},function(t,e,n){"use strict";(function(t){var e=n(244);const r=()=>n(364);let o;class c{constructor(){this.util=n(365),this.textEncoder=new this.util.TextEncoder}fetch(path,t){return null!=Object(e.b)().global.fetch?Object(e.b)().global.fetch(path,t):(null==o&&(o=r()),o(path,t))}now(){const time=t.hrtime();return 1e3*time[0]+time[1]/1e6}encode(text,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(text)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}}Object(e.b)().get("IS_NODE")&&Object(e.b)().setPlatform("node",new c)}).call(this,n(171))},function(t,e,n){"use strict";var r,o;n.d(e,"a",(function(){return r})),function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(r||(r={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(o||(o={}))},function(t,e,n){"use strict";n.r(e),n.d(e,"json",(function(){return r}));const r=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},function(t,e,n){"use strict";n.r(e),n.d(e,"json",(function(){return r}));const r=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"clip_value_min",name:"clipValueMin",type:"number"},{tfName:"clip_value_max",name:"clipValueMax",type:"number"}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"clipValueMin",name:"clipValueMin",type:"number",defaultValue:0},{tfName:"clipValueMax",name:"clipValueMax",type:"number",defaultValue:6}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},function(t,e,n){"use strict";n.r(e),n.d(e,"json",(function(){return r}));const r=[{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}]},function(t,e,n){"use strict";n.r(e),n.d(e,"json",(function(){return r}));const r=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]},function(t,e,n){"use strict";n.r(e),n.d(e,"json",(function(){return r}));const r=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]},function(t,e,n){"use strict";n.r(e),n.d(e,"json",(function(){return r}));const r=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},function(t,e,n){"use strict";n.r(e),n.d(e,"json",(function(){return r}));const r=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]},function(t,e,n){"use strict";n.r(e),n.d(e,"json",(function(){return r}));const r=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]},function(t,e,n){"use strict";n.r(e),n.d(e,"json",(function(){return r}));const r=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}]},function(t,e,n){"use strict";n.r(e),n.d(e,"json",(function(){return r}));const r=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},function(t,e,n){"use strict";n.r(e),n.d(e,"json",(function(){return r}));const r=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},function(t,e,n){"use strict";n.r(e),n.d(e,"json",(function(){return r}));const r=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}]},function(t,e,n){"use strict";n.r(e),n.d(e,"json",(function(){return r}));const r=[{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]},function(t,e,n){"use strict";n.r(e),n.d(e,"json",(function(){return r}));const r=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool",notSupported:!0}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}]},function(t,e,n){"use strict";n.r(e),n.d(e,"json",(function(){return r}));const r=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]},function(t,e,n){"use strict";n.r(e),n.d(e,"json",(function(){return r}));const r=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}]},function(t,e,n){var r=n(538),o=n(539),c=n(540),l=n(541),d=n(542),h=n(543),f=n(544);f.alea=r,f.xor128=o,f.xorwow=c,f.xorshift7=l,f.xor4096=d,f.tychei=h,t.exports=f},function(t,e,n){(function(t){var r;!function(t,o,c){function l(t){var e,n=this,r=(e=4022871197,function(data){data=data.toString();for(var i=0;i<data.length;i++){var t=.02519603282416938*(e+=data.charCodeAt(i));t-=e=t>>>0,e=(t*=e)>>>0,e+=4294967296*(t-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(t),n.s0<0&&(n.s0+=1),n.s1-=r(t),n.s1<0&&(n.s1+=1),n.s2-=r(t),n.s2<0&&(n.s2+=1),r=null}function d(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function h(t,e){var n=new l(t),r=e&&e.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&("object"==typeof r&&d(r,n),o.state=function(){return d(n,{})}),o}o&&o.exports?o.exports=h:n(254)&&n(300)?void 0===(r=function(){return h}.call(e,n,e,o))||(o.exports=r):this.alea=h}(0,t,n(254))}).call(this,n(299)(t))},function(t,e,n){(function(t){var r;!function(t,o,c){function l(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function d(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function h(t,e){var n=new l(t),r=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&d(r,n),o.state=function(){return d(n,{})}),o}o&&o.exports?o.exports=h:n(254)&&n(300)?void 0===(r=function(){return h}.call(e,n,e,o))||(o.exports=r):this.xor128=h}(0,t,n(254))}).call(this,n(299)(t))},function(t,e,n){(function(t){var r;!function(t,o,c){function l(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function d(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function h(t,e){var n=new l(t),r=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&d(r,n),o.state=function(){return d(n,{})}),o}o&&o.exports?o.exports=h:n(254)&&n(300)?void 0===(r=function(){return h}.call(e,n,e,o))||(o.exports=r):this.xorwow=h}(0,t,n(254))}).call(this,n(299)(t))},function(t,e,n){(function(t){var r;!function(t,o,c){function l(t){var e=this;e.next=function(){var t,n,r=e.x,i=e.i;return t=r[i],n=(t^=t>>>7)^t<<24,n^=(t=r[i+1&7])^t>>>10,n^=(t=r[i+3&7])^t>>>3,n^=(t=r[i+4&7])^t<<7,t=r[i+7&7],n^=(t^=t<<13)^t<<9,r[i]=n,e.i=i+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function d(t,e){return e.x=t.x.slice(),e.i=t.i,e}function h(t,e){null==t&&(t=+new Date);var n=new l(t),r=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,r&&(r.x&&d(r,n),o.state=function(){return d(n,{})}),o}o&&o.exports?o.exports=h:n(254)&&n(300)?void 0===(r=function(){return h}.call(e,n,e,o))||(o.exports=r):this.xorshift7=h}(0,t,n(254))}).call(this,n(299)(t))},function(t,e,n){(function(t){var r;!function(t,o,c){function l(t){var e=this;e.next=function(){var t,n,r=e.w,o=e.X,i=e.i;return e.w=r=r+1640531527|0,n=o[i+34&127],t=o[i=i+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=o[i]=n^t,e.i=i,n+(r^r>>>16)|0},function(t,e){var n,r,i,o,c,l=[],d=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,d=Math.max(d,e.length)),i=0,o=-32;o<d;++o)e&&(r^=e.charCodeAt((o+32)%e.length)),0===o&&(c=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,o>=0&&(c=c+1640531527|0,i=0==(n=l[127&o]^=r+c)?i+1:0);for(i>=128&&(l[127&(e&&e.length||0)]=-1),i=127,o=512;o>0;--o)r=l[i+34&127],n=l[i=i+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,l[i]=r^n;t.w=c,t.X=l,t.i=i}(e,t)}function d(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function h(t,e){null==t&&(t=+new Date);var n=new l(t),r=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,r&&(r.X&&d(r,n),o.state=function(){return d(n,{})}),o}o&&o.exports?o.exports=h:n(254)&&n(300)?void 0===(r=function(){return h}.call(e,n,e,o))||(o.exports=r):this.xor4096=h}(0,t,n(254))}).call(this,n(299)(t))},function(t,e,n){(function(t){var r;!function(t,o,c){function l(t){var e=this,n="";e.next=function(){var b=e.b,t=e.c,n=e.d,a=e.a;return b=b<<25^b>>>7^t,t=t-n|0,n=n<<24^n>>>8^a,a=a-b|0,e.b=b=b<<20^b>>>12^t,e.c=t=t-n|0,e.d=n<<16^t>>>16^a,e.a=a-b|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function d(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function h(t,e){var n=new l(t),r=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&d(r,n),o.state=function(){return d(n,{})}),o}o&&o.exports?o.exports=h:n(254)&&n(300)?void 0===(r=function(){return h}.call(e,n,e,o))||(o.exports=r):this.tychei=h}(0,t,n(254))}).call(this,n(299)(t))},function(t,e,n){var r;!function(o,c){var l,d=this,h=256,f=c.pow(h,6),m=c.pow(2,52),y=2*m,mask=255;function O(t,e,n){var r=[],O=j(w((e=1==e?{entropy:!0}:e||{}).entropy?[t,E(o)]:null==t?function(){try{var t;return l&&(t=l.randomBytes)?t=t(h):(t=new Uint8Array(h),(d.crypto||d.msCrypto).getRandomValues(t)),E(t)}catch(t){var e=d.navigator,n=e&&e.plugins;return[+new Date,d,n,d.screen,E(o)]}}():t,3),r),$=new x(r),C=function(){for(var t=$.g(6),e=f,n=0;t<m;)t=(t+n)*h,e*=h,n=$.g(1);for(;t>=y;)t/=2,e/=2,n>>>=1;return(t+n)/e};return C.int32=function(){return 0|$.g(4)},C.quick=function(){return $.g(4)/4294967296},C.double=C,j(E($.S),o),(e.pass||n||function(t,e,n,r){return r&&(r.S&&v(r,$),t.state=function(){return v($,{})}),n?(c.random=t,e):t})(C,O,"global"in e?e.global:this==c,e.state)}function x(t){var e,n=t.length,r=this,i=0,o=r.i=r.j=0,s=r.S=[];for(n||(t=[n++]);i<h;)s[i]=i++;for(i=0;i<h;i++)s[i]=s[o=mask&o+t[i%n]+(e=s[i])],s[o]=e;(r.g=function(t){for(var e,n=0,i=r.i,o=r.j,s=r.S;t--;)e=s[i=mask&i+1],n=n*h+s[mask&(s[i]=s[o=mask&o+e])+(s[o]=e)];return r.i=i,r.j=o,n})(h)}function v(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function w(t,e){var n,r=[],o=typeof t;if(e&&"object"==o)for(n in t)try{r.push(w(t[n],e-1))}catch(t){}return r.length?r:"string"==o?t:t+"\0"}function j(t,e){for(var n,r=t+"",o=0;o<r.length;)e[mask&o]=mask&(n^=19*e[mask&o])+r.charCodeAt(o++);return E(e)}function E(a){return String.fromCharCode.apply(0,a)}if(c.seedrandom=O,j(c.random(),o),t.exports){t.exports=O;try{l=n(406)}catch(t){}}else void 0===(r=function(){return O}.call(e,n,e,t))||(t.exports=r)}([],Math)}])]);